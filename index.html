<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WPS 3.0</title>
    <!-- Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the Inter font and overall body */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* Light grey background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px; /* Add some padding for smaller screens */
            box-sizing: border-box; /* Ensure padding doesn't cause overflow */
        }
        /* Style for the message box (e.g., error/success messages) */
        .message-box {
            padding: 10px;
            border-radius: 8px;
            margin-top: 15px;
            text-align: center;
            font-weight: bold;
        }
        .message-box.error {
            background-color: #fee2e2; /* Red-ish background */
            color: #ef4444; /* Red text */
            border: 1px solid #ef4444;
        }
        .message-box.success {
            background-color: #d1fae5; /* Green-ish background */
            color: #10b981; /* Green text */
            border: 1px solid #10b981;
        }
        .message-box.info {
            background-color: #bfdbfe; /* Blue-ish background */
            color: #3b82f6; /* Blue text */
            border: 1px solid #3b82f6;
        }
        /* Styling for log entries */
        .log-entry {
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            padding: 8px;
            margin-bottom: 4px;
            border-radius: 4px;
            font-size: 0.875rem;
            color: #4b5563;
            text-align: left;
        }
        .log-entry strong {
            color: #1f2937;
        }
        /* Table styles for user management */
        .user-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        .user-table th, .user-table td {
            border: 1px solid #e2e8f0;
            padding: 8px;
            text-align: left;
        }
        .user-table th {
            background-color: #e0f2fe;
            color: #2563eb;
            font-weight: bold;
        }
        .user-table tr:nth-child(even) {
            background-color: #f8fafc;
        }
        .user-table select {
            width: 100%;
            padding: 4px;
            border-radius: 4px;
            border: 1px solid #cbd5e1;
        }
    </style>
</head>
<body class="bg-gray-100 font-inter">

    <!-- Main Login Container -->
    <div class="bg-white p-8 rounded-xl shadow-lg w-full max-w-sm sm:max-w-md md:max-w-lg lg:max-w-xl flex flex-col items-center">
        <h2 class="text-3xl md:text-4xl font-bold text-gray-800 mb-6">WPS Login</h2>

        <!-- Loading Indicator -->
        <div id="loadingIndicator" class="hidden flex items-center justify-center p-4">
            <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <span class="text-gray-600">Initializing Firebase...</span>
        </div>

        <!-- Login Buttons -->
        <div id="loginButtonsContainer" class="w-full flex flex-col items-center space-y-3 hidden">
            <button
                type="button"
                id="googleLoginButton"
                class="w-full flex items-center justify-center bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg"
            >
                <!-- Google Icon SVG -->
                <svg class="w-5 h-5 mr-2" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12.0001 4.5V7.5L17.2501 7.5C17.0279 8.65312 16.3989 9.69736 15.4883 10.4514C14.5776 11.2054 13.4357 11.6212 12.2501 11.6212C9.40006 11.6212 6.99999 9.40871 6.99999 6.55871C6.99999 3.70871 9.40006 1.49621 12.2501 1.49621C13.6874 1.49621 14.9754 2.05267 15.9388 2.92305L18.1565 0.705359C16.5912 -0.80332 14.4754 -1.54716e-07 12.2501 -1.54716e-07C7.26627 -1.54716e-07 3.00006 4.26627 3.00006 9.25006C3.00006 14.2338 7.26627 18.5 12.2501 18.5C14.6738 18.5 16.6346 17.6534 18.0626 16.1436C19.5398 14.6338 19.9999 12.3501 19.9999 9.94006C19.9999 9.25006 19.9312 8.57506 19.8001 7.92506L12.0001 7.92506V4.5Z" fill="#fff"/>
                </svg>
                Sign In with Google
            </button>
            <!-- Email/Password button removed -->
        </div>


        <!-- Message Box for Login Status -->
        <div id="messageBox" class="message-box hidden w-full text-sm md:text-base"></div>

        <!-- Logout Button (Initially hidden) -->
        <button
            id="logoutButton"
            class="hidden mt-4 w-full bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg"
        >
            Logout
        </button>

        <!-- "View User Directory" Button (Initially hidden) -->
        <button
            id="viewUserDirectoryButton"
            class="hidden mt-4 w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg"
        >
            View User Directory
        </button>

        <!-- "Open Account Management" Button (Initially hidden) -->
        <button
            id="openAccountManagementButton"
            class="hidden mt-4 w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg"
        >
            Manage Account
        </button>

        <!-- "Open Admin Panel" Button (Initially hidden, for admins) -->
        <button
            id="openAdminPanelButton"
            class="hidden mt-4 w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg"
        >
            Admin Panel
        </button>

        <!-- "Join a Game" Button (Initially hidden, for all logged-in users) -->
        <button
            id="joinGameButton"
            class="hidden mt-4 w-full bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-orange-500 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg"
        >
            Join a Game
        </button>

        <!-- Admin Panel (Initially hidden) -->
        <div id="adminPanel" class="hidden mt-8 p-6 bg-gray-50 rounded-xl shadow-inner w-full text-center">
            <h3 class="text-2xl md:text-3xl font-bold text-gray-700 mb-4">Admin Panel</h3>
            <p class="text-gray-600 mb-6 text-sm md:text-base">
                Welcome, Administrator! From here, you can manage users, game data, and other aspects of the WPS system.
                <br>
                <strong class="text-red-500">Note: User management will only show users who have logged in via Firebase Auth.</strong>
            </p>
            <div class="space-y-4">
                <button id="manageUsersButton" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Manage Users
                </button>
                <button id="manageGameRoomsButton" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Manage Game Rooms
                </button>
                <button class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Manage Game Data (Placeholder)
                </button>
                <button class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Configure Games
                </button>
                <!-- "View Activity Logs" button removed -->
                <button id="manageAccountButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Account Management
                </button>
                <button id="closeAdminPanelButton" class="mt-6 w-1/2 mx-auto bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Close Admin Panel
                </button>
            </div>
        </div>

        <!-- User Management Panel (Initially hidden) -->
        <div id="userManagementPanel" class="hidden mt-8 p-6 bg-gray-50 rounded-xl shadow-inner w-full max-w-md md:max-w-lg lg:max-w-xl">
            <h3 class="text-2xl md:text-3xl font-bold text-gray-700 mb-4 text-center">User Management</h3>
            <p class="text-gray-600 mb-4 text-center text-sm md:text-base">
                Assign roles to users who have logged in.
                <br>
                <strong class="text-red-500">Important: This is a client-side role management for demonstration. For production, consider using Firebase Cloud Functions for secure role assignment.</strong>
            </p>
            <div class="overflow-x-auto">
                <table class="user-table text-sm md:text-base">
                    <thead>
                        <tr>
                            <th>Display Name</th>
                            <th>Chip Count</th>
                            <th>Role</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="userRolesTableBody">
                        <!-- User rows will be rendered here -->
                        <tr><td colspan="3" class="text-center text-gray-500">Loading users...</td></tr>
                    </tbody>
                </table>
            </div>
            <div class="flex justify-between space-x-2 mt-4">
                <button id="saveUserRolesButton" class="w-1/2 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Save Changes
                </button>
                <button id="hideUserManagementButton" class="w-1/2 bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Hide Panel
                </button>
            </div>
        </div>

        <!-- Game Room Management Panel (Initially hidden) -->
        <div id="gameRoomManagementPanel" class="hidden mt-8 p-6 bg-gray-50 rounded-xl shadow-inner w-full max-w-lg md:max-w-xl">
            <h3 class="text-2xl md:text-3xl font-bold text-gray-700 mb-6 text-center">Manage Game Rooms</h3>

            <!-- Create New Game Room Section -->
            <div class="mb-6 p-4 border border-gray-200 rounded-lg bg-white">
                <h4 class="text-lg font-semibold text-gray-700 mb-3">Create New Game Room</h4>
                <div class="flex flex-col sm:flex-row items-stretch sm:items-end space-y-2 sm:space-y-0 sm:space-x-2">
                    <div class="flex-grow">
                        <label for="newRoomNameInput" class="block text-sm font-medium text-gray-700 mb-1">Room Name:</label>
                        <input type="text" id="newRoomNameInput" placeholder="e.g., Main Event Table 1" class="w-full border rounded-lg py-2 px-3 text-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                    <button id="createGameRoomButton" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out sm:w-auto w-full">
                        Create Room
                    </button>
                </div>
            </div>

            <!-- Existing Game Rooms List Section -->
            <div>
                <h4 class="text-lg font-semibold text-gray-700 mb-3">Existing Rooms</h4>
                <div id="gameRoomsListContainer" class="max-h-80 overflow-y-auto border border-gray-200 p-2 rounded-lg bg-white">
                    <p class="text-gray-500 text-center py-4">Loading rooms...</p>
                    <!-- Game rooms will be listed here by JavaScript -->
                </div>
            </div>

            <div class="flex justify-center mt-6">
                <button id="closeGameRoomManagementPanelButton" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105">
                    Close & Return to Admin Panel
                </button>
            </div>
        </div>

        <!-- Player Join Room Panel (Initially hidden) -->
        <div id="playerJoinRoomPanel" class="hidden mt-8 p-6 bg-gray-50 rounded-xl shadow-inner w-full max-w-lg md:max-w-xl">
            <h3 class="text-2xl md:text-3xl font-bold text-gray-700 mb-6 text-center">Available Game Rooms</h3>
            
            <div id="availableRoomsListContainer" class="max-h-96 overflow-y-auto border border-gray-200 p-2 rounded-lg bg-white">
                <p class="text-gray-500 text-center py-4">Loading available rooms...</p>
                <!-- Available game rooms will be listed here by JavaScript -->
            </div>

            <div class="flex justify-center mt-6">
                <button id="closePlayerJoinRoomPanelButton" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105">
                    Close
                </button>
            </div>
        </div>

        <!-- Game Room View Panel (Initially hidden) -->
        <div id="gameRoomViewPanel" class="hidden mt-8 p-4 sm:p-6 bg-gray-800 text-white rounded-xl shadow-xl w-full max-w-2xl lg:max-w-4xl">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-2xl md:text-3xl font-bold" id="gameRoomViewName">Room Name Placeholder</h3>
                <button id="closeGameRoomViewButton" class="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-4 rounded-lg text-sm transition duration-150">
                    Return to Lobby
                </button>
            </div>

            <!-- Player List Area -->
            <div class="mb-6">
                <h4 class="text-xl font-semibold mb-3 text-gray-300">Players in Room</h4>
                <div id="roomPlayersListContainer" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3 max-h-72 overflow-y-auto p-2 bg-gray-700 rounded">
                    <!-- Player cards will be rendered here by JavaScript -->
                    <p class="text-gray-400 col-span-full text-center py-4">Waiting for players...</p>
                </div>
            </div>
            
            <!-- Game Stats Area -->
            <div id="gameStatsContainer" class="mb-6 p-4 border border-gray-600 rounded-lg bg-gray-700">
                <h4 class="text-lg font-semibold text-gray-300 mb-3">Game Stats</h4>
                <div id="gameStatsContent" class="text-gray-300">
                    <p>Loading game stats...</p>
                </div>
                <!-- Admin Game Controls -->
                <div id="adminGameControls" class="mt-4 pt-4 border-t border-gray-600 hidden">
                    <h5 class="text-md font-semibold text-gray-200 mb-2">Admin Controls</h5>
                    <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-2">
                        <button id="adminRoomResetButton" class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-3 rounded-lg text-sm transition duration-150 ease-in-out flex-1">
                            Room Reset
                        </button>
                        <button id="adminUpdateChipsButton" class="bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-3 rounded-lg text-sm transition duration-150 ease-in-out flex-1">
                            Update Chips
                        </button>
                    </div>
                </div>
            </div>

            <!-- Update Chips Panel (Admin Only, Initially Hidden) -->
            <div id="updateChipsPanel" class="hidden p-4 my-4 border border-gray-600 rounded-lg bg-gray-700">
                <h4 class="text-lg font-semibold text-gray-200 mb-3">Update Player Chips After Hand</h4>
                <div id="updateChipsPlayerList" class="space-y-3 mb-4 max-h-60 overflow-y-auto">
                    <!-- Player entries will be populated here by JavaScript -->
                    <p class="text-gray-400">Loading players...</p>
                </div>
                <div class="flex justify-end space-x-3">
                    <button id="cancelChipUpdate" class="bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg text-sm transition duration-150">
                        Cancel
                    </button>
                    <button id="submitChipUpdate" class="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-lg text-sm transition duration-150">
                        Submit Chip Updates
                    </button>
                </div>
            </div>

            <!-- Player Bet Input Section -->
            <div class="p-4 border border-gray-600 rounded-lg bg-gray-700">
                <h4 class="text-lg font-semibold text-gray-300 mb-3">Your Bet</h4>
                <div class="flex flex-col sm:flex-row items-stretch sm:items-end space-y-3 sm:space-y-0 sm:space-x-3">
                    <div class="flex-grow">
                        <label for="playerBetInput" class="block text-sm font-medium text-gray-300 mb-1">Enter Amount:</label>
                        <input type="number" id="playerBetInput" placeholder="0" class="w-full border-gray-500 bg-gray-600 text-white rounded-lg py-2 px-3 focus:outline-none focus:ring-2 focus:ring-blue-500" min="0">
                        <p class="text-xs text-gray-400 mt-1">Your chips: <span id="playerChipCountForBet">N/A</span></p>
                    </div>
                    <button id="placeBetButton" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out sm:w-auto w-full">
                        Place Bet
                    </button>
                    <button id="foldButton" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out sm:w-auto w-full">
                        Fold
                    </button>
                    <button id="allInButton" class="bg-red-700 hover:bg-red-800 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out sm:w-auto w-full">
                        All-In
                    </button>
                </div>
            </div>

            <div class="flex justify-center mt-6">
                 <button id="leaveCurrentGameRoomButton" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105">
                    Leave Room
                </button>
            </div>
        </div>


        <!-- Account Management Panel (Initially hidden) -->
        <div id="accountManagementPanel" class="hidden mt-8 p-6 bg-gray-50 rounded-xl shadow-inner w-full max-w-md md:max-w-lg text-center">
            <h3 class="text-2xl md:text-3xl font-bold text-gray-700 mb-4">Account Management</h3>
            <div class="flex flex-col items-center space-y-4">
                <img id="userProfilePic" class="w-24 h-24 md:w-32 md:h-32 rounded-full border-4 border-blue-400 shadow-md" src="" alt="Profile Picture">
                <p class="text-xl md:text-2xl font-semibold text-gray-800" id="currentUserName"></p>
                <p class="text-gray-600 text-sm md:text-base" id="currentUserUsername"></p>
                <p class="text-gray-500 text-xs md:text-sm" id="currentUserProvider"></p>

                <div class="w-full space-y-3 pt-4 border-t border-gray-200 mt-4">
                    <button
                        type="button"
                        id="linkGoogleAccountButton"
                        class="w-full flex items-center justify-center bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg"
                    >
                        <svg class="w-5 h-5 mr-2" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12.0001 4.5V7.5L17.2501 7.5C17.0279 8.65312 16.3989 9.69736 15.4883 10.4514C14.5776 11.2054 13.4357 11.6212 12.2501 11.6212C9.40006 11.6212 6.99999 9.40871 6.99999 6.55871C6.99999 3.70871 9.40006 1.49621 12.2501 1.49621C13.6874 1.49621 14.9754 2.05267 15.9388 2.92305L18.1565 0.705359C16.5912 -0.80332 14.4754 -1.54716e-07 12.2501 -1.54716e-07C7.26627 -1.54716e-07 3.00006 4.26627 3.00006 9.25006C3.00006 14.2338 7.26627 18.5 12.2501 18.5C14.6738 18.5 16.6346 17.6534 18.0626 16.1436C19.5398 14.6338 19.9999 12.3501 19.9999 9.94006C19.9999 9.25006 19.9312 8.57506 19.8001 7.92506L12.0001 7.92506V4.5Z" fill="#fff"/>
                        </svg>
                        Link with Google
                    </button>
                    <button class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                        Change Password (Placeholder)
                    </button>
                    <button class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                        Update Profile (Placeholder)
                    </button>
                </div>
                <button id="hideAccountManagementButton" class="w-full bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Close Account Management
                </button>
            </div>
        </div>


        <!-- Activity Log Viewer (REMOVED) -->

        <!-- User Directory Panel -->
        <div id="userDirectoryPanel" class="hidden mt-8 p-6 bg-gray-50 rounded-xl shadow-inner w-full max-w-lg md:max-w-xl lg:max-w-2xl">
            <h3 class="text-2xl md:text-3xl font-bold text-gray-700 mb-4 text-center">User Directory</h3>
            <div class="overflow-x-auto">
                <table class="user-table text-sm md:text-base">
                    <thead>
                        <tr>
                            <th>Display Name</th>
                            <th>Chip Count</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="userDirectoryTableBody">
                        <!-- User rows will be rendered here by JavaScript -->
                        <tr><td colspan="2" class="text-center text-gray-500 py-4">Loading...</td></tr>
                    </tbody>
                </table>
            </div>
            <div class="flex justify-center mt-4">
                <button id="hideUserDirectoryPanelButton" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Close
                </button>
            </div>
        </div>

    </div>

    <script type="module">
        // Import Firebase SDKs
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-analytics.js";
        import { getAuth, signInWithCustomToken, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, linkWithPopup, signOut } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, addDoc, onSnapshot, collection, query, getDocs, deleteDoc, serverTimestamp, orderBy, updateDoc, arrayUnion, arrayRemove, deleteField } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";

        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyBefsHEBuiRyJ31NzF885ac3ugCefzngTU",
            authDomain: "wps-3-be723.firebaseapp.com",
            projectId: "wps-3-be723",
            storageBucket: "wps-3-be723.firebasestorage.app",
            messagingSenderId: "420146617877",
            appId: "1:420146617877:web:ea2e06a690732da76fb81c",
            measurementId: "G-H0Z4C2185Y"
        };

        const appId = typeof __app_id !== 'undefined' ? __app_id : firebaseConfig.projectId;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Initialize Firebase
        const firebaseApp = initializeApp(firebaseConfig);
        const analytics = getAnalytics(firebaseApp);
        const db = getFirestore(firebaseApp, 'wps-database'); // Using named database 'wps-database'
        const auth = getAuth(firebaseApp);
        const googleProvider = new GoogleAuthProvider();


        // Track Firebase authentication readiness and data loading state
        let firebaseAuthReady = false;
        let isLoggingOut = false;
        let dataLoadedAndListenersSetup = false;
        let unsubscribeOwnActiveSessionListener = null; // For self-logout listener


        // --- Super Admin UID (DO NOT TOUCH THIS!) ---
        // This UID will be used to identify the initial administrator account.
        // It should be the Firebase UID of your Google account.
        const SUPER_ADMIN_UID = "Qr3XI0uNYrZ3AECim6XtRvp12MJ2";


        // --- DOM Elements ---
        const loginButtonsContainer = document.getElementById('loginButtonsContainer');
        const googleLoginButton = document.getElementById('googleLoginButton');
        // const emailPasswordLoginButton = document.getElementById('emailPasswordLoginButton'); // Removed
        const messageBox = document.getElementById('messageBox');
        const logoutButton = document.getElementById('logoutButton');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const adminPanel = document.getElementById('adminPanel');

        const manageUsersButton = document.getElementById('manageUsersButton');
        const userManagementPanel = document.getElementById('userManagementPanel');
        const userRolesTableBody = document.getElementById('userRolesTableBody');
        const saveUserRolesButton = document.getElementById('saveUserRolesButton');
        const hideUserManagementButton = document.getElementById('hideUserManagementButton');

        // const viewLogsButton = document.getElementById('viewLogsButton'); // Removed
        // const logViewer = document.getElementById('logViewer'); // Removed
        // const logEntriesContainer = document.getElementById('logEntries'); // Removed
        // const clearLogsButton = document.getElementById('clearLogsButton'); // Removed
        // const hideLogsButton = document.getElementById('hideLogsButton'); // Removed

        const manageAccountButton = document.getElementById('manageAccountButton');
        const accountManagementPanel = document.getElementById('accountManagementPanel');
        const userProfilePic = document.getElementById('userProfilePic');
        const currentUserName = document.getElementById('currentUserName');
        const currentUserUsername = document.getElementById('currentUserUsername');
        const currentUserProvider = document.getElementById('currentUserProvider');
        const linkGoogleAccountButton = document.getElementById('linkGoogleAccountButton');
        const hideAccountManagementButton = document.getElementById('hideAccountManagementButton');

        const viewUserDirectoryButton = document.getElementById('viewUserDirectoryButton'); // Changed ID
        const userDirectoryPanel = document.getElementById('userDirectoryPanel'); 
        const userDirectoryTableBody = document.getElementById('userDirectoryTableBody'); 
        const hideUserDirectoryPanelButton = document.getElementById('hideUserDirectoryPanelButton');

        const openAdminPanelButton = document.getElementById('openAdminPanelButton');
        const openAccountManagementButton = document.getElementById('openAccountManagementButton');
        const closeAdminPanelButton = document.getElementById('closeAdminPanelButton');

        const manageGameRoomsButton = document.getElementById('manageGameRoomsButton');
        const gameRoomManagementPanel = document.getElementById('gameRoomManagementPanel');
        const newRoomNameInput = document.getElementById('newRoomNameInput');
        const createGameRoomButton = document.getElementById('createGameRoomButton');
        const gameRoomsListContainer = document.getElementById('gameRoomsListContainer');
        const closeGameRoomManagementPanelButton = document.getElementById('closeGameRoomManagementPanelButton');

        const joinGameButton = document.getElementById('joinGameButton');
        const playerJoinRoomPanel = document.getElementById('playerJoinRoomPanel');
        const availableRoomsListContainer = document.getElementById('availableRoomsListContainer');
        const closePlayerJoinRoomPanelButton = document.getElementById('closePlayerJoinRoomPanelButton');

        const gameRoomViewPanel = document.getElementById('gameRoomViewPanel');
        const gameRoomViewName = document.getElementById('gameRoomViewName');
        const roomPlayersListContainer = document.getElementById('roomPlayersListContainer');
        const leaveCurrentGameRoomButton = document.getElementById('leaveCurrentGameRoomButton');
        const closeGameRoomViewButton = document.getElementById('closeGameRoomViewButton');
        const playerBetInput = document.getElementById('playerBetInput');
        const playerChipCountForBet = document.getElementById('playerChipCountForBet');
        const placeBetButton = document.getElementById('placeBetButton');
        const foldButton = document.getElementById('foldButton'); // Added Fold button
        const allInButton = document.getElementById('allInButton'); // Added All-In button

        // Admin Game Controls in Game Room View
        const adminGameControls = document.getElementById('adminGameControls');
        const adminRoomResetButton = document.getElementById('adminRoomResetButton');
        const adminUpdateChipsButton = document.getElementById('adminUpdateChipsButton');

        // Update Chips Panel Elements
        const updateChipsPanel = document.getElementById('updateChipsPanel');
        const updateChipsPlayerList = document.getElementById('updateChipsPlayerList');
        const cancelChipUpdate = document.getElementById('cancelChipUpdate');
        const submitChipUpdate = document.getElementById('submitChipUpdate');


        // const logFilterType = document.getElementById('logFilterType'); // Removed
        // const logSearchText = document.getElementById('logSearchText'); // Removed
        // const logSortOrderRadios = document.querySelectorAll('input[name="logSortOrder"]'); // Removed

        let allFirebaseUsersData = []; // Stores user profiles fetched from Firestore
        let firestoreUserRoles = {}; // Stores roles fetched from Firestore
        // let firestoreActivityLogs = []; // Removed
        let firestoreActiveSessions = []; // Stores active sessions from Firestore
        let firestoreGameRooms = []; // Stores game rooms fetched from Firestore
        let currentJoinedRoomId = null; // Stores the ID of the room the current player has joined

        const ROLES = ['disabled', 'player', 'admin', 'owner']; // Defined roles for the system


        // --- Role Helper Functions ---
        function getCurrentUserRole(uid) {
            if (!uid) return 'player'; // Default for cases where UID might be null
            return firestoreUserRoles[uid]?.role || 'player'; // Default to 'player'
        }

        function isOwner(uid) {
            if (!uid) return false;
            // SUPER_ADMIN_UID is always considered an owner for bootstrapping purposes.
            // Otherwise, explicit 'owner' role is required.
            return uid === SUPER_ADMIN_UID || getCurrentUserRole(uid) === 'owner';
        }

        function hasAdminAccess(uid) {
            if (!uid) return false;
            const role = getCurrentUserRole(uid);
            // SUPER_ADMIN_UID, 'owner', or 'admin' roles grant admin panel access.
            return uid === SUPER_ADMIN_UID || role === 'owner' || role === 'admin';
        }

        // --- Listener for Own Active Session (for remote/forced logout detection) ---
        function setupOwnActiveSessionListener(uid) {
            if (unsubscribeOwnActiveSessionListener) {
                console.log("Unsubscribing from previous own active session listener.");
                unsubscribeOwnActiveSessionListener(); 
                unsubscribeOwnActiveSessionListener = null;
            }

            if (!uid) {
                console.error("Cannot setup own active session listener without UID.");
                return; 
            }

            const sessionDocRef = doc(activeSessionsCollectionRef, uid);
            console.log(`Setting up listener for own active session: active_sessions/${uid}`);

            unsubscribeOwnActiveSessionListener = onSnapshot(sessionDocRef, (docSnap) => {
                console.log(`Own active session listener event: exists=${docSnap.exists()}`);
                if (!docSnap.exists()) {
                    // Document was deleted
                    console.log("Own active session document deleted, potentially by force logout or other means.");
                    if (auth.currentUser && auth.currentUser.uid === uid && !isLoggingOut) { 
                        // Check if still the same user and not already in the process of logging out
                        console.log("Current user matches and not already logging out. Initiating self-logout.");
                        isLoggingOut = true; // Set flag early to prevent race conditions/re-entry
                        showMessage("Your session has been ended remotely. You are now being logged out.", "info");
                        
                        if (unsubscribeOwnActiveSessionListener) {
                            console.log("Unsubscribing from own active session listener before forced logout.");
                            unsubscribeOwnActiveSessionListener();
                            unsubscribeOwnActiveSessionListener = null;
                        }

                        // Delay slightly to allow message to be seen, then logout
                        setTimeout(() => {
                            handleLogout(); 
                        }, 3000); 
                    } else {
                        console.log("Self-logout condition not met:", 
                                    {currentUser: auth.currentUser?.uid, targetUid: uid, isLoggingOutFlag: isLoggingOut});
                    }
                }
            }, (error) => {
                console.error(`Error listening to own active session (active_sessions/${uid}):`, error);
                // Optionally, inform the user if this critical listener fails
                // showMessage("Error: Could not monitor session status. Please refresh.", "error");
            });
        }


        // Firestore Collection References (implicitly pointing to 'user-data' database)
        const userRolesCollectionRef = collection(db, `artifacts/${appId}/public/data/user_roles`);
        const activityLogsCollectionRef = collection(db, `artifacts/${appId}/public/data/activity_logs`);
        const userProfilesCollectionRef = collection(db, `artifacts/${appId}/public/data/user_profiles`);
        const activeSessionsCollectionRef = collection(db, `artifacts/${appId}/public/data/active_sessions`);
        const gameRoomsCollectionRef = collection(db, `artifacts/${appId}/public/data/game_rooms`);


        // --- Utility Functions ---
        function showPanel(panelToShow) {
            // logViewer variable was removed, so it's no longer in this list.
            const panels = [loginButtonsContainer, adminPanel, userManagementPanel, accountManagementPanel, userDirectoryPanel, gameRoomManagementPanel, playerJoinRoomPanel, gameRoomViewPanel, loadingIndicator];
            panels.forEach(panel => {
                if (panel === panelToShow) {
                    panel.classList.remove('hidden');
                } else {
                    panel.classList.add('hidden');
                }
            });
        }

        function showMessage(message, type = 'error') {
            messageBox.textContent = message;
            messageBox.className = `message-box ${type} w-full`;
            messageBox.classList.remove('hidden');
            setTimeout(hideMessage, 5000); // Auto-hide messages after 5 seconds
        }

        function hideMessage() {
            messageBox.classList.add('hidden');
        }

        // --- Helper function to format display names ---
        function formatDisplayName(user) {
            if (!user || typeof user.displayName !== 'string' || typeof user.email !== 'string') {
                // Return a fallback if essential user properties are missing or not strings
                return (user && typeof user.displayName === 'string') ? user.displayName : (user && typeof user.email === 'string' ? user.email : 'N/A');
            }

            let displayName = user.displayName;
            // Ensure email is present and is a string before trying to operate on it
            if (user.email && typeof user.email === 'string') {
                const emailParts = user.email.split('@');
                if (emailParts.length === 2) {
                    const emailDomain = emailParts[1].toLowerCase();
                    if (emailDomain === 'wrsdk12.net') {
                        if (!displayName.endsWith(" (School)")) {
                            displayName += " (School)";
                        }
                    }
                }
            }
            return displayName;
        }


        // --- Log System Functions (Firestore Integrated) ---
        // addLogEntry function and its calls are being removed.

        // Log-related functions populateLogFilterTypes, renderLogs, clearLogs REMOVED.
        
        // --- End Log System Functions ---


        // --- User Management Functions (Firestore Integrated) ---
        async function saveUserChangesToFirestore(changesMap) { // Renamed and updated parameter
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to save user changes.", 'error');
                // addLogEntry("Save User Changes Attempt Failed", { reason: "Permission denied", by: auth.currentUser?.uid }); // Removed
                return;
            }

            const currentUserIsOwner = isOwner(auth.currentUser.uid);
            showMessage("Saving user changes...", 'info');

            try {
                // Fetch current roles and profiles for robust old value checks and to avoid unnecessary writes.
                const rolesSnapshot = await getDocs(userRolesCollectionRef);
                const currentFirestoreRoles = {};
                rolesSnapshot.forEach(doc => currentFirestoreRoles[doc.id] = doc.data());

                const profilesSnapshot = await getDocs(userProfilesCollectionRef);
                const currentFirestoreProfiles = {};
                profilesSnapshot.forEach(doc => currentFirestoreProfiles[doc.id] = doc.data());

                for (const uid in changesMap) {
                    const { newRole, newChipCount } = changesMap[uid];
                    const oldRole = currentFirestoreRoles[uid]?.role || 'player';
                    const oldChipCount = currentFirestoreProfiles[uid]?.chip_count; // Can be undefined or number

                    let roleChanged = oldRole !== newRole;
                    // Chip count comparison needs to handle undefined and ensure numeric comparison
                    let chipCountChanged = typeof oldChipCount === 'undefined' || oldChipCount !== newChipCount;
                    if (typeof newChipCount !== 'number') { // Ensure newChipCount is a number before saving
                        showMessage(`Invalid chip count for user ${uid}. Must be a number.`, 'error');
                        // addLogEntry("Invalid Chip Count Input", {targetUser: uid, value: newChipCount}); // Removed
                        continue; // Skip this user if chip count is not a number
                    }


                    // **Permission Checks**
                    // These apply to both role and chip count changes for simplicity unless specific fine-grained control is needed.
                    // If a user cannot have their role changed, they likely shouldn't have chip count changed by that admin either.

                    // 0. SUPER_ADMIN_UID: Role must be 'owner', chip count cannot be changed by non-owners (effectively, should not be changed by anyone but system/self if needed)
                    if (uid === SUPER_ADMIN_UID) {
                        if (newRole !== 'owner') {
                            showMessage(`SUPER_ADMIN (${uid}) role cannot be changed from 'owner'.`, 'error');
                            // addLogEntry("SUPER_ADMIN Role Change Blocked", { attemptedRole: newRole, by: auth.currentUser.uid }); // Removed
                            roleChanged = false; // Do not proceed with role change
                        }
                        // For SUPER_ADMIN, only allow chip count change if current user is owner (which SUPER_ADMIN is).
                        // Effectively, this means SUPER_ADMIN can change their own chips if UI allowed, or another owner could.
                        // But generally, we want to protect SUPER_ADMIN from accidental changes by other admins.
                        // The UI already disables these fields if current user is not owner.
                        // This server-side check ensures it.
                        if (!currentUserIsOwner && chipCountChanged) {
                             showMessage(`Chip count for SUPER_ADMIN (${uid}) cannot be changed by non-owners.`, 'error');
                             // addLogEntry("SUPER_ADMIN Chip Count Change Blocked", { by: auth.currentUser.uid }); // Removed
                             chipCountChanged = false; // Do not proceed
                        }
                    }
                    // 1. Only an owner can assign the 'owner' role.
                    else if (newRole === 'owner' && !currentUserIsOwner) {
                        showMessage(`You do not have permission to assign 'owner' role to ${uid}.`, 'error');
                        // addLogEntry("Assign Owner Role Failed", { targetUser: uid, by: auth.currentUser.uid }); // Removed
                        roleChanged = false;
                    }
                    // 2. An admin cannot change an owner's role or chip count. Only another owner can.
                    else if (oldRole === 'owner' && !currentUserIsOwner) {
                        if (roleChanged) {
                            showMessage(`You do not have permission to change role of owner ${uid}.`, 'error');
                            // addLogEntry("Modify Owner Role Failed", { targetUser: uid, by: auth.currentUser.uid }); // Removed
                            roleChanged = false;
                        }
                        if (chipCountChanged) {
                            showMessage(`You do not have permission to change chip count of owner ${uid}.`, 'error');
                            // addLogEntry("Modify Owner Chip Count Failed", { targetUser: uid, by: auth.currentUser.uid }); // Removed
                            chipCountChanged = false;
                        }
                    }
                    // 3. Prevent last owner from demoting themselves (SUPER_ADMIN is a fallback).
                    else if (uid === auth.currentUser.uid && currentUserIsOwner && (newRole === 'disabled' || newRole === 'player' || newRole === 'admin')) {
                        const ownersInFirestore = Object.keys(currentFirestoreRoles).filter(id => currentFirestoreRoles[id]?.role === 'owner');
                        // Check against currentFirestoreRoles which is fresh from DB
                        if (ownersInFirestore.length === 1 && ownersInFirestore[0] === uid && uid !== SUPER_ADMIN_UID) {
                           showMessage("Cannot demote the last owner. Assign 'owner' to another user first.", 'error');
                           // addLogEntry("Last Owner Demotion Blocked", { user: uid, newRole: newRole }); // Removed
                           roleChanged = false;
                        }
                    }

                    // Proceed with updates if changes are valid and permissible
                    if (roleChanged) {
                        const roleDocRef = doc(userRolesCollectionRef, uid);
                        await setDoc(roleDocRef, { role: newRole }, { merge: true });
                        // addLogEntry("User Role Changed", { targetUser: uid, oldRole, newRole, by: auth.currentUser.email }); // Removed
                    }

                    if (chipCountChanged && typeof newChipCount === 'number') { // Double check it's a number
                        const profileDocRef = doc(userProfilesCollectionRef, uid);
                        await setDoc(profileDocRef, { chip_count: newChipCount }, { merge: true });
                        // addLogEntry("User Chip Count Changed", { targetUser: uid, oldChipCount: oldChipCount === undefined ? "N/A" : oldChipCount, newChipCount, by: auth.currentUser.email }); // Removed
                    }
                }
                showMessage("User changes processed and saved to Firestore.", 'success');
            } catch (e) {
                console.error("Error saving user changes to Firestore:", e);
                showMessage("Failed to save user changes.", 'error');
            }
        }

        async function adminPlaceBetForPlayer(roomId, targetPlayerId, targetPlayerName, currentChips) {
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to place bets for players.", "error");
                return;
            }

            const targetPlayerCurrentStatus = firestoreGameRooms.find(r => r.id === roomId)?.playerStatuses?.[targetPlayerId];
            if (targetPlayerCurrentStatus === 'folded' || targetPlayerCurrentStatus === 'all-in') {
                showMessage(`Cannot place bet for ${targetPlayerName}; player is ${targetPlayerCurrentStatus}.`, "info");
                return;
            }
            
            const betAmountString = prompt(`Enter bet amount for ${targetPlayerName} (current chips: ${currentChips}):`);
            if (betAmountString === null) { // User cancelled prompt
                return;
            }

            const betAmount = parseInt(betAmountString, 10);

            if (isNaN(betAmount) || betAmount <= 0) {
                showMessage("Invalid bet amount. Please enter a positive number.", "error");
                return;
            }

            // Validate against player's actual chip count from their profile
            const targetUserProfile = allFirebaseUsersData.find(p => p.uid === targetPlayerId);
            const targetPlayerTotalChips = targetUserProfile ? (targetUserProfile.chip_count ?? 0) : 0;

            if (betAmount > targetPlayerTotalChips) {
                showMessage(`${targetPlayerName} does not have enough chips (has ${targetPlayerTotalChips}). Bet cannot exceed this amount.`, "error");
                return;
            }

            showMessage(`Placing bet of ${betAmount} for ${targetPlayerName}...`, "info");
            const roomDocRef = doc(gameRoomsCollectionRef, roomId);

            try {
                const roomSnap = await getDoc(roomDocRef);
                if (!roomSnap.exists()) {
                    showMessage("Error: Room data not found.", "error");
                    return;
                }
                const roomData = roomSnap.data();
                const currentHighestBetInRoom = Object.values(roomData.currentBets || {}).reduce((max, bet) => Math.max(max, bet), 0);

                let action = 'admin_bet'; // Default action
                if (betAmount > currentHighestBetInRoom && currentHighestBetInRoom > 0) {
                    action = 'admin_raise';
                } else if (betAmount === currentHighestBetInRoom && currentHighestBetInRoom > 0) {
                    action = 'admin_call';
                }

                let newStatus = 'ready';
                if (betAmount < currentHighestBetInRoom && currentHighestBetInRoom > 0) {
                    // This case should ideally be handled by admin consciously or UI should guide better.
                    // For now, if admin sets a bet lower than current highest, it's like an incomplete call.
                    // The player would still be 'pending' based on player card rendering logic.
                    // So, we can set 'pending' here, or let the rendering logic derive it.
                    // Let's assume admin action makes them 'ready' up to their bet, rendering logic will show 'pending' if needed.
                }
                 if (betAmount === targetPlayerTotalChips) { // If admin bets all player's chips
                    newStatus = 'all-in';
                    action = 'admin_all_in';
                }


                const updates = {
                    [`currentBets.${targetPlayerId}`]: betAmount,
                    [`playerStatuses.${targetPlayerId}`]: newStatus,
                    [`playerLastActions.${targetPlayerId}`]: action
                };
                await updateDoc(roomDocRef, updates);
                showMessage(`Bet of ${betAmount} placed for ${targetPlayerName}.`, "success");
                // UI will update via Firestore listener.
            } catch (error) {
                console.error(`Error placing bet for player ${targetPlayerId}:`, error);
                showMessage(`Failed to place bet for player: ${error.message}`, "error");
            }
        }

        async function adminForceFoldPlayer(roomId, targetPlayerId, targetPlayerName) {
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to force fold players.", "error");
                return;
            }
            if (targetPlayerId === auth.currentUser.uid) {
                showMessage("You cannot force fold yourself.", "info");
                return;
            }

            if (!confirm(`Are you sure you want to force fold ${targetPlayerName || 'this player'}?`)) {
                return;
            }

            showMessage(`Forcing ${targetPlayerName || 'player'} to fold...`, "info");
            const roomDocRef = doc(gameRoomsCollectionRef, roomId);
            try {
                const updates = {
                    [`playerStatuses.${targetPlayerId}`]: 'folded',
                    [`playerLastActions.${targetPlayerId}`]: 'admin_folded'
                    // Player's currentBet remains as it was, as is typical for a fold.
                };
                await updateDoc(roomDocRef, updates);
                showMessage(`${targetPlayerName || 'Player'} has been folded.`, "success");
                // UI will update via Firestore listener.
            } catch (error) {
                console.error(`Error force folding player ${targetPlayerId}:`, error);
                showMessage(`Failed to force fold player: ${error.message}`, "error");
            }
        }

        async function adminRemovePlayer(roomId, targetPlayerId, targetPlayerName) {
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to remove players.", "error");
                return;
            }

            if (targetPlayerId === auth.currentUser.uid) {
                showMessage("You cannot remove yourself using this admin action. Please use the 'Leave Room' button.", "info");
                return;
            }

            if (!confirm(`Are you sure you want to remove ${targetPlayerName || 'this player'} from the room?`)) {
                return;
            }

            showMessage(`Removing ${targetPlayerName || 'player'}...`, "info");
            const roomDocRef = doc(gameRoomsCollectionRef, roomId);
            try {
                // To remove fields from maps, we need FieldValue.delete()
                // It's imported with: import { ..., FieldValue } from "firebase/firestore";
                // However, FieldValue is not directly available in the global firebase object when using compat version.
                // For modular SDK, it needs to be imported. Since we are using modular SDK,
                // we need to ensure `deleteField` (the v9 equivalent) is available.
                // It's `import { ..., deleteField } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";`
                // Let's assume `deleteField` is available globally or correctly imported.
                // If not, this will cause an error and we'll need to add `deleteField` to the import list.

                // For now, let's try with direct update and arrayRemove.
                // Removing map entries is trickier without FieldValue.delete() or equivalent.
                // A common workaround if FieldValue.delete() isn't readily usable is to set the field to null or a special marker,
                // or fetch the document, modify the map in JS, and overwrite the map.
                // Given our current structure, arrayRemove is for arrays. For maps, we update the specific keys.

                const updates = {
                    players: arrayRemove(targetPlayerId), // Remove from players array
                    [`currentBets.${targetPlayerId}`]: deleteField(),
                    [`playerStatuses.${targetPlayerId}`]: deleteField(),
                    [`playerLastActions.${targetPlayerId}`]: deleteField()
                };

                await updateDoc(roomDocRef, updates);

                // Also delete their active session to force a UI update/kick for them
                try {
                    const activeSessionRef = doc(activeSessionsCollectionRef, targetPlayerId);
                    await deleteDoc(activeSessionRef);
                    console.log(`Active session for player ${targetPlayerId} deleted by admin removal.`);
                } catch (sessionError) {
                    console.error(`Error deleting active session for removed player ${targetPlayerId}:`, sessionError);
                    // Non-critical for the removal itself, but log it.
                    // The player might not get immediately kicked from UI if this fails, but they are out of the room data-wise.
                }

                showMessage(`${targetPlayerName || 'Player'} has been removed from the room and their session ended.`, "success");
                // The room view will update via Firestore listener.
            } catch (error) {
                console.error(`Error removing player ${targetPlayerId}:`, error);
                showMessage(`Failed to remove player: ${error.message}`, "error");
            }
        }

        async function handlePlaceBet(roomId) {
            if (!auth.currentUser) {
                showMessage("You must be logged in to place a bet.", "error");
                return;
            }
            const userId = auth.currentUser.uid;
            const betAmountString = playerBetInput.value.trim();
            const betAmount = parseInt(betAmountString, 10);

            const currentUserProfile = allFirebaseUsersData.find(p => p.uid === userId);
            const currentPlayerChips = currentUserProfile ? (currentUserProfile.chip_count ?? 0) : 0;

            // Validation
            if (isNaN(betAmount) || betAmount <= 0) {
                showMessage("Please enter a valid positive bet amount.", "error");
                return;
            }
            if (betAmount > currentPlayerChips) {
                showMessage("You cannot bet more chips than you have.", "error");
                return;
            }

            const roomDocRef = doc(gameRoomsCollectionRef, roomId);
            showMessage("Placing your bet...", "info");

            try {
                // Determine current highest bet in the room to decide if it's a bet, call, or raise.
                // This requires fetching the room data first, or having it available.
                // For simplicity in this step, we'll assume any bet sets status to 'ready' and action to 'bet'.
                // More complex logic (call/raise determination) will be handled in later UI steps or refined here.
                const roomSnap = await getDoc(roomDocRef);
                if (!roomSnap.exists()) {
                    showMessage("Error: Room data not found for placing bet.", "error");
                    return;
                }
                const roomData = roomSnap.data();
                const currentHighestBet = Object.values(roomData.currentBets || {}).reduce((max, bet) => Math.max(max, bet), 0);
                
                let action = 'bet'; // Default action
                if (betAmount > currentHighestBet && currentHighestBet > 0) {
                    action = 'raise';
                } else if (betAmount === currentHighestBet && currentHighestBet > 0) {
                    action = 'call';
                } else if (betAmount > 0 && currentHighestBet === 0) {
                    action = 'bet'; // Opening bet
                }


                // Update Firestore document
                const updates = {
                    [`currentBets.${userId}`]: betAmount,
                    [`playerStatuses.${userId}`]: 'ready', // Assuming betting makes you 'ready' for now
                    [`playerLastActions.${userId}`]: action 
                };
                await updateDoc(roomDocRef, updates);
                
                showMessage(`Bet of ${betAmount} (${action}) placed successfully!`, "success");
                playerBetInput.value = ''; // Clear input

                // Note: Actual chip deduction from player's profile is NOT handled here yet.
                // That will be part of the "All-In" implementation or a more general chip management logic.
            } catch (error) {
                console.error("Error placing bet:", error);
                showMessage(`Failed to place bet: ${error.message}`, "error");
            }
        }

        async function handleLeaveRoom(roomId) {
            if (!auth.currentUser) {
                showMessage("You must be logged in to leave a room.", "error");
                return;
            }
            const userId = auth.currentUser.uid;

            if (roomId === currentJoinedRoomId) {
                currentJoinedRoomId = null; // Clear the joined room state
            }

            const roomDocRef = doc(gameRoomsCollectionRef, roomId);
            showMessage("Leaving room...", "info");
            try {
                await updateDoc(roomDocRef, {
                    players: arrayRemove(userId)
                });
                showMessage("You have left the room.", "success");
                showPanel(playerJoinRoomPanel); // Navigate back to the lobby/room list
                // Other UI (like User Directory status) will update via Firestore listeners.
            } catch (error) {
                console.error("Error leaving room:", error);
                showMessage(`Failed to leave room: ${error.message}`, "error");
                // If failed, re-render current view in case it was from gameRoomViewPanel
                if(gameRoomViewPanel && !gameRoomViewPanel.classList.contains('hidden') && currentJoinedRoomId === roomId) {
                    renderGameRoomView(roomId);
                } else {
                     renderAvailableRoomsList(); // Or refresh available rooms list if called from there
                }
            }
        }

        function renderUserRolesTable() {
            userRolesTableBody.innerHTML = '';
            
            if (allFirebaseUsersData.length === 0) {
                userRolesTableBody.innerHTML = '<tr><td colspan="4" class="text-center text-gray-500 py-4">No users found. Users will appear here after they log in.</td></tr>'; // Colspan updated
                return;
            }

            const currentUserId = auth.currentUser?.uid;
            const activeSessionUIDs = firestoreActiveSessions.map(session => session.id); // Get active UIDs
            const currentUserIsAdminOrOwner = hasAdminAccess(currentUserId);
            const currentUserIsOwner = isOwner(currentUserId);


            allFirebaseUsersData.sort((a, b) => (a.displayName || '').localeCompare(b.displayName || '')); // Sort by display name

            allFirebaseUsersData.forEach(user => {
                const row = userRolesTableBody.insertRow();
                const displayNameCell = row.insertCell();
                const chipCountCell = row.insertCell(); // New cell for chip count
                const userRoleCell = row.insertCell();

                displayNameCell.textContent = formatDisplayName(user); // Use helper to format display name

                // Chip count input
                const chipInput = document.createElement('input');
                chipInput.type = 'number';
                chipInput.className = 'border rounded-lg p-1 w-20 text-sm'; // Added w-20 for width
                chipInput.setAttribute('data-uid', user.uid);
                chipInput.setAttribute('name', `chip_count_${user.uid}`);
                chipInput.value = (typeof user.chip_count === 'number') ? user.chip_count : 0;
                chipCountCell.appendChild(chipInput);

                // Role select dropdown
                const select = document.createElement('select');
                select.className = 'border rounded-lg p-1 text-sm';
                select.setAttribute('data-uid', user.uid);
                select.setAttribute('name', `role_${user.uid}`);


                const userCurrentRole = getCurrentUserRole(user.uid);

                ROLES.forEach(role => {
                    const option = document.createElement('option');
                    option.value = role;
                    option.textContent = role;
                    select.appendChild(option);
                });

                select.value = userCurrentRole;

                // **Disable select element and chip input based on permissions**
                let disableRoleSelect = false;
                let disableChipInput = false;

                // 1. If current user doesn't have admin access at all, all fields are disabled.
                if (!currentUserIsAdminOrOwner) {
                    disableRoleSelect = true;
                    disableChipInput = true;
                } else {
                    // 2. SUPER_ADMIN_UID's role dropdown should always be disabled.
                    //    Chip input for SUPER_ADMIN_UID can be edited by an owner.
                    if (user.uid === SUPER_ADMIN_UID) {
                        disableRoleSelect = true;
                        select.value = 'owner'; // Visually reflect owner status
                        if (!currentUserIsOwner) { // Non-owners cannot edit SUPER_ADMIN's chips
                            disableChipInput = true;
                        }
                    }
                    // 3. If the target user is an 'owner' and the current user is not an 'owner' (and target is not SUPER_ADMIN, handled above)
                    //    (Admins cannot change other Owners' roles or chip counts).
                    else if (userCurrentRole === 'owner' && !currentUserIsOwner) {
                        disableRoleSelect = true;
                        disableChipInput = true;
                    }
                }
                select.disabled = disableRoleSelect;
                chipInput.disabled = disableChipInput;

                // Specific option disabling for roles (doesn't apply to chip_count input directly)
                // Disable the 'owner' role option if the current user is not an owner.
                if (!currentUserIsOwner) {
                    const ownerOption = select.querySelector('option[value="owner"]');
                    if (ownerOption) {
                        ownerOption.disabled = true;
                    }
                }

                // Prevent last owner from disabling/demoting self via dropdown directly (UI hint)
                // This is a UI hint; server-side/save function has the definitive check.
                if (user.uid === currentUserId && currentUserIsOwner) {
                    const ownersInFirestore = Object.keys(firestoreUserRoles).filter(id => firestoreUserRoles[id]?.role === 'owner');
                    if (ownersInFirestore.length === 1 && ownersInFirestore[0] === user.uid && user.uid !== SUPER_ADMIN_UID) {
                        ['disabled', 'player', 'admin'].forEach(roleToDisable => {
                            const option = select.querySelector(`option[value="${roleToDisable}"]`);
                            if (option) option.disabled = true;
                        });
                    }
                }


                userRoleCell.appendChild(select);

                // Actions cell
                const actionsCell = row.insertCell();
                const forceLogoutButton = document.createElement('button');
                forceLogoutButton.textContent = 'Force Logout';
                forceLogoutButton.className = 'bg-red-500 hover:bg-red-700 text-white text-xs py-1 px-2 rounded disabled:opacity-50 disabled:cursor-not-allowed';
                
                const targetUserRole = userCurrentRole; // Role of the user in the row
                const targetUserIsOnline = activeSessionUIDs.includes(user.uid);

                let disableLogoutButton = false;

                if (user.uid === currentUserId) { // Cannot logout self
                    disableLogoutButton = true;
                } else if (!targetUserIsOnline) { // Cannot logout an offline user
                    disableLogoutButton = true;
                } else {
                    if (currentUserIsOwner) {
                        // Owners can log out anyone (except self, handled above)
                        disableLogoutButton = false;
                    } else if (currentUserIsAdminOrOwner) { // Current user is Admin (but not Owner)
                        if (targetUserRole === 'owner' || targetUserRole === 'admin') {
                            disableLogoutButton = true; // Admins cannot log out other Admins or Owners
                        }
                    } else { // Current user has no admin/owner access (should not happen if they see the panel, but defensive)
                        disableLogoutButton = true;
                    }
                }

                forceLogoutButton.disabled = disableLogoutButton;
                if (!disableLogoutButton) {
                    forceLogoutButton.onclick = () => forceLogoutUser(user.uid, formatDisplayName(user));
                }
                actionsCell.appendChild(forceLogoutButton);
            });
        }

        function collectAndSaveChanges() { // Function definition renamed
            const newRolesMap = {};
            const changesMap = {}; // Will store { uid: { newRole: 'role', newChipCount: 123 } }
            const rows = userRolesTableBody.querySelectorAll('tr');

            rows.forEach(row => {
                const roleSelect = row.querySelector('select[data-uid]');
                const chipInput = row.querySelector('input[type="number"][data-uid]');

                if (roleSelect && chipInput) {
                    const uid = roleSelect.getAttribute('data-uid');
                    const newRole = roleSelect.value;
                    const newChipCount = parseInt(chipInput.value, 10);

                    if (isNaN(newChipCount)) {
                        showMessage(`Invalid chip count for user with UID ${uid}. Please enter a valid number.`, 'error');
                        // Potentially skip this user or handle error more gracefully
                        return; // Skip this row if chip count is not a number
                    }
                    changesMap[uid] = { newRole, newChipCount };
                }
            });

            if (Object.keys(changesMap).length > 0) {
                saveUserChangesToFirestore(changesMap); // Call the renamed function
            } else {
                showMessage("No user data found to save.", "info");
            }
        }
        // --- End User Management Functions ---

        // --- Admin: Force Logout User ---
        async function forceLogoutUser(targetUid, targetUserDisplayName) {
            console.log(`Attempting to force logout for UID: ${targetUid}, Name: ${targetUserDisplayName}`); // Debug log

            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to force logout users.", 'error');
                // addLogEntry("Force Logout Attempt Failed", { reason: "Permission denied", targetUser: targetUid, by: auth.currentUser?.uid }); // Removed
                console.error("Force logout permission denied for current user:", auth.currentUser?.uid); // Debug log
                return;
            }

            // Additional permission checks (partially redundant with button disabling logic, but good for direct calls)
            const currentUserId = auth.currentUser.uid;
            console.log(`Current admin UID: ${currentUserId}`); // Debug log
            const currentUserIsOwner = isOwner(currentUserId);
            const targetUserRole = getCurrentUserRole(targetUid); 

            if (targetUid === currentUserId) {
                showMessage("You cannot force logout yourself.", 'error');
                return;
            }

            // This check is primarily for direct calls; button logic should prevent this UI-wise for admins.
            if (!currentUserIsOwner && (targetUserRole === 'owner' || targetUserRole === 'admin')) {
                showMessage("Admins cannot force logout other Admins or Owners.", 'error');
                // addLogEntry("Force Logout Attempt Denied", { reason: "Admin tried to log out admin/owner", targetUser: targetUid, by: currentUserId }); // Removed
                return;
            }

            if (!confirm(`Are you sure you want to force logout ${targetUserDisplayName || targetUid}? This will remove their active session marker.`)) {
                return;
            }
            console.log("Proceeding with force logout confirmation."); // Debug log

            if (!confirm(`Are you sure you want to force logout ${targetUserDisplayName || targetUid}? This will remove their active session marker.`)) {
                console.log("Force logout cancelled by admin."); // Debug log
                return;
            }

            showMessage(`Forcing logout for ${targetUserDisplayName || targetUid}...`, 'info');
            try {
                const activeSessionRef = doc(activeSessionsCollectionRef, targetUid);
                console.log(`Attempting to delete active session doc: active_sessions/${targetUid}`); // Debug log
                await deleteDoc(activeSessionRef);
                console.log(`Successfully deleted active session doc for UID: ${targetUid}`); // Debug log
                
                // addLogEntry("User Forced Logout", { 
                //     targetUser: targetUid, 
                //     targetUserName: targetUserDisplayName || 'N/A',
                //     byUser: auth.currentUser.email || currentUserId 
                // }); // Removed
                showMessage(`${targetUserDisplayName || targetUid} has been marked as logged out. Their status will update shortly.`, 'success');
                
                // Re-render the user management table to update button states (e.g., logout button for the user just logged out should become disabled)
                console.log("Force logout successful, re-rendering user roles table if visible."); // Debug log
                if (!userManagementPanel.classList.contains('hidden')) {
                    renderUserRolesTable();
                }
                // The User Directory table will auto-update if visible due to its own listener on activeSessionsCollectionRef.

            } catch (error) {
                console.error("Error during force logout Firestore operation:", error); // Debug log
                showMessage(`Failed to force logout for ${targetUserDisplayName || targetUid}. Error: ${error.message}`, 'error');
                // addLogEntry("Force Logout Failed", { targetUser: targetUid, error: error.message, by: currentUserId }); // Removed
            }
        }


        // --- "User Directory" Panel Functions (formerly Logged-in Users Panel) ---
        async function showUserDirectoryPanel() { 
            showPanel(userDirectoryPanel); // Corrected variable name
            await renderUserDirectoryTable(); 
            // addLogEntry("User Directory Panel Opened", { user: auth.currentUser?.email || auth.currentUser?.uid }); // Removed for log simplification
        }

        function hideUserDirectoryPanel() { 
            userDirectoryPanel.classList.add('hidden'); // Corrected variable name
            const loggedInUser = JSON.parse(localStorage.getItem('loggedInUser'));
            if (loggedInUser && loggedInUser.hasAdminAccess) {
                showPanel(adminPanel);
            } else if (loggedInUser) {
                // For regular users, perhaps show account management or simply hide, returning to default view.
                // Default view logic after login is handled by onAuthStateChanged or handleLoginSuccess.
                // If they were viewing their account, maybe go back there. For now, just hide.
            }
        }

        async function renderUserDirectoryTable() { 
            userDirectoryTableBody.innerHTML = '<tr><td colspan="3" class="text-center text-gray-500 py-4">Loading users...</td></tr>'; // Updated colspan for 3 columns

            try {
                // Ensure firestoreActiveSessions is available for status check
                const activeSessionUIDs = firestoreActiveSessions.map(session => session.id);

                const querySnapshot = await getDocs(userProfilesCollectionRef);
                const users = [];
                querySnapshot.forEach(doc => {
                    users.push(doc.data());
                });

                userDirectoryTableBody.innerHTML = ''; // Corrected variable name

                if (users.length === 0) {
                    userDirectoryTableBody.innerHTML = '<tr><td colspan="3" class="text-center text-gray-500 py-4">No users found in the directory.</td></tr>'; // Updated colspan
                    return;
                }

                // Sort users by displayName, case-insensitive
                users.sort((a, b) => {
                    const nameA = (formatDisplayName(a) || '').toLowerCase();
                    const nameB = (formatDisplayName(b) || '').toLowerCase();
                    if (nameA < nameB) return -1;
                    if (nameA > nameB) return 1;
                    return 0;
                });

                users.forEach(user => {
                    const row = userDirectoryTableBody.insertRow(); // Corrected variable name
                    const displayNameCell = row.insertCell();
                    const chipCountCell = row.insertCell();
                    const statusCell = row.insertCell();

                    displayNameCell.textContent = formatDisplayName(user);
                    chipCountCell.textContent = (typeof user.chip_count === 'number') ? user.chip_count : '0';

                    // Determine status: In-Game > Online > Offline
                    let userStatus = "Offline";
                    let statusClass = "text-gray-500";

                    // Check if user is in any game room's players list
                    let isInGame = false;
                    for (const room of firestoreGameRooms) {
                        if (room.players && room.players.includes(user.uid)) {
                            isInGame = true;
                            break;
                        }
                    }

                    if (isInGame) {
                        userStatus = "In-Game";
                        statusClass = "text-blue-600 font-semibold"; // Blue for In-Game
                    } else if (activeSessionUIDs.includes(user.uid)) {
                        userStatus = 'Online';
                        statusClass = 'text-green-600 font-semibold'; // Green for Online
                    }
                    // Default is Offline (grey), already set

                    statusCell.textContent = userStatus;
                    statusCell.className = statusClass;
                });

            } catch (error) {
                console.error("Error fetching user profiles for directory:", error);
                userDirectoryTableBody.innerHTML = '<tr><td colspan="3" class="text-center text-red-500 py-4">Error loading users.</td></tr>'; // Updated colspan
                showMessage("Could not load user directory.", "error");
            }
        }
        // --- End "User Directory" Panel Functions ---


        // --- Account Management Functions ---
        function renderAccountManagementPanel(displayUser) {
            const firebaseUser = auth.currentUser;

            userProfilePic.src = displayUser.profilePic || firebaseUser?.photoURL || 'https://placehold.co/100x100/cccccc/ffffff?text=U';
            userProfilePic.alt = `${displayUser.name || displayUser.username}'s profile picture`;
            currentUserName.textContent = displayUser.name || firebaseUser?.displayName || 'N/A';
            currentUserUsername.textContent = `Email: ${displayUser.username || firebaseUser?.email || 'N/A'}`;

            let providerId = 'Unknown';
            if (firebaseUser) {
                const providers = firebaseUser.providerData.map(p => p.providerId);
                if (providers.includes('google.com')) {
                    providerId = 'Google';
                    linkGoogleAccountButton.classList.add('hidden'); // Already linked with Google
                } else if (providers.includes('password')) {
                    providerId = 'Email/Password';
                    linkGoogleAccountButton.classList.remove('hidden'); // Can link to Google
                } else if (providers.includes('anonymous')) {
                    providerId = 'Anonymous';
                    linkGoogleAccountButton.classList.remove('hidden'); // Can link to Google
                }
            } else {
                providerId = 'No Firebase Session'; // Should not happen if this panel is shown
                linkGoogleAccountButton.classList.remove('hidden');
            }
            currentUserProvider.textContent = `Provider: ${providerId}`;
        }

        async function handleGoogleLink() {
            if (!auth.currentUser) {
                showMessage("No active Firebase user session to link accounts. Please sign in first.", 'error');
                return;
            }

            showMessage("Attempting to link with Google...", 'info');
            try {
                const result = await linkWithPopup(auth.currentUser, googleProvider);
                const linkedUser = result.user;
                console.log("Account linked successfully with Google:", linkedUser);

                const updatedLoggedInUser = {
                    username: linkedUser.email || linkedUser.uid,
                    name: linkedUser.displayName || linkedUser.email,
                    profilePic: linkedUser.photoURL,
                    isAdmin: (linkedUser.uid === SUPER_ADMIN_UID || firestoreUserRoles[linkedUser.uid]?.role === 'admin'),
                    firebaseUid: linkedUser.uid
                };
                localStorage.setItem('loggedInUser', JSON.stringify(updatedLoggedInUser));
                
                showMessage("Account successfully linked with Google!", 'success');
                // addLogEntry("Account Linked", { user: linkedUser.email || linkedUser.uid, provider: "Google" }); // Removed for log simplification
                renderAccountManagementPanel(updatedLoggedInUser);
            } catch (error) {
                console.error("Error linking Google account:", error);
                let errorMessage = "Failed to link Google account.";
                if (error.code === 'auth/credential-already-in-use') {
                    errorMessage = "This Google account is already linked to another user.";
                } else if (error.code === 'auth/popup-closed-by-user') {
                    errorMessage = "Google login window was closed.";
                } else if (error.code === 'auth/invalid-credential') {
                    errorMessage = "Invalid Google credential or already linked to a different account.";
                } else if (error.code === 'auth/email-already-in-use') {
                    errorMessage = "The email associated with this Google account is already in use by another login method. Please sign in with that method and then link.";
                }
                showMessage(errorMessage, 'error');
                // addLogEntry("Account Link Failed", { user: auth.currentUser?.uid || 'Unknown', provider: "Google", error: error.message }); // Removed for log simplification
            }
        }

        // Function to handle successful login and subsequent data loading
        async function handleLoginSuccess(user) {
            console.log("handleLoginSuccess: User authenticated, UID:", user.uid);
            
            // Ensure data loading and listeners setup only once per successful login
            if (!dataLoadedAndListenersSetup) {
                showPanel(loadingIndicator); // Show loading indicator while data is fetched
                loadingIndicator.querySelector('span').textContent = 'Loading user data...';
                await loadInitialData(); // Load user profiles first, if needed separately
                console.log("handleLoginSuccess: Setting up Firestore listeners and awaiting initial data...");
                await setupFirestoreListeners(); // Wait for listeners to load initial data
                console.log("handleLoginSuccess: Firestore listeners initial data loaded.");
                dataLoadedAndListenersSetup = true;
            }

            let userRole = getCurrentUserRole(user.uid); // Use helper, defaults to 'player'

            // Ensure SUPER_ADMIN_UID has 'owner' role in Firestore for consistency and explicitness.
            // The helper functions (isOwner, hasAdminAccess) will grant privileges regardless,
            // but this makes the database state match the effective permissions.
            if (user.uid === SUPER_ADMIN_UID && userRole !== 'owner') {
                // Check against the raw firestoreUserRoles as getCurrentUserRole would default to 'player' if not set
                if (firestoreUserRoles[user.uid]?.role !== 'owner') {
                    console.log(`SUPER_ADMIN_UID (${user.uid}) logged in. Ensuring 'owner' role is set in Firestore.`);
                    const superAdminRoleRef = doc(userRolesCollectionRef, user.uid);
                    try {
                        await setDoc(superAdminRoleRef, { role: 'owner' }, { merge: true });
                        firestoreUserRoles[user.uid] = { role: 'owner' }; // Update local cache
                        userRole = 'owner'; // Update userRole for the current execution context
                        // addLogEntry("SUPER_ADMIN Role Initialized/Verified", { uid: user.uid }); // Removed for log simplification (too internal)
                        console.log(`SUPER_ADMIN_UID (${user.uid}) role set to 'owner' in Firestore.`);
                    } catch (e) {
                        console.error("CRITICAL: Failed to set SUPER_ADMIN_UID role to 'owner' in Firestore:", e);
                        showMessage("Critical: Failed to initialize SUPER_ADMIN role. Contact support.", "error");
                        // Depending on policy, might want to halt login or restrict SUPER_ADMIN if this fails.
                        // For now, proceed as helper functions provide override.
                    }
                } else {
                     // If firestoreUserRoles already shows 'owner' (e.g. from listener update after another owner set it)
                    userRole = 'owner';
                }
            }


            // Ensure a user profile exists in Firestore for the logged-in Firebase user
            if (user) {
                const userProfileRef = doc(userProfilesCollectionRef, user.uid);
                // Prepare base user data
                const userData = {
                    uid: user.uid,
                    email: user.email || null,
                    displayName: user.displayName || user.email || 'Anonymous', // Ensure displayName has a fallback
                    photoURL: user.photoURL || null,
                    lastLogin: new Date().toISOString(),
                    role: userRole // Ensure profile reflects the determined role
                };

                // Check if the user profile document already exists to set chip_count only for new users
                const userProfileSnap = await getDoc(userProfileRef);
                if (!userProfileSnap.exists()) {
                    userData.chip_count = 0; // Initialize chip_count for new users
                    console.log("New user profile created with initial chip_count: 0 for user:", user.uid);
                } else {
                    const existingData = userProfileSnap.data();
                    // Ensure chip_count is a number, defaulting to 0 if it's missing or not a number.
                    if (typeof existingData.chip_count === 'number') {
                        userData.chip_count = existingData.chip_count;
                    } else {
                        userData.chip_count = 0; // Default to 0 if not a number or undefined
                        if (typeof existingData.chip_count !== 'undefined') {
                            console.log(`Existing user profile had a non-numeric chip_count ('${existingData.chip_count}'). Corrected to 0 for user:`, user.uid);
                        } else {
                            console.log("Existing user profile was missing chip_count. Initialized to 0 for user:", user.uid);
                        }
                    }
                }

                await setDoc(userProfileRef, userData, { merge: true });
                console.log("User profile updated/created in Firestore:", user.uid, "with role:", userRole, "and chip_count handling.");

                // Add to active_sessions collection
                const activeSessionRef = doc(activeSessionsCollectionRef, user.uid);
                try {
                    await setDoc(activeSessionRef, {
                        email: user.email || 'N/A',
                        role: userRole,
                        loginTime: new Date().toISOString()
                    }, { merge: true }); // merge:true to update if session doc already exists
                    console.log("User session added/updated in active_sessions:", user.uid);
                    setupOwnActiveSessionListener(user.uid); // Setup listener for self-logout
                } catch (e) {
                    console.error("Error adding/updating user session to active_sessions:", e);
                    // Non-critical, so don't block login, but log it.
                }
            }

            // ** 'Disabled' role check - This is handled in Step 3 of the plan, will be added here later **

            // Determine admin access and prepare user data for local storage
            const userHasAdminAccess = hasAdminAccess(user.uid);

            const finalUserForLocalStorage = {
                username: user.email || user.uid,
                name: formatDisplayName(user), // Format display name here
                profilePic: user.photoURL || 'https://placehold.co/50x50/cccccc/ffffff?text=U',
                hasAdminAccess: userHasAdminAccess, // Updated field name
                firebaseUid: user.uid,
                role: userRole
            };
            localStorage.setItem('loggedInUser', JSON.stringify(finalUserForLocalStorage));

            // ** 'Disabled' role check **
            if (userRole === 'disabled') {
                showMessage("Your account has been disabled. Please contact an administrator.", 'error');
                // addLogEntry("Disabled Account Login Attempt", { user: finalUserForLocalStorage.username, firebaseUid: user.uid }); // Removed
                // Ensure logout happens and no further UI is shown for a disabled user
                // We need to make sure handleLogout doesn't try to re-trigger onAuthStateChanged logic that might re-run this.
                // The isLoggingOut flag in handleLogout should prevent immediate re-login attempts.
                // No need to show other panels or buttons.
                isLoggingOut = true; // Set flag to prevent onAuthStateChanged from re-processing login
                handleLogout(); // This will clear local storage and sign out from Firebase
                showPanel(loginButtonsContainer); // Explicitly show login buttons after logout
                messageBox.classList.remove('hidden'); // Ensure the disabled message stays visible
                loadingIndicator.classList.add('hidden'); // Hide loading indicator
                return; // Stop further execution for disabled users
            }

            // Show welcome message
            showMessage(`Welcome, ${finalUserForLocalStorage.name}! Role: ${userRole}`, 'success');
            // addLogEntry("User Login", { user: finalUserForLocalStorage.username, firebaseUid: user.uid, role: userRole }); // Removed general login, covered by specific Google success/fail
            
            // Show neutral view with main action buttons, hide all content panels initially
            showPanel(null); // This will hide adminPanel, accountManagementPanel, userDirectoryPanel etc.
            loginButtonsContainer.classList.add('hidden'); // Ensure login buttons are hidden

            logoutButton.classList.remove('hidden');
            openAccountManagementButton.classList.remove('hidden');
            joinGameButton.classList.remove('hidden'); // Show for all logged-in users

            if (userHasAdminAccess) {
                openAdminPanelButton.classList.remove('hidden');
                // addLogEntry("Admin Panel Access", { user: finalUserForLocalStorage.username, firebaseUid: user.uid, role: userRole }); // Removed: Redundant with "User Login" and panel is no longer auto-opened
            } else {
                openAdminPanelButton.classList.add('hidden');
            }
            
            const userRoleForButton = finalUserForLocalStorage.role; // Re-check or use userRole directly
            if (userRoleForButton === 'player' || userRoleForButton === 'admin' || userRoleForButton === 'owner') {
                viewUserDirectoryButton.classList.remove('hidden');
            } else {
                viewUserDirectoryButton.classList.add('hidden');
            }
            // Note: renderAccountManagementPanel() will be called when its button is clicked.
            // Admin panel content is static for now, no specific render function on open needed beyond showPanel.
        }

        // Function to handle logout
        async function handleLogout() {
            if (unsubscribeOwnActiveSessionListener) {
                console.log("Unsubscribing from own active session listener during logout.");
                unsubscribeOwnActiveSessionListener();
                unsubscribeOwnActiveSessionListener = null;
            }

            const loggedInUserString = localStorage.getItem('loggedInUser');
            let firebaseUidToClear = null;

            if (loggedInUserString) {
                const user = JSON.parse(loggedInUserString);
                firebaseUidToClear = user.firebaseUid; // Get UID before clearing localStorage
                // addLogEntry("Logout", { user: user.username, isAdmin: user.hasAdminAccess, firebaseUid: user.firebaseUid }); // Removed
            } else if (auth.currentUser) {
                // Fallback if localStorage was cleared but auth session still exists
                firebaseUidToClear = auth.currentUser.uid;
                // addLogEntry("Logout", { user: auth.currentUser.email || "Unknown (from auth)", firebaseUid: auth.currentUser.uid }); // Removed
            } else {
                 // addLogEntry("Logout", { user: "Unknown" }); // Removed
            }

            isLoggingOut = true;

            if (firebaseUidToClear) {
                // Attempt to remove user from any game room they are in
                for (const room of firestoreGameRooms) {
                    if (room.players && room.players.includes(firebaseUidToClear)) {
                        console.log(`User ${firebaseUidToClear} is in room ${room.id}. Attempting to remove.`);
                        const roomDocRef = doc(gameRoomsCollectionRef, room.id);
                        try {
                            await updateDoc(roomDocRef, {
                                players: arrayRemove(firebaseUidToClear)
                            });
                            console.log(`User ${firebaseUidToClear} removed from room ${room.id} during logout.`);
                        } catch (e) {
                            console.error(`Error removing user ${firebaseUidToClear} from room ${room.id} during logout:`, e);
                            // Non-critical, continue logout process
                        }
                        // Assuming a user can only be in one room at a time
                        break; 
                    }
                }

                // Attempt to remove from active_sessions, regardless of signOut success
                try {
                    const activeSessionRef = doc(activeSessionsCollectionRef, firebaseUidToClear);
                    await deleteDoc(activeSessionRef);
                    console.log("User session removed from active_sessions:", firebaseUidToClear);
                } catch (e) {
                    console.error("Error removing user session from active_sessions:", e);
                    // Non-critical, log and continue logout
                }
            }

            try {
                if (auth.currentUser) { // Check again as state might have changed due to async operations above
                    await signOut(auth); // Use Firebase signOut function
                    console.log("Firebase: Signed out.");
                }
            } catch (error) {
                console.error("Firebase: Error signing out:", error);
            }

            localStorage.removeItem('loggedInUser');
            dataLoadedAndListenersSetup = false; // Reset for next login
            showMessage('You have been logged out.', 'info');
            showPanel(loginButtonsContainer);
            logoutButton.classList.add('hidden');
            viewUserDirectoryButton.classList.add('hidden');
            openAccountManagementButton.classList.add('hidden');
            openAdminPanelButton.classList.add('hidden');
            joinGameButton.classList.add('hidden'); // Hide on logout

            // Hide other content panels that might have been open
            adminPanel.classList.add('hidden');
            userManagementPanel.classList.add('hidden');
            // logViewer.classList.add('hidden'); // logViewer removed
            accountManagementPanel.classList.add('hidden');
            if (userDirectoryPanel) { 
                userDirectoryPanel.classList.add('hidden');
            }
            // viewUserDirectoryButton is already handled above
        }

        // Best-effort cleanup on tab close / navigation
        window.addEventListener('beforeunload', async (event) => {
            // Check if there's a logged-in user according to Firebase Auth directly
            if (auth.currentUser && !isLoggingOut) { 
                const userId = auth.currentUser.uid;
                console.log('beforeunload: Attempting cleanup for user:', userId);

                // Best-effort: Attempt to remove user from any game room
                for (const room of firestoreGameRooms) {
                    if (room.players && room.players.includes(userId)) {
                        console.log(`beforeunload: User ${userId} is in room ${room.id}. Attempting fire-and-forget removal.`);
                        const roomDocRef = doc(gameRoomsCollectionRef, room.id);
                        updateDoc(roomDocRef, { // Not awaiting, fire-and-forget
                            players: arrayRemove(userId)
                        }).catch(e => console.warn(`beforeunload: Error removing user from room ${room.id}:`, e));
                        break; // Assuming user can only be in one room
                    }
                }
                
                // Best-effort: Attempt to clear active session
                try {
                    const activeSessionRef = doc(activeSessionsCollectionRef, userId);
                    deleteDoc(activeSessionRef).then(() => {
                        console.log('beforeunload: Active session cleanup call for', userId, 'completed.');
                    }).catch(e => {
                        console.warn('beforeunload: Error in active session cleanup call for', userId, e);
                    });
                } catch (e) {
                    console.warn("Error during beforeunload active session cleanup setup for user:", userId, e);
                }
            }
        });

        // --- Initial Data Loading (fetches user profiles) ---
        async function loadInitialData() {
            console.log("loadInitialData: Attempting to load user profiles...");
            if (!auth.currentUser) {
                console.warn("loadInitialData: Skipping data load, no authenticated user.");
                return;
            }

            try {
                const querySnapshot = await getDocs(userProfilesCollectionRef);
                allFirebaseUsersData = [];
                querySnapshot.forEach(doc => {
                    allFirebaseUsersData.push(doc.data());
                });
                console.log("Loaded Firebase user profiles:", allFirebaseUsersData.length);
            } catch (error) {
                console.error("Failed to fetch user profiles:", error);
                showMessage(`Failed to load user data: ${error.message}.`, 'error');
                // addLogEntry("Initial data load failed", { error: error.message }); // Removed
            }
        }

        // --- Firestore Real-time Listeners (for user roles and activity logs) ---
        function setupFirestoreListeners() {
            console.log("setupFirestoreListeners: Attempting to set up listeners...");
            if (!auth.currentUser) {
                console.warn("setupFirestoreListeners: Skipping listener setup, no authenticated user.");
                return Promise.resolve(); // Resolve immediately if no user
            }

            // Promise for User Roles
            const rolesPromise = new Promise((resolve, reject) => {
                let initialRolesLoadDone = false;
                const unsubscribeRoles = onSnapshot(userRolesCollectionRef, (snapshot) => {
                    const newRoles = {};
                    snapshot.forEach(doc => {
                        newRoles[doc.id] = doc.data();
                    });
                    firestoreUserRoles = newRoles;
                    console.log("Firestore: User Roles snapshot processed. Roles count:", Object.keys(firestoreUserRoles).length);

                    if (!userManagementPanel.classList.contains('hidden')) {
                        renderUserRolesTable();
                    }

                    const currentUser = auth.currentUser;
                    if (currentUser) {
                        const storedUser = JSON.parse(localStorage.getItem('loggedInUser'));
                        if (storedUser && currentUser.uid === storedUser.firebaseUid) { // Ensure it's the currently logged-in user
                             const newRoleDeterminedByListener = getCurrentUserRole(currentUser.uid);
                             const newHasAdminAccess = hasAdminAccess(currentUser.uid);

                             // Check if either role or admin access status has changed
                             if (storedUser.role !== newRoleDeterminedByListener || storedUser.hasAdminAccess !== newHasAdminAccess) {
                                 console.log(`Real-time: Role/access changed by listener for ${currentUser.uid}. Old role: ${storedUser.role}, New: ${newRoleDeterminedByListener}. Old AdminAccess: ${storedUser.hasAdminAccess}, New: ${newHasAdminAccess}`);

                                 storedUser.role = newRoleDeterminedByListener;
                                 storedUser.hasAdminAccess = newHasAdminAccess;
                                localStorage.setItem('loggedInUser', JSON.stringify(storedUser));

                                 // Handle 'disabled' role immediately if applied mid-session
                                 if (newRoleDeterminedByListener === 'disabled') {
                                    showMessage("Your account has been disabled. Please contact an administrator.", 'error');
                                    // addLogEntry("Account Disabled Mid-Session", { user: currentUser.email || currentUser.uid }); // Removed
                                    handleLogout(); // Force logout
                                    // Resolve promise here as further UI updates for this user are irrelevant
                                    if (!initialRolesLoadDone) {
                                        initialRolesLoadDone = true;
                                        console.log("Firestore: Initial User Roles loaded (resolved after disabled check).");
                                        resolve();
                                    }
                                    return; // Stop further processing for this user in the listener
                                 }

                                 if (newHasAdminAccess) {
                                    showPanel(adminPanel);
                                } else {
                                    showPanel(accountManagementPanel);
                                    renderAccountManagementPanel(storedUser);
                                }
                            }
                        }
                    }

                    if (!initialRolesLoadDone) {
                        initialRolesLoadDone = true;
                        console.log("Firestore: Initial User Roles loaded.");
                        resolve();
                    }
                }, (error) => {
                    console.error("Firestore: Error listening to user roles:", error);
                    showMessage("Error: Could not sync user roles from cloud.", 'error');
                    reject(error);
                });
                // Consider storing unsubscribeRoles if you need to detach listeners later
            });

            // Promise for User Profiles
            const profilesPromise = new Promise((resolve, reject) => {
                let initialProfilesLoadDone = false;
                const unsubscribeProfiles = onSnapshot(userProfilesCollectionRef, (snapshot) => {
                    allFirebaseUsersData = [];
                    snapshot.forEach(doc => {
                        allFirebaseUsersData.push(doc.data());
                    });
                    console.log("Firestore: User Profiles snapshot processed. Profiles count:", allFirebaseUsersData.length);
                    if (!userManagementPanel.classList.contains('hidden')) {
                        renderUserRolesTable();
                    }
                    if (!initialProfilesLoadDone) {
                        initialProfilesLoadDone = true;
                        console.log("Firestore: Initial User Profiles loaded.");
                        resolve();
                    }
                }, (error) => {
                    console.error("Firestore: Error listening to user profiles:", error);
                    showMessage("Error: Could not sync user profiles from cloud.", 'error');
                    reject(error);
                });
            });

            // Promise for Activity Logs (REMOVED)

            // Promise for Active Sessions
            const activeSessionsPromise = new Promise((resolve, reject) => {
                let initialSessionsLoadDone = false;
                const unsubscribeSessions = onSnapshot(activeSessionsCollectionRef, (snapshot) => {
                    const newSessions = [];
                    snapshot.forEach(doc => {
                        newSessions.push({ id: doc.id, ...doc.data() });
                    });
                    firestoreActiveSessions = newSessions;
                    console.log("Firestore: Active Sessions snapshot processed. Sessions count:", firestoreActiveSessions.length);

                    // If the User Directory panel is currently visible, re-render it to update statuses
                    if (userDirectoryPanel && !userDirectoryPanel.classList.contains('hidden')) {
                        renderUserDirectoryTable(); 
                    }

                    if (!initialSessionsLoadDone) {
                        initialSessionsLoadDone = true;
                        console.log("Firestore: Initial Active Sessions loaded.");
                        resolve();
                    }
                }, (error) => {
                    console.error("Firestore: Error listening to active sessions:", error);
                    showMessage("Error: Could not sync active sessions from cloud.", 'error');
                    reject(error);
                });
                // Consider storing unsubscribeSessions if needed
            });

            // Promise for Game Rooms
            const gameRoomsPromise = new Promise((resolve, reject) => {
                let initialGameRoomsLoadDone = false;
                const q = query(gameRoomsCollectionRef, orderBy("createdAt", "desc")); // Order by creation time, newest first
                const unsubscribeGameRooms = onSnapshot(q, (snapshot) => {
                    const newRooms = [];
                    snapshot.forEach(doc => {
                        newRooms.push({ id: doc.id, ...doc.data() });
                    });
                    firestoreGameRooms = newRooms;
                    console.log("Firestore: Game Rooms snapshot processed. Rooms count:", firestoreGameRooms.length);
                    
                    if (gameRoomManagementPanel && !gameRoomManagementPanel.classList.contains('hidden')) {
                        renderGameRoomsList();
                    }
                    // Also re-render user directory if it's visible, as player status might depend on game rooms
                    if (userDirectoryPanel && !userDirectoryPanel.classList.contains('hidden')) {
                        renderUserDirectoryTable();
                    }
                    // Also re-render available rooms list for players if it's visible
                    if (playerJoinRoomPanel && !playerJoinRoomPanel.classList.contains('hidden')) {
                        renderAvailableRoomsList();
                    }

                    // If player is currently viewing a specific game room, update that view
                    if (currentJoinedRoomId && gameRoomViewPanel && !gameRoomViewPanel.classList.contains('hidden')) {
                        const updatedRoomData = newRooms.find(room => room.id === currentJoinedRoomId);
                        if (updatedRoomData) {
                            renderGameRoomView(currentJoinedRoomId); // Re-render with potentially updated player list, status, etc.
                        } else {
                            // The room the player was in has been deleted or is no longer available
                            showMessage("The room you were in is no longer available.", "info");
                            currentJoinedRoomId = null;
                            showPanel(playerJoinRoomPanel); // Go back to lobby
                        }
                    }

                    if (!initialGameRoomsLoadDone) {
                        initialGameRoomsLoadDone = true;
                        console.log("Firestore: Initial Game Rooms loaded.");
                        resolve();
                    }
                }, (error) => {
                    console.error("Firestore: Error listening to game rooms:", error);
                    showMessage("Error: Could not sync game rooms from cloud.", 'error');
                    reject(error);
                });
                // Consider storing unsubscribeGameRooms if needed
            });

            return Promise.all([rolesPromise, profilesPromise, activeSessionsPromise, gameRoomsPromise]);
        }


        // --- Initialize App on DOM Load and Auth State Change ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOMContentLoaded fired. Script is running.');
            showPanel(loadingIndicator); // Show loading indicator immediately

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    // User is authenticated
                    console.log("Firebase: Authenticated. User ID:", user.uid, "Provider:", user.providerData[0]?.providerId || 'N/A');
                    firebaseAuthReady = true;

                    // If not logging out, and data/listeners not yet set up for this session
                    if (!isLoggingOut && !dataLoadedAndListenersSetup) {
                        console.log("onAuthStateChanged: User present and not logging out, triggering handleLoginSuccess.");
                        await handleLoginSuccess(user); // Triggers data load, listener setup, and panel display
                    } else if (isLoggingOut) {
                        console.log("onAuthStateChanged: User present but in logging out state. Skipping automatic login actions.");
                        showPanel(loginButtonsContainer); // Ensure login buttons are shown after logout
                        logoutButton.classList.add('hidden');
                        isLoggingOut = false; // Reset flag
                    } else {
                        // User is authenticated and data/listeners already set up for this session
                        console.log("onAuthStateChanged: User authenticated, data already loaded. Showing appropriate panel.");
                        const storedUser = JSON.parse(localStorage.getItem('loggedInUser'));
                        if (storedUser && storedUser.isAdmin) {
                            showPanel(adminPanel);
                        } else if (storedUser) {
                            showPanel(accountManagementPanel);
                            renderAccountManagementPanel(storedUser);
                        } else {
                            // Fallback if localStorage is somehow out of sync with Firebase auth
                            showPanel(loginButtonsContainer);
                            logoutButton.classList.add('hidden');
                        }
                    }
                    googleLoginButton.disabled = false;
                    // emailPasswordLoginButton.disabled = false; // This line is removed as the element no longer exists

                } else {
                    // No Firebase user is currently authenticated
                    console.log("Firebase: No user authenticated or user logged out.");
                    firebaseAuthReady = true; // Mark auth ready to allow future login attempts

                    if (initialAuthToken && !isLoggingOut) {
                        // Canvas environment: Attempt to sign in with custom token
                        console.log("Firebase: Canvas environment detected. Attempting custom token sign-in.");
                        loadingIndicator.querySelector('span').textContent = 'Authenticating with Canvas...';
                        try {
                            await signInWithCustomToken(auth, initialAuthToken);
                            // If successful, onAuthStateChanged will fire again with `user`, triggering data setup.
                        } catch (error) {
                            console.error("Firebase: Custom authentication failed:", error);
                            showMessage(`Firebase custom auth failed: ${error.message}. Functionality may be limited.`, 'error');
                            showPanel(loginButtonsContainer); // Show login buttons if custom auth fails
                        } finally {
                            loadingIndicator.classList.add('hidden');
                        }
                    } else {
                        // Regular web deployment or after explicit logout
                        console.log("Firebase: Regular deployment or logged out. Displaying login options.");
                        showPanel(loginButtonsContainer);
                        logoutButton.classList.add('hidden');
                        loadingIndicator.classList.add('hidden'); // Hide loading if no auth
                    }
                    // Reset data/listener flag when no user is authenticated
                    dataLoadedAndListenersSetup = false; 
                    googleLoginButton.disabled = false;
                    // emailPasswordLoginButton.disabled = false; // Removed
                }
            });
        });

        // Event listener for Google Login Button (primary login method)
        googleLoginButton.addEventListener('click', async () => {
            console.log('Google Login button clicked.');
            // addLogEntry("Google Login Attempt"); // Removed

            if (!firebaseAuthReady) {
                showMessage("Firebase authentication is not ready yet. Please wait a moment and try again.", 'info');
                return;
            }
            
            googleLoginButton.disabled = true; // Disable button during login attempt
            showMessage("Signing in with Google...", 'info');
            try {
                const result = await signInWithPopup(auth, googleProvider);
                const user = result.user; // Firebase User object
                console.log("Google Sign-In successful:", user);

                await handleLoginSuccess(user); // Pass the Firebase User object directly
                // addLogEntry("Google Login Success", { user: user.email || user.uid }); // Removed

            } catch (error) {
                console.error("Google Sign-In failed:", error);
                let errorMessage = "Google sign-in failed.";
                if (error.code === 'auth/popup-closed-by-user') {
                    errorMessage = "Google login window was closed.";
                } else if (error.code === 'auth/cancelled-popup-request') {
                    errorMessage = "Popup blocked or already open. Please try again.";
                } else if (error.code === 'auth/account-exists-with-different-credential') {
                     errorMessage = `An account already exists with this email using a different login method.`;
                     console.warn(errorMessage, "Provider ID:", error.customData.email, error.credential.providerId);
                } else if (error.code === 'auth/operation-not-allowed') {
                    errorMessage = "Google Sign-In is not enabled in Firebase Authentication settings.";
                }
                showMessage(errorMessage, 'error');
                // addLogEntry("Google Login Failed", { error: error.message }); // Removed
            } finally {
                googleLoginButton.disabled = false; // Re-enable button after attempt
            }
        });

        // Email/Password Login event listener removed.


        // Event listener for logout button
        logoutButton.addEventListener('click', handleLogout);

        // --- Admin Panel Button Event Listeners ---
        manageUsersButton.addEventListener('click', () => {
            const loggedInUser = JSON.parse(localStorage.getItem('loggedInUser'));
            // Use the new 'hasAdminAccess' field from localStorage
            if (loggedInUser && loggedInUser.hasAdminAccess) {
                showPanel(userManagementPanel);
                renderUserRolesTable(); // This will apply new role-based disabling of options
                // addLogEntry("User Management Panel Opened", { user: loggedInUser.username, role: loggedInUser.role }); // Removed for log simplification
            } else {
                showMessage("You do not have administrative access to manage users.", 'error');
                // addLogEntry("User Management Access Denied", { user: loggedInUser?.username || 'Unknown User', attemptedAction: "Open User Management Panel" }); // Removed
            }
        });

        hideUserManagementButton.addEventListener('click', () => {
            showPanel(adminPanel); // Assuming only admins/owners see this button in the first place
        });

        saveUserRolesButton.addEventListener('click', collectAndSaveChanges); // Updated function name


        // Event listeners for log viewer buttons (REMOVED as feature is removed)

        // --- Account Management Button Event Listeners ---
        manageAccountButton.addEventListener('click', () => {
            const loggedInUser = JSON.parse(localStorage.getItem('loggedInUser'));
            if (loggedInUser) {
                showPanel(accountManagementPanel);
                renderAccountManagementPanel(loggedInUser);
                // addLogEntry("Account Management Panel Opened", { user: loggedInUser.username }); // Removed for log simplification
            } else {
                showMessage("Please log in to manage your account.", 'info');
            }
        });

        hideAccountManagementButton.addEventListener('click', () => {
            showPanel(null); // Hide account management, return to the neutral view with main action buttons
        });

        linkGoogleAccountButton.addEventListener('click', handleGoogleLink);

        // --- User Directory Panel Button Event Listeners ---
        viewUserDirectoryButton.addEventListener('click', () => { 
            console.log("View User Directory button clicked."); // Debug log
            const loggedInUser = JSON.parse(localStorage.getItem('loggedInUser'));
            console.log("Logged in user for directory view:", loggedInUser); // Debug log
            if (loggedInUser && (loggedInUser.role === 'player' || loggedInUser.role === 'admin' || loggedInUser.role === 'owner')) {
                showUserDirectoryPanel();
            } else {
                showMessage("You do not have permission to view this.", 'error');
                 // addLogEntry("View User Directory Access Denied", { user: loggedInUser?.username || 'Unknown User', role: loggedInUser?.role }); // Removed
            }
        });

        hideUserDirectoryPanelButton.addEventListener('click', hideUserDirectoryPanel); 


        // --- Event Listeners for New "Open Panel" Buttons ---
        openAdminPanelButton.addEventListener('click', () => {
            // Permission check also happens in handleLoginSuccess for button visibility, 
            // but good to have a check here too in case of direct calls or unforeseen UI states.
            if (auth.currentUser && hasAdminAccess(auth.currentUser.uid)) {
                showPanel(adminPanel);
                // addLogEntry("Admin Panel Opened", { trigger: "OpenAdminPanelButton", by: auth.currentUser.email }); // Removed
            } else {
                showMessage("You do not have permission to access the Admin Panel.", "error");
                // Optionally hide the button if it was erroneously shown
                openAdminPanelButton.classList.add('hidden');
            }
        });

        openAccountManagementButton.addEventListener('click', () => {
            const loggedInUser = JSON.parse(localStorage.getItem('loggedInUser'));
            if (loggedInUser && auth.currentUser) { // Ensure there's an active Firebase auth session too
                showPanel(accountManagementPanel);
                // The loggedInUser object from localStorage should have the formatted name.
                // renderAccountManagementPanel expects an object with {name, username, profilePic}
                // and also uses auth.currentUser for provider info.
                renderAccountManagementPanel(loggedInUser); 
                // addLogEntry("Account Management Panel Opened", { trigger: "OpenAccountManagementButton", by: loggedInUser.username }); // Removed
            } else {
                // This case should ideally not be reached if button visibility is managed correctly.
                showMessage("You need to be logged in to manage your account.", "info");
                showPanel(loginButtonsContainer); // Show login as a fallback
            }
        });

        closeAdminPanelButton.addEventListener('click', () => {
            showPanel(null); // Hide admin panel, return to the neutral view with main action buttons
            // Ensure main action buttons are visible if they were part of a container managed by showPanel
            // However, current logic in handleLoginSuccess makes them visible and they are not hidden by showPanel(specificPanel).
        });

        // --- Game Room Management Panel Event Listeners ---
        manageGameRoomsButton.addEventListener('click', () => {
            console.log("Manage Game Rooms button clicked."); // Debug log
            if (auth.currentUser && hasAdminAccess(auth.currentUser.uid)) {
                console.log("User has admin access, showing gameRoomManagementPanel and calling renderGameRoomsList."); // Debug log
                showPanel(gameRoomManagementPanel);
                renderGameRoomsList(); // Render the list when panel is opened
            } else {
                console.log("User does NOT have admin access for game rooms or not logged in."); // Debug log
                showMessage("You do not have permission to manage game rooms.", "error");
            }
        });

        closeGameRoomManagementPanelButton.addEventListener('click', () => {
            showPanel(adminPanel); // Return to main admin panel
        });

        async function createGameRoom() {
            const roomName = newRoomNameInput.value.trim();
            if (!roomName) {
                showMessage("Room name cannot be empty.", "error");
                return;
            }

            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to create game rooms.", "error");
                return;
            }

            showMessage("Creating game room...", "info");
            try {
                await addDoc(gameRoomsCollectionRef, {
                    roomName: roomName,
                    createdBy: auth.currentUser.uid,
                    createdAt: serverTimestamp(),
                    status: "open", // Initial status
                    players: []      // Initially no players
                });
                showMessage(`Game room "${roomName}" created successfully!`, "success");
                newRoomNameInput.value = ''; // Clear input
                // The list of rooms will update via the Firestore listener in renderGameRoomsList
            } catch (error) {
                console.error("Error creating game room:", error);
                showMessage(`Failed to create game room: ${error.message}`, "error");
            }
        }

        createGameRoomButton.addEventListener('click', createGameRoom);

        async function handleDeleteRoom(roomId, roomName) {
            console.log(`handleDeleteRoom CALLED for roomId: ${roomId}, roomName: ${roomName}`); // Debug
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to delete game rooms.", "error");
                return;
            }

            if (!confirm(`Are you sure you want to permanently delete room: "${roomName}"? This action cannot be undone.`)) {
                return;
            }

            showMessage(`Deleting room "${roomName}"...`, "info");
            try {
                const roomDocRef = doc(gameRoomsCollectionRef, roomId);
                await deleteDoc(roomDocRef);
                showMessage(`Room "${roomName}" deleted successfully.`, "success");
                // The list will automatically update via the Firestore listener.
            } catch (error) {
                console.error("Error deleting game room:", error);
                showMessage(`Failed to delete room "${roomName}": ${error.message}`, "error");
            }
        }

        // --- Player Join Game Panel Listeners ---
        joinGameButton.addEventListener('click', () => {
            if (auth.currentUser) {
                showPanel(playerJoinRoomPanel);
                renderAvailableRoomsList(); // To be implemented next
            } else {
                showMessage("Please log in to join a game.", "info");
                showPanel(loginButtonsContainer);
            }
        });

        closePlayerJoinRoomPanelButton.addEventListener('click', () => {
            showPanel(null); // Return to neutral view
        });

        // --- Game Room Listing ---
        function renderGameRoomsList() {
            console.log("renderGameRoomsList CALLED"); // Debug log
            if (!gameRoomsListContainer) {
                console.error("renderGameRoomsList: gameRoomsListContainer is null!"); // Debug log
                return; 
            }

            gameRoomsListContainer.innerHTML = ''; // Clear previous list

            if (firestoreGameRooms.length === 0) {
                gameRoomsListContainer.innerHTML = '<p class="text-gray-500 text-center py-4">No game rooms created yet.</p>';
                return;
            }

            const ul = document.createElement('ul');
            ul.className = 'space-y-2';

            // Sort rooms, e.g., by creation time (newest first) if createdAt is a valid Timestamp
            // For now, just iterating as is, or sort by name.
            const sortedRooms = [...firestoreGameRooms].sort((a, b) => {
                if (a.createdAt && b.createdAt) { // Assuming createdAt is a Firestore Timestamp
                    return b.createdAt.seconds - a.createdAt.seconds; 
                }
                return (a.roomName || '').localeCompare(b.roomName || '');
            });

            sortedRooms.forEach(room => {
                const li = document.createElement('li');
                li.className = 'p-3 bg-gray-100 rounded-md shadow-sm flex justify-between items-center';
                
                const roomNameSpan = document.createElement('span');
                roomNameSpan.textContent = room.roomName || 'Unnamed Room';
                roomNameSpan.className = 'font-semibold text-gray-800';
                
                const roomStatusSpan = document.createElement('span');
                roomStatusSpan.textContent = `Status: ${room.status || 'N/A'}`;
                roomStatusSpan.className = `text-sm px-2 py-1 rounded-full ${room.status === 'open' ? 'bg-green-200 text-green-800' : 'bg-gray-200 text-gray-800'}`;

                // TODO: Add player count: room.players?.length || 0
                
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'flex items-center space-x-2 mt-2 sm:mt-0 sm:ml-4';

                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.className = 'bg-red-500 hover:bg-red-700 text-white text-xs py-1 px-2 rounded';
                deleteButton.setAttribute('data-room-id', room.id);
                deleteButton.setAttribute('data-room-name', room.roomName || 'Unnamed Room');
                console.log(`Setting delete click for room: ${room.id}, name: ${room.roomName || 'Unnamed Room'}`); // Debug
                deleteButton.onclick = () => handleDeleteRoom(room.id, room.roomName || 'Unnamed Room');

                actionsDiv.appendChild(deleteButton);
                // TODO: Add other admin action buttons here (e.g., View Players, Close/Open Room)


                li.appendChild(roomNameSpan);
                const detailsDiv = document.createElement('div'); // To group status and actions
                detailsDiv.className = "flex flex-col sm:flex-row sm:items-center";
                detailsDiv.appendChild(roomStatusSpan);
                detailsDiv.appendChild(actionsDiv);
                li.appendChild(detailsDiv);

                ul.appendChild(li);
            });
            gameRoomsListContainer.appendChild(ul);
        }

        // --- Player: Render Available Game Rooms List ---
        function renderAvailableRoomsList() {
            if (!availableRoomsListContainer) return;

            availableRoomsListContainer.innerHTML = ''; // Clear previous list

            const openRooms = firestoreGameRooms.filter(room => room.status === 'open');

            if (openRooms.length === 0) {
                availableRoomsListContainer.innerHTML = '<p class="text-gray-500 text-center py-4">No game rooms currently available to join.</p>';
                return;
            }

            const ul = document.createElement('ul');
            ul.className = 'space-y-3';

            openRooms.forEach(room => {
                const li = document.createElement('li');
                li.className = 'p-4 bg-white rounded-lg shadow hover:shadow-md transition-shadow flex flex-col sm:flex-row justify-between items-start sm:items-center space-y-2 sm:space-y-0';

                const roomInfoDiv = document.createElement('div');
                
                const roomNameSpan = document.createElement('span');
                roomNameSpan.textContent = room.roomName || 'Unnamed Room';
                roomNameSpan.className = 'font-semibold text-lg text-indigo-700 block';
                roomInfoDiv.appendChild(roomNameSpan);

                const playerCountSpan = document.createElement('span');
                const currentPlayers = room.players?.length || 0;
                // const maxPlayers = room.maxPlayers || 'N/A'; // Assuming maxPlayers might be added later
                playerCountSpan.textContent = `Players: ${currentPlayers}`; // / ${maxPlayers}
                playerCountSpan.className = 'text-sm text-gray-600 block mt-1';
                roomInfoDiv.appendChild(playerCountSpan);
                
                li.appendChild(roomInfoDiv);

                const joinButton = document.createElement('button');
                joinButton.textContent = 'Join';
                joinButton.className = 'bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out text-sm sm:ml-4 flex-shrink-0 disabled:opacity-50 disabled:cursor-not-allowed';
                joinButton.setAttribute('data-room-id', room.id);
                joinButton.disabled = false; // Default to enabled, specific conditions will disable it.

                if(auth.currentUser) {
                    let playerUID = auth.currentUser.uid;
                    let playerIsCurrentlyInThisRoom = room.players && room.players.includes(playerUID);
                    let playerIsCurrentlyInAnyOtherRoom = false;

                    if (!playerIsCurrentlyInThisRoom) {
                        for (const r of firestoreGameRooms) {
                            if (r.id !== room.id && r.players && r.players.includes(playerUID)) {
                                playerIsCurrentlyInAnyOtherRoom = true;
                                break;
                            }
                        }
                    }

                    if (playerIsCurrentlyInThisRoom) {
                        joinButton.textContent = 'View Current Game';
                        joinButton.className = 'bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out text-sm sm:ml-4 flex-shrink-0';
                        joinButton.onclick = () => {
                            currentJoinedRoomId = room.id;
                            showPanel(gameRoomViewPanel);
                            renderGameRoomView(room.id);
                        };
                    } else if (playerIsCurrentlyInAnyOtherRoom) {
                        joinButton.textContent = 'Join';
                        joinButton.className = 'bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out text-sm sm:ml-4 flex-shrink-0 disabled:opacity-50 disabled:cursor-not-allowed';
                        joinButton.disabled = true; // Player is in another room
                        joinButton.onclick = () => handleJoinRoom(room.id); // Keep original join action, though disabled
                    } else { // Player is in no room
                        joinButton.textContent = 'Join';
                        joinButton.className = 'bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out text-sm sm:ml-4 flex-shrink-0 disabled:opacity-50 disabled:cursor-not-allowed';
                        joinButton.onclick = () => handleJoinRoom(room.id);
                        if (room.status !== 'open') {
                            joinButton.disabled = true; // Room is not open to join
                        }
                    }
                } else {
                    // No user logged in, disable join
                    joinButton.textContent = 'Join';
                    joinButton.className = 'bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out text-sm sm:ml-4 flex-shrink-0 disabled:opacity-50 disabled:cursor-not-allowed';
                    joinButton.disabled = true;
                }
                
                // Final check, if room is not open and it's not the "View Current Game" button
                if (room.status !== 'open' && joinButton.textContent === 'Join') { 
                    joinButton.disabled = true;
                }
                li.appendChild(joinButton);
                ul.appendChild(li);
            });
            availableRoomsListContainer.appendChild(ul);
        }

        function renderGameRoomView(roomId) {
            if (!gameRoomViewPanel || !auth.currentUser) {
                console.error("renderGameRoomView: Panel or user not available.");
                showPanel(playerJoinRoomPanel); // Fallback to lobby
                return;
            }

            const room = firestoreGameRooms.find(r => r.id === roomId);
            if (!room) {
                console.error(`renderGameRoomView: Room with ID ${roomId} not found in firestoreGameRooms.`);
                showMessage("Error: The room you were in could not be found.", "error");
                currentJoinedRoomId = null;
                showPanel(playerJoinRoomPanel); // Fallback to lobby
                adminGameControls.classList.add('hidden'); // Ensure admin controls are hidden on error/fallback
                updateChipsPanel.classList.add('hidden'); // Ensure update chips panel is hidden
                return;
            }

            gameRoomViewName.textContent = room.roomName || 'Unnamed Room';

            // Admin controls visibility check at the beginning of render
            if (auth.currentUser && hasAdminAccess(auth.currentUser.uid)) {
                adminGameControls.classList.remove('hidden');
                // Event listeners for admin buttons are now set here to ensure they have the correct roomId
                adminRoomResetButton.onclick = () => adminRoomReset(roomId);
                adminUpdateChipsButton.onclick = () => toggleUpdateChipsPanel(roomId, true); // Show panel
                cancelChipUpdate.onclick = () => toggleUpdateChipsPanel(roomId, false);    // Hide panel
                submitChipUpdate.onclick = () => handleSubmitChipUpdate(roomId);
            } else {
                adminGameControls.classList.add('hidden');
                updateChipsPanel.classList.add('hidden'); // Also hide the panel if user is not admin
            }

            // Populate player list
            if (!roomPlayersListContainer) {
                console.error("renderGameRoomView: roomPlayersListContainer is null!");
                return;
            }
            roomPlayersListContainer.innerHTML = ''; // Clear previous player list

            // Calculate the highest bet in the current round - MOVED HERE
            const highestBet = Object.values(room.currentBets || {}).reduce((max, bet) => Math.max(max, bet), 0);

            console.log('--- ADMIN ACCESS CHECK (Overall):', auth.currentUser?.uid, hasAdminAccess(auth.currentUser?.uid)); // Step 1 Debug Log

            if (!room.players || room.players.length === 0) {
                roomPlayersListContainer.innerHTML = '<p class="text-gray-400 col-span-full text-center py-4">No players in this room yet.</p>';
            } else {
                room.players.forEach(playerId => {
                    const playerProfile = allFirebaseUsersData.find(p => p.uid === playerId);
                    const playerName = playerProfile ? formatDisplayName(playerProfile) : `Player UID: ${playerId}`;
                    const playerChips = playerProfile ? (playerProfile.chip_count ?? 0) : 'N/A';
                    
                    const rawStatus = room.playerStatuses ? room.playerStatuses[playerId] : 'pending';
                    const playerBetAmount = room.currentBets ? (room.currentBets[playerId] ?? 0) : 0;

                    let displayStatus = rawStatus;
                    let cardBgColor = 'bg-gray-700'; // Default

                    if (rawStatus === 'folded') {
                        displayStatus = 'Folded';
                        cardBgColor = 'bg-red-600 hover:bg-red-700'; // Darker red
                    } else if (rawStatus === 'all-in') {
                        displayStatus = 'All-In';
                        cardBgColor = 'bg-purple-600 hover:bg-purple-700'; // Darker purple
                    } else if (highestBet > 0 && playerBetAmount < highestBet) {
                        displayStatus = 'Pending';
                        cardBgColor = 'bg-yellow-500 hover:bg-yellow-600'; // Darker yellow
                    } else { // Includes playerBetAmount === highestBet, or highestBet is 0
                        displayStatus = 'Ready';
                        cardBgColor = 'bg-green-600 hover:bg-green-700'; // Darker green
                    }

                    const playerCard = document.createElement('div');
                    // Base classes with transition for color change
                    playerCard.className = `p-3 rounded shadow text-white transition-colors duration-300 ease-in-out ${cardBgColor}`;
                    
                    const nameEl = document.createElement('p');
                    nameEl.className = 'font-semibold text-lg'; // Adjusted text color for better contrast on varied backgrounds
                    nameEl.textContent = playerName;
                    playerCard.appendChild(nameEl);

                    const chipsEl = document.createElement('p');
                    chipsEl.className = 'text-sm';
                    chipsEl.textContent = `Chips: ${playerChips}`;
                    playerCard.appendChild(chipsEl);

                    const statusTextEl = document.createElement('p');
                    statusTextEl.className = 'text-sm font-medium mt-1';
                    statusTextEl.textContent = `Status: ${displayStatus}`;
                    playerCard.appendChild(statusTextEl);
                    
                    const betEl = document.createElement('p');
                    betEl.className = 'text-xs';
                    betEl.textContent = `Bet: ${playerBetAmount}`; 
                    playerCard.appendChild(betEl);

                    // Admin Menu for Player Card - Debugging
                    // console.log('Admin Check before if:', auth.currentUser?.uid, typeof auth.currentUser?.uid !== 'undefined' ? hasAdminAccess(auth.currentUser.uid) : 'N/A (no user)');
                    if (auth.currentUser && hasAdminAccess(auth.currentUser.uid)) {
                        // console.log('Admin menu WILL be created for player:', playerName);
                        const adminMenuButton = document.createElement('button');
                        adminMenuButton.innerHTML = '&#8942;'; // Vertical ellipsis
                        // Restored Tailwind classes for subtle styling
                        adminMenuButton.className = 'absolute top-2 right-2 text-gray-200 hover:text-white p-1 rounded-full focus:outline-none focus:ring-2 focus:ring-gray-500'; 
                        
                        const adminMenuDropdown = document.createElement('div');
                        adminMenuDropdown.className = 'hidden absolute top-8 right-2 bg-gray-600 text-white rounded-md shadow-lg py-1 z-10 min-w-max';
                        adminMenuDropdown.id = `admin-menu-${playerId}`;
                        adminMenuDropdown.innerHTML = ''; // Clear placeholder

                        // "Remove Player" option
                        const removePlayerButton = document.createElement('button');
                        removePlayerButton.textContent = 'Remove Player';
                        removePlayerButton.className = 'block w-full text-left px-3 py-2 text-sm hover:bg-gray-500 focus:outline-none';
                        if (playerId === auth.currentUser.uid) { // Prevent admin from removing self this way
                            removePlayerButton.disabled = true;
                            removePlayerButton.title = "Cannot remove yourself";
                            removePlayerButton.classList.add('opacity-50', 'cursor-not-allowed');
                        } else {
                            removePlayerButton.onclick = (event) => {
                                event.stopPropagation();
                                adminRemovePlayer(roomId, playerId, playerName);
                                adminMenuDropdown.classList.add('hidden'); // Close menu after action
                            };
                        }
                        adminMenuDropdown.appendChild(removePlayerButton);

                        // "Force Fold Player" option
                        const forceFoldButton = document.createElement('button');
                        forceFoldButton.textContent = 'Force Fold';
                        forceFoldButton.className = 'block w-full text-left px-3 py-2 text-sm hover:bg-gray-500 focus:outline-none';
                        
                        const targetPlayerCurrentStatus = room.playerStatuses ? room.playerStatuses[playerId] : 'pending';
                        if (playerId === auth.currentUser.uid || targetPlayerCurrentStatus === 'folded' || targetPlayerCurrentStatus === 'all-in') {
                            forceFoldButton.disabled = true;
                            forceFoldButton.title = (playerId === auth.currentUser.uid) ? "Cannot force fold yourself" : "Player already folded or all-in";
                            forceFoldButton.classList.add('opacity-50', 'cursor-not-allowed');
                        } else {
                            forceFoldButton.onclick = (event) => {
                                event.stopPropagation();
                                adminForceFoldPlayer(roomId, playerId, playerName);
                                adminMenuDropdown.classList.add('hidden'); // Close menu
                            };
                        }
                        adminMenuDropdown.appendChild(forceFoldButton);

                        // "Place Bet for Player" option
                        const placeBetForPlayerButton = document.createElement('button');
                        placeBetForPlayerButton.textContent = 'Place Bet for Player';
                        placeBetForPlayerButton.className = 'block w-full text-left px-3 py-2 text-sm hover:bg-gray-500 focus:outline-none';

                        if (targetPlayerCurrentStatus === 'folded' || targetPlayerCurrentStatus === 'all-in') {
                            placeBetForPlayerButton.disabled = true;
                            placeBetForPlayerButton.title = "Player is folded or all-in";
                            placeBetForPlayerButton.classList.add('opacity-50', 'cursor-not-allowed');
                        } else {
                            placeBetForPlayerButton.onclick = (event) => {
                                event.stopPropagation();
                                adminPlaceBetForPlayer(roomId, playerId, playerName, playerChips); // Pass playerChips for validation
                                adminMenuDropdown.classList.add('hidden'); // Close menu
                            };
                        }
                        adminMenuDropdown.appendChild(placeBetForPlayerButton);

                        // "Declare Winner" option (Placeholder) - REMOVED
                        // const declareWinnerButton = document.createElement('button');
                        // declareWinnerButton.textContent = 'Declare Winner (Placeholder)';
                        // declareWinnerButton.className = 'block w-full text-left px-3 py-2 text-sm hover:bg-gray-500 focus:outline-none';
                        // // Enable for any active player, admin can decide if it makes sense.
                        // // Could be disabled if player is folded.
                        // if (targetPlayerCurrentStatus === 'folded') {
                        //      declareWinnerButton.disabled = true;
                        //      declareWinnerButton.title = "Cannot declare a folded player as winner";
                        //      declareWinnerButton.classList.add('opacity-50', 'cursor-not-allowed');
                        // } else {
                        //     declareWinnerButton.onclick = (event) => {
                        //         event.stopPropagation();
                        //         adminDeclareWinner(roomId, playerId, playerName);
                        //         adminMenuDropdown.classList.add('hidden'); // Close menu
                        //     };
                        // }
                        // adminMenuDropdown.appendChild(declareWinnerButton);
                        
                        // Placeholder for more actions (if any more are added after this)
                        // const comingSoon = document.createElement('p'); 
                        // comingSoon.className = 'px-3 py-1 text-xs text-gray-400 border-t border-gray-500 mt-1 pt-1';
                        // comingSoon.textContent = 'More actions soon...';
                        // adminMenuDropdown.appendChild(comingSoon);


                        playerCard.appendChild(adminMenuButton);
                        playerCard.appendChild(adminMenuDropdown); // Append to card to be relative to it

                        adminMenuButton.onclick = (event) => {
                            event.stopPropagation(); // Prevent card click or other underlying events
                            // Hide any other open admin menus
                            document.querySelectorAll('[id^="admin-menu-"]').forEach(menu => {
                                if (menu.id !== adminMenuDropdown.id) {
                                    menu.classList.add('hidden');
                                }
                            });
                            adminMenuDropdown.classList.toggle('hidden');
                        };
                        
                        // Clicking outside the dropdown should close it
                        // This listener is added once per renderGameRoomView, ideally should be managed more globally or cleaned up
                        // For now, this is a simple approach.
                        document.body.addEventListener('click', (event) => {
                            if (!adminMenuDropdown.contains(event.target) && !adminMenuButton.contains(event.target)) {
                                adminMenuDropdown.classList.add('hidden');
                            }
                        }, { once: true }); // Use once to auto-remove after first trigger, or manage removal carefully
                    }
                    playerCard.style.position = 'relative'; // Needed for absolute positioning of dropdown/button

                    roomPlayersListContainer.appendChild(playerCard);
                });
            }

            // Update player's chip count for betting UI
            const currentUserProfileForBetUI = allFirebaseUsersData.find(p => p.uid === auth.currentUser.uid);
            if (currentUserProfileForBetUI && playerChipCountForBet) {
                playerChipCountForBet.textContent = currentUserProfileForBetUI.chip_count ?? 0;
                if (playerBetInput) {
                    playerBetInput.max = currentUserProfileForBetUI.chip_count ?? 0;
                }
            } else if (playerChipCountForBet) {
                playerChipCountForBet.textContent = 'N/A';
                 if (playerBetInput) {
                    playerBetInput.removeAttribute('max');
                }
            }

            // Calculate and Display Game Stats
            const gameStatsContent = document.getElementById('gameStatsContent');
            if (gameStatsContent) {
                gameStatsContent.innerHTML = ''; // Clear previous stats

                const totalPot = Object.values(room.currentBets || {}).reduce((sum, bet) => sum + bet, 0);
                // highestBet is now defined in the outer scope of this function.
                
                const totalPotEl = document.createElement('p');
                totalPotEl.innerHTML = `<strong>Total Pot:</strong> ${totalPot} chips`;
                gameStatsContent.appendChild(totalPotEl);

                const highestBetEl = document.createElement('p');
                highestBetEl.innerHTML = `<strong>Highest Bet This Round:</strong> ${highestBet} chips`; 
                gameStatsContent.appendChild(highestBetEl);

                const activePlayersBetsTitle = document.createElement('h5');
                activePlayersBetsTitle.className = 'text-md font-semibold mt-3 mb-1 text-gray-200';
                activePlayersBetsTitle.textContent = 'Active Player Bets:';
                gameStatsContent.appendChild(activePlayersBetsTitle);

                const activePlayersUl = document.createElement('ul');
                activePlayersUl.className = 'list-disc list-inside text-sm space-y-1';

                let activePlayerFound = false;
                if (room.players && room.playerStatuses && room.currentBets) {
                    room.players.forEach(playerId => {
                        const status = room.playerStatuses[playerId];
                        const bet = room.currentBets[playerId] ?? 0;
                        if (status !== 'folded') {
                            const playerProfile = allFirebaseUsersData.find(p => p.uid === playerId);
                            const playerName = playerProfile ? formatDisplayName(playerProfile) : `UID: ${playerId.substring(0,6)}`;
                            const li = document.createElement('li');
                            li.textContent = `${playerName}: ${bet} chips`;
                            activePlayersUl.appendChild(li);
                            activePlayerFound = true;
                        }
                    });
                }

                if (!activePlayerFound) {
                    const noActiveEl = document.createElement('p');
                    noActiveEl.className = 'text-sm text-gray-400';
                    noActiveEl.textContent = 'No players currently active in the pot.';
                    activePlayersUl.appendChild(noActiveEl);
                }
                gameStatsContent.appendChild(activePlayersUl);

                // Placeholder for future side pot display refinement
                const sidePotInfo = document.createElement('p');
                sidePotInfo.className = 'text-xs text-gray-500 mt-2';
                sidePotInfo.textContent = '(Detailed side pot calculations will be shown here in a future update.)';
                gameStatsContent.appendChild(sidePotInfo);

            } else {
                console.warn("gameStatsContent element not found for rendering stats.");
            }


            // Wire up buttons in this panel
            leaveCurrentGameRoomButton.onclick = () => {
                handleLeaveRoom(roomId);
                adminGameControls.classList.add('hidden'); // Ensure admin controls are hidden
                updateChipsPanel.classList.add('hidden'); // Ensure update chips panel is hidden
            };
            closeGameRoomViewButton.onclick = () => {
                currentJoinedRoomId = null; // Clear joined room state
                showPanel(playerJoinRoomPanel); // Show the lobby/list of rooms
                adminGameControls.classList.add('hidden'); // Hide admin controls when leaving room view
                updateChipsPanel.classList.add('hidden'); // Hide chip update panel if open
            };

            // Assign handlePlaceBet directly to the onclick event
            placeBetButton.onclick = () => handlePlaceBet(roomId);
            foldButton.onclick = () => handleFold(roomId); // Wire up Fold button
            allInButton.onclick = () => handleAllIn(roomId); // Wire up All-In button

            // Admin controls visibility is handled at the top of renderGameRoomView.
            // Event listeners for admin buttons are also set there.

            // Disable action buttons if player is folded or all-in
            const currentPlayerStatus = room.playerStatuses ? room.playerStatuses[auth.currentUser.uid] : null;
            if (currentPlayerStatus === 'folded' || currentPlayerStatus === 'all-in') {
                placeBetButton.disabled = true;
                foldButton.disabled = true;
                allInButton.disabled = true;
                playerBetInput.disabled = true; 
            } else {
                placeBetButton.disabled = false;
                foldButton.disabled = false;
                allInButton.disabled = false;
                playerBetInput.disabled = false;
            }
        }

        async function handleAllIn(roomId) {
            if (!auth.currentUser) {
                showMessage("You must be logged in to go all-in.", "error");
                return;
            }
            const userId = auth.currentUser.uid;
            const roomDocRef = doc(gameRoomsCollectionRef, roomId);

            // Get player's current chip count
            const userProfile = allFirebaseUsersData.find(p => p.uid === userId);
            if (!userProfile || typeof userProfile.chip_count !== 'number') {
                showMessage("Could not retrieve your chip count to go all-in.", "error");
                console.error("All-In: User profile or chip_count not found for", userId, userProfile);
                return;
            }
            const allInAmount = userProfile.chip_count;

            if (allInAmount <= 0) {
                showMessage("You have no chips to go all-in with.", "info");
                // Optionally, could auto-fold the player here or prevent all-in if it means betting 0.
                // For now, just inform. If their current bet is already > 0, this might be an edge case.
                return;
            }

            showMessage(`Going all-in with ${allInAmount} chips...`, "info");
            try {
                const updates = {
                    [`currentBets.${userId}`]: allInAmount,
                    [`playerStatuses.${userId}`]: 'all-in',
                    [`playerLastActions.${userId}`]: 'all-in'
                };
                await updateDoc(roomDocRef, updates);

                // IMPORTANT: Deduct chips from the player's actual profile
                // This is a critical operation and ideally should be part of a transaction
                // if combined with other game state changes that must succeed or fail together.
                // For now, we'll update the user_profiles document directly.
                // Consider moving chip deduction to when a hand/round resolves to avoid issues if a game crashes.
                // However, the requirement was "Deducts chips from the player's profile".
                // Let's proceed with caution. If this direct deduction is problematic,
                // we will revise to only mark chips as "in play" from the room's perspective.

                // For this iteration, we will NOT directly deduct from user_profiles here.
                // The allInAmount is recorded in currentBets. Chip reconciliation will be a later step
                // (e.g., when the pot is awarded or if a player leaves).
                // This avoids complexity with partial game states and rollbacks.

                showMessage(`You are all-in with ${allInAmount}!`, "success");
                // UI will update via Firestore listener, disabling buttons.
            } catch (error) {
                console.error("Error going all-in:", error);
                showMessage(`Failed to go all-in: ${error.message}`, "error");
            }
        }

        async function adminDeclareWinner(roomId, targetPlayerId, targetPlayerName) {
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to declare winners.", "error");
                return;
            }

            const targetPlayerCurrentStatus = firestoreGameRooms.find(r => r.id === roomId)?.playerStatuses?.[targetPlayerId];
            if (targetPlayerCurrentStatus === 'folded') {
                showMessage(`${targetPlayerName} is folded and cannot be declared a winner.`, "info");
                return;
            }

            if (!confirm(`Are you sure you want to declare ${targetPlayerName || 'this player'} as the winner of the current pot? This is a placeholder action.`)) {
                return;
            }

            console.log(`ADMIN ACTION: Declare Winner triggered for player ${targetPlayerName} (UID: ${targetPlayerId}) in room ${roomId}. Pot distribution logic is pending.`);
            alert(`Admin action: Declared ${targetPlayerName} as winner of the current pot. (Note: Pot distribution is not yet implemented.)`);
            
            // In a full implementation, this would trigger:
            // 1. Calculation of main pot and any side pots.
            // 2. Distribution of chips to the winner(s) - updating their chip_count in user_profiles.
            // 3. Resetting currentBets for all players in the room.
            // 4. Potentially advancing the game state (e.g., new round, new dealer).
            // For now, it's just a notification.
            showMessage(`Placeholder: ${targetPlayerName} declared winner. No chips moved yet.`, "info");
        }

        async function handleFold(roomId) {
            if (!auth.currentUser) {
                showMessage("You must be logged in to fold.", "error");
                return;
            }
            const userId = auth.currentUser.uid;
            const roomDocRef = doc(gameRoomsCollectionRef, roomId);

            showMessage("Folding your hand...", "info");
            try {
                const updates = {
                    [`playerStatuses.${userId}`]: 'folded',
                    [`playerLastActions.${userId}`]: 'fold'
                    // Optionally, set currentBets[userId] to a specific value like -1 or keep as is
                };
                await updateDoc(roomDocRef, updates);
                showMessage("You have folded.", "success");
                // The gameRoomView will re-render due to the Firestore listener,
                // which should update UI elements (e.g., disable buttons, change player card color).
            } catch (error) {
                console.error("Error folding:", error);
                showMessage(`Failed to fold: ${error.message}`, "error");
            }
        }

        async function handleJoinRoom(roomId) {
            if (!auth.currentUser) {
                showMessage("You must be logged in to join a room.", "error");
                return;
            }
            const userId = auth.currentUser.uid;

            // Check if player is already in any room (client-side check for quick UI feedback)
            for (const r of firestoreGameRooms) {
                if (r.players && r.players.includes(userId)) {
                    if (r.id === roomId) {
                        showMessage("You are already in this room.", "info");
                    } else {
                        showMessage("You are already in another game room. Please leave it before joining a new one.", "error");
                    }
                    return;
                }
            }

            const roomDocRef = doc(gameRoomsCollectionRef, roomId);
            showMessage("Joining room...", "info");

            try {
                const roomSnap = await getDoc(roomDocRef);
                if (!roomSnap.exists()) {
                    showMessage("Error: Room not found.", "error");
                    renderAvailableRoomsList(); // Refresh list as room might have been deleted
                    return;
                }

                const roomData = roomSnap.data();
                if (roomData.status !== 'open') {
                    showMessage("This room is no longer open to join.", "error");
                    renderAvailableRoomsList(); // Refresh list
                    return;
                }

                // Optional: Check for maxPlayers if implemented
                // if (roomData.players.length >= roomData.maxPlayers) {
                //     showMessage("This room is full.", "error");
                //     renderAvailableRoomsList(); // Refresh list
                //     return;
                // }
                
                // Add player to the room and initialize their game state
                const updates = {
                    players: arrayUnion(userId),
                    [`currentBets.${userId}`]: 0, // Initialize bet to 0
                    [`playerStatuses.${userId}`]: 'pending', // Initial status
                    [`playerLastActions.${userId}`]: 'joined' // Initial action
                };
                await updateDoc(roomDocRef, updates);

                showMessage("Successfully joined the room!", "success");
                currentJoinedRoomId = roomId; // Set the current joined room ID
                showPanel(gameRoomViewPanel);   // Show the dedicated game room view
                renderGameRoomView(roomId);     // Populate the view
            } catch (error) {
                console.error("Error joining room:", error);
                showMessage(`Failed to join room: ${error.message}`, "error");
            }
        }

        // --- Admin Game Control Functions ---
        async function adminRoomReset(roomId) {
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to reset the room.", "error");
                return;
            }

            const roomDocRef = doc(gameRoomsCollectionRef, roomId);
            const room = firestoreGameRooms.find(r => r.id === roomId);

            if (!room || !room.players) {
                showMessage("Room data or players not found.", "error");
                return;
            }

            if (!confirm("Are you sure you want to reset all bets to 0 and unfold all players?")) {
                return;
            }

            showMessage("Resetting room...", "info");
            try {
                const updates = {};
                room.players.forEach(playerId => {
                    updates[`currentBets.${playerId}`] = 0;
                    updates[`playerStatuses.${playerId}`] = 'pending'; // Or 'ready' depending on desired default
                    updates[`playerLastActions.${playerId}`] = 'room_reset';
                });

                // Also reset overall room properties if needed, e.g., pot, current round, etc.
                // For now, focusing on player bets and statuses.

                await updateDoc(roomDocRef, updates);
                showMessage("Room has been reset. All bets are 0, players unfolded.", "success");
                // UI will update via Firestore listener in renderGameRoomView
            } catch (error) {
                console.error("Error resetting room:", error);
                showMessage(`Failed to reset room: ${error.message}`, "error");
            }
        }

        function toggleUpdateChipsPanel(roomId, show) { // Renamed and modified
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to access this feature.", "error");
                return;
            }
            if (show) {
                populateUpdateChipsPanel(roomId); // Populate before showing
                updateChipsPanel.classList.remove('hidden');
            } else {
                updateChipsPanel.classList.add('hidden');
            }
        }

        function populateUpdateChipsPanel(roomId) {
            if (!updateChipsPlayerList) return;
            updateChipsPlayerList.innerHTML = ''; // Clear previous content

            const room = firestoreGameRooms.find(r => r.id === roomId);
            if (!room || !room.players || room.players.length === 0) {
                updateChipsPlayerList.innerHTML = '<p class="text-gray-400">No players in the room to update.</p>';
                return;
            }

            room.players.forEach(playerId => {
                const playerProfile = allFirebaseUsersData.find(p => p.uid === playerId);
                const playerName = playerProfile ? formatDisplayName(playerProfile) : `Player UID: ${playerId}`;
                const playerStatus = room.playerStatuses ? room.playerStatuses[playerId] : 'unknown';

                // Only include players who are not folded for ranking
                if (playerStatus === 'folded') {
                    const foldedPlayerDiv = document.createElement('div');
                    foldedPlayerDiv.className = 'flex justify-between items-center p-2 bg-gray-600 rounded';
                    foldedPlayerDiv.innerHTML = `
                        <span class="text-gray-400">${playerName} (Folded)</span>
                        <span class="text-xs text-gray-500">Cannot rank folded players</span>
                    `;
                    updateChipsPlayerList.appendChild(foldedPlayerDiv);
                    return; // Skip to next player
                }

                const playerDiv = document.createElement('div');
                playerDiv.className = 'flex justify-between items-center p-2 bg-gray-600 rounded';

                const nameSpan = document.createElement('span');
                nameSpan.textContent = playerName;
                nameSpan.className = 'text-gray-100';
                playerDiv.appendChild(nameSpan);

                const selectRank = document.createElement('select');
                selectRank.className = 'bg-gray-500 text-white border border-gray-400 rounded-md p-1 text-sm focus:ring-blue-500 focus:border-blue-500';
                selectRank.setAttribute('data-player-id', playerId);

                const ranks = [
                    { value: '0', text: 'No Win / Loser' },
                    { value: '1', text: 'Winner 1st' },
                    { value: '2', text: 'Winner 2nd' },
                    { value: '3', text: 'Winner 3rd' }
                ];

                ranks.forEach(rank => {
                    const option = document.createElement('option');
                    option.value = rank.value;
                    option.textContent = rank.text;
                    selectRank.appendChild(option);
                });
                selectRank.value = '0'; // Default to "No Win"
                playerDiv.appendChild(selectRank);
                updateChipsPlayerList.appendChild(playerDiv);
            });
        }

        async function handleSubmitChipUpdate(roomId) {
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to perform this action.", "error");
                return;
            }

            const room = firestoreGameRooms.find(r => r.id === roomId);
            if (!room || !room.players || room.players.length === 0) {
                showMessage("No player data found for this room.", "error");
                return;
            }

            // Collect rankings
            const playerRankings = [];
            const rankSelects = updateChipsPlayerList.querySelectorAll('select[data-player-id]');
            rankSelects.forEach(select => {
                playerRankings.push({
                    playerId: select.getAttribute('data-player-id'),
                    rank: parseInt(select.value, 10) // 0 for No Win, 1, 2, 3
                });
            });

            if (playerRankings.some(p => p.rank > 0 && (room.playerStatuses[p.playerId] === 'folded'))) {
                 showMessage("Error: Folded players cannot be assigned a winning rank. Please correct and resubmit.", "error");
                 return;
            }

            // --- Pot Calculation and Distribution Logic ---
            let totalPot = Object.values(room.currentBets || {}).reduce((sum, bet) => sum + (bet || 0), 0);
            if (totalPot <= 0) {
                showMessage("Pot is zero or empty. No chips to distribute.", "info");
                await adminRoomReset(roomId); // Reset the room as there's nothing to award.
                toggleUpdateChipsPanel(roomId, false); // Hide panel
                return;
            }

            console.log("Initial Total Pot (sum of currentBets):", totalPot);
            console.log("Player Rankings from UI:", playerRankings);

            // --- Phase 1: Debit all bets and prepare player data ---
            const playersInHand = []; // Array to store processed player data for this hand
            const chipChanges = {};   // Stores net change for each player's profile update

            for (const playerId in room.currentBets) {
                if (room.currentBets.hasOwnProperty(playerId)) {
                    const betAmount = room.currentBets[playerId] || 0;
                    if (betAmount <= 0 && room.playerStatuses[playerId] !== 'folded') { // Allow folded players to have 0 bet if they folded before betting
                        // If a player is active but has 0 bet, they are not really in the hand for winning/losing pot.
                        // But if they were ranked, it's an inconsistency. The ranking UI should prevent this.
                        // For now, we mostly care about players who have bet.
                        continue;
                    }

                    const profile = allFirebaseUsersData.find(p => p.uid === playerId);
                    const playerStatus = room.playerStatuses[playerId];
                    const rankingInfo = playerRankings.find(r => r.playerId === playerId);
                    const rank = rankingInfo ? rankingInfo.rank : 0; // Default to "No Win" if not in selection (e.g. folded player not in UI)

                    if (rank > 0 && playerStatus === 'folded') {
                         showMessage(`Error: Player ${profile ? formatDisplayName(profile) : playerId} is FOLDED but assigned rank ${rank}. Cannot proceed.`, "error");
                         return; // Critical error, stop processing
                    }

                    playersInHand.push({
                        uid: playerId,
                        name: profile ? formatDisplayName(profile) : `UID: ${playerId.substring(0,6)}`,
                        bet: betAmount,
                        initialChips: profile ? (profile.chip_count || 0) : 0,
                        isAllIn: playerStatus === 'all-in',
                        isFolded: playerStatus === 'folded',
                        rank: rank,
                        winnings: 0, // How much this player wins from the pot
                        // Initial change is loss of their bet. This will be adjusted by winnings or returned amounts.
                        netChipChange: (betAmount > 0 && !playerStatus === 'folded') ? -betAmount : 0
                                       // If folded, their bet is already "lost" to the pot.
                                       // If they didn't bet, no change initially.
                                       // This needs to be careful: if a player folds, their bet IS part of the pot.
                                       // The `chipChanges` will store the *final* update amount for their profile.
                    });

                    // Initialize chipChanges: everyone who bet loses their bet initially.
                    // If folded, their bet is already part of the pot calculation.
                    if (betAmount > 0) {
                         chipChanges[playerId] = -betAmount;
                    } else {
                         chipChanges[playerId] = 0;
                    }
                }
            }

            console.log("--- Phase 1 Complete ---");
            console.log("Total Pot (from sum of bets):", totalPot);
            console.log("Players In Hand (with initial bet debit):", JSON.parse(JSON.stringify(playersInHand)));
            console.log("Initial Chip Changes (bets debited):", JSON.parse(JSON.stringify(chipChanges)));

            // --- Phase 2: Distribute Winnings ---
            // Sort WINNERS by rank (1st, 2nd, 3rd), then by bet amount (smallest all-in first to define side pots)
            // Losers (rank 0) or folded players are not part of this sorted list for *winning* distribution.
            const rankedWinners = playersInHand.filter(p => p.rank > 0 && !p.isFolded && p.bet > 0)
                .sort((a, b) => {
                    if (a.rank !== b.rank) return a.rank - b.rank;
                    return a.bet - b.bet; // Smaller bets (usually all-ins) first for their pot slice
                });

            console.log("Ranked Winners (sorted for distribution):", JSON.parse(JSON.stringify(rankedWinners)));

            let potContributions = playersInHand
                .filter(p => !p.isFolded && p.bet > 0) // Only players who contributed to this pot and didn't fold
                .map(p => ({ uid: p.uid, contributed: p.bet, stillInPlay: p.bet, returned: 0 }));

            console.log("Initial Pot Contributions:", JSON.parse(JSON.stringify(potContributions)));

            for (const winner of rankedWinners) {
                if (totalPot <= 0) break; // No more pot to distribute

                let amountWonByThisWinner = 0;
                let winnerMaxEligibleFromThisPot = 0;

                // Calculate the maximum this winner can win from the players still in play
                // This forms the "pot" this winner is competing for.
                let currentPotForWinner = 0;
                potContributions.forEach(pc => {
                    if (pc.stillInPlay > 0) {
                         // Winner can take up to their own bet from pc's contribution, or what's left of pc's contribution
                        currentPotForWinner += Math.min(winner.bet, pc.stillInPlay);
                    }
                });
                // Winner's own bet is also part of this pot they are competing for
                currentPotForWinner = Math.min(currentPotForWinner, totalPot); // Cannot be more than total available pot

                // How many other winners of the same rank are also competing for this exact same pot slice?
                const coWinnersForThisPotSlice = rankedWinners.filter(rw =>
                    rw.rank === winner.rank &&
                    rw.uid !== winner.uid &&
                    rw.bet >= winner.bet // Co-winners must have bet at least as much to fully share this slice
                ).length + 1; // +1 for the current winner

                let shareForThisWinner = Math.round(currentPotForWinner / coWinnersForThisPotSlice);
                shareForThisWinner = Math.min(shareForThisWinner, totalPot); // Cannot win more than what's globally left

                // Distribute 'shareForThisWinner' by taking from potContributions
                for (const contributor of potContributions) {
                    if (shareForThisWinner <= 0) break;
                    if (contributor.uid === winner.uid) continue; // Don't take from self here, own bet is "returned" as part of winnings

                    const amountToTake = Math.min(shareForThisWinner, contributor.stillInPlay, winner.bet);
                    if (amountToTake > 0) {
                        contributor.stillInPlay -= amountToTake;
                        amountWonByThisWinner += amountToTake;
                        shareForThisWinner -= amountToTake;
                        totalPot -= amountToTake;
                    }
                }
                // Add winner's own bet back as part of their winnings
                const winnerOriginalContributionRec = potContributions.find(pc => pc.uid === winner.uid);
                if (winnerOriginalContributionRec) {
                    const ownBetToReclaim = Math.min(winner.bet, winnerOriginalContributionRec.stillInPlay, amountWonByThisWinner > 0 ? winner.bet : 0);
                    // ^ only reclaim own bet if actually won something from others, or if it's a pure chop of own money
                    // More simply: if they won, their bet is part of the winnings.
                    // The amountWonByThisWinner is from *others*. So total win = amountWonByThisWinner + own_bet_back.
                    // Let's adjust chipChanges directly.
                }

                chipChanges[winner.uid] += amountWonByThisWinner + winner.bet; // Add winnings and get own bet back
                // The initial chipChanges[winner.uid] was -winner.bet. So this becomes +amountWonByThisWinner.
                // Let's re-evaluate: chipChanges[winner.uid] = -winner.bet (initial debit)
                // chipChanges[winner.uid] was initialised to -winner.bet (total bet for hand)
                // shareForThisWinner is the total value of this pot slice the winner gets.
                // This includes their own contribution to this slice and what they take from others for this slice.
                chipChanges[winner.uid] += shareForThisWinner;

                const playerWinningsEntry = playersInHand.find(p => p.uid === winner.uid);
                if(playerWinningsEntry) playerWinningsEntry.winnings = shareForThisWinner; // Total value they won from this pot slice

                // totalPot was already reduced by amounts taken from OTHERS inside the contributor loop.
                // Now, we need to account for the winner's own contribution to this share being "removed" from the pot.
                let winnerOwnContributionToThisShare = shareForThisWinner - amountWonByThisWinner;
                totalPot -= winnerOwnContributionToThisShare;


                console.log(`Player ${winner.name} (Rank ${winner.rank}) awarded total slice of ${shareForThisWinner} (of which ${amountWonByThisWinner} was from others). ChipChange now ${chipChanges[winner.uid]}`);
                console.log(`Total pot remaining: ${totalPot}`);
                console.log(`Updated Pot Contributions:`, JSON.parse(JSON.stringify(potContributions)));
                console.log(`Updated Chip Changes:`, JSON.parse(JSON.stringify(chipChanges)));

            }

            // --- Phase 3: Return un-won portions of bets (Chip Conservation) ---
            potContributions.forEach(pc => {
                if (pc.stillInPlay > 0) {
                    // This amount was bet but not won by anyone. Return to contributor.
                    chipChanges[pc.uid] += pc.stillInPlay;
                    pc.returned = pc.stillInPlay;
                    totalPot -= pc.stillInPlay; // Should bring totalPot to 0 if all logic is correct
                    pc.stillInPlay = 0;
                    console.log(`Player UID ${pc.uid} gets ${pc.returned} chips back (unwon portion of bet). Final chipChange: ${chipChanges[pc.uid]}`);
                }
            });

            if (totalPot > 0.5) { // Using 0.5 to handle potential small floating point residuals
                console.warn(`Warning: Pot has ${totalPot} remaining after distribution and returns. This might be due to rounding or logic gap. Attempting to give to highest winner or log.`);
                // For simplicity, this small amount might be lost or could be given to the first place winner if one exists.
                const firstPlaceWinner = rankedWinners.find(p => p.rank === 1);
                if (firstPlaceWinner) {
                    chipChanges[firstPlaceWinner.uid] += totalPot;
                    console.log(`Awarded lingering ${totalPot} from pot to ${firstPlaceWinner.name}.`);
                    totalPot = 0;
                } else {
                    console.error(`Lingering pot of ${totalPot} could not be distributed.`);
                }
            }


            console.log("--- Phase 2 & 3 Complete ---");
            console.log("Final Chip Changes to be applied:", chipChanges);
            console.log("Final Pot Contributions state:", potContributions);


            // Update Firestore
            showMessage("Updating chip counts in Firestore...", "info");
            const updates = [];
            for (const playerId in chipChanges) {
                const change = chipChanges[playerId];
                const playerProfileRef = doc(userProfilesCollectionRef, playerId);

                // It's safer to fetch the current chip count before updating,
                // but for this exercise, we'll assume `allFirebaseUsersData` is reasonably fresh.
                // A transaction would be ideal here.
                const profile = allFirebaseUsersData.find(p => p.uid === playerId);
                if (profile) {
                    const newChipCount = (profile.chip_count || 0) + change;
                    updates.push(updateDoc(playerProfileRef, { chip_count: newChipCount }));
                    console.log(`Updating ${profile.displayName}'s chips from ${profile.chip_count} by ${change} to ${newChipCount}`);
                } else {
                    console.error(`Could not find profile for player UID ${playerId} to update chips.`);
                }
            }

            try {
                await Promise.all(updates);
                showMessage("Chip counts updated successfully!", "success");

                // Finally, reset the room
                await adminRoomReset(roomId); // This will set bets to 0 and statuses to pending
            } catch (error) {
                console.error("Error updating chip counts or resetting room:", error);
                showMessage(`Failed to update chip counts: ${error.message}`, "error");
            }

            toggleUpdateChipsPanel(roomId, false); // Hide panel after submission
        }

    </script>
</body>
</html>