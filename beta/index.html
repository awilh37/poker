<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WPS 3.1</title>
    
    <!-- 
      ============================================================
      =                 NEW CUSTOM STYLESHEET START                =
      ============================================================
      
      This stylesheet replaces Tailwind completely.
      It defines all styles for a full-screen layout,
      buttons, panels, tables, and the game room.
    -->
    <style>
        /* --- Imports & Base --- */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');

        html {
            box-sizing: border-box;
        }
        *, *:before, *:after {
            box-sizing: inherit;
        }

        body {
            font-family: 'Inter', sans-serif;
            /* A subtle gradient background for a more modern feel */
            background-color: #f7faff;
            background-image: linear-gradient(170deg, #f7faff 0%, #e6f0ff 100%);
            min-height: 100vh;
            margin: 0;
            color: #334155; /* Default text color (slate-700) */
        }

        /* --- Utility --- */
        .hidden {
            display: none !important;
        }

        /* --- Layout --- */
        #mainContainer {
            width: 100%;
            max-width: 1280px; /* Large, but not infinite */
            margin: 0 auto; /* Center the content */
            padding: 2rem 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem; /* Replaces all the separate margins */
        }

        /* --- Typography --- */
        h2 {
            font-size: 1.875rem; /* 30px */
            font-weight: 800;
            color: #1f2937;
            margin: 0 0 1rem 0;
            text-align: center;
        }
        h3 {
            font-size: 1.5rem; /* 24px */
            font-weight: 700;
            color: #1f2937;
            margin: 0 0 1rem 0;
            text-align: center;
        }
        h4 {
            font-size: 1.25rem; /* 20px */
            font-weight: 600;
            color: #111827;
            margin: 0 0 0.75rem 0;
            text-align: center;
        }
        h5 {
            font-size: 1rem; /* 16px */
            font-weight: 600;
            color: #374151;
            margin: 0 0 0.5rem 0;
        }
        p {
            font-size: 1rem;
            color: #4b5563;
            line-height: 1.6;
            margin: 0 0 1rem 0;
            text-align: center;
        }
        p.text-left { text-align: left; }
        p.small { font-size: 0.875rem; }
        
        .strong-note {
            font-weight: 600;
            color: #dc3545; /* Red */
        }
        
        @media (min-width: 768px) {
            h2 { font-size: 2.25rem; } /* 36px */
            h3 { font-size: 1.875rem; } /* 30px */
        }

        /* --- Buttons --- */
        .btn {
            width: 100%;
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            text-decoration: none;
            color: white;
        }
        .btn:hover {
            filter: brightness(1.1);
        }
        .btn:active {
            transform: scale(0.98);
        }
        .btn:focus-visible {
            outline: none;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.4);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: brightness(1);
            transform: scale(1);
        }

        .btn svg {
            width: 1.25rem;
            height: 1.25rem;
        }

        /* Button Colors */
        .btn-google  { background-color: #db4437; }
        .btn-logout  { background-color: #dc3545; }
        .btn-green   { background-color: #28a745; }
        .btn-blue    { background-color: #007bff; }
        .btn-purple  { background-color: #6f42c1; }
        .btn-orange  { background-color: #fd7e14; }
        .btn-gray    { background-color: #6c757d; }
        .btn-indigo  { background-color: #6610f2; }
        .btn-red     { background-color: #b91c1c; }
        .btn-yellow  { background-color: #ffc107; color: #212529; } /* For All-In */
        .btn-teal    { background-color: #20c997; }

        /* Button Sizing */
        .btn-half {
            width: 50%;
            margin-left: auto;
            margin-right: auto;
        }
        .btn-sm {
            padding: 0.25rem 0.5rem;
            font-size: 0.875rem;
            border-radius: 0.375rem;
        }
        .btn-group {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
        }
        .btn-group .btn {
            width: auto;
            flex-grow: 1;
        }

        /* --- Loading Indicator --- */
        #loadingIndicator {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            color: #4b5563;
            font-size: 1rem;
        }
        #loadingIndicator svg {
            animation: spin 1s linear infinite;
            margin-right: 0.75rem;
            width: 1.25rem;
            height: 1.25rem;
            color: #007bff;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* --- Message Box --- */
        .message-box {
            width: 100%;
            max-width: 48rem;
            padding: 1rem;
            border-radius: 0.75rem;
            font-weight: 500;
            border-width: 1px;
            border-style: solid;
            text-align: center;
        }
        .message-box.error   { background-color: #fff1f2; color: #be123c; border-color: #fda4af; }
        .message-box.success { background-color: #f0fdf4; color: #15803d; border-color: #a7f3d0; }
        .message-box.info    { background-color: #f0f9ff; color: #0369a1; border-color: #bae6fd; }

        /* --- Forms (Inputs, Selects) --- */
        input[type="text"],
        input[type="number"],
        select {
            width: 100%;
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid #cbd5e1;
            background-color: #fff;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            color: #334155;
        }
        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
        }
        label {
            display: block;
            font-weight: 500;
            color: #334155;
            margin-bottom: 0.5rem;
            text-align: left;
        }
        .form-group {
            margin-bottom: 1rem;
            width: 100%;
        }
        .form-group-inline {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        @media (min-width: 640px) {
            .form-group-inline {
                flex-direction: row;
                align-items: flex-end;
            }
            .form-group-inline > .form-group {
                flex-grow: 1;
                margin-bottom: 0;
            }
            .form-group-inline > .btn {
                width: auto;
                flex-shrink: 0;
            }
        }

        /* --- Panels --- */
        /* This is the main white card style for most content */
        .panel {
            width: 100%;
            max-width: 48rem;
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 1.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem; /* Space between elements inside panel */
        }
        
        /* This is for nested panels, like in the Admin area */
        .content-panel {
            width: 100%;
            padding: 1.5rem;
            background-color: #f8fafc;
            border-radius: 1rem;
            border: 1px solid #e2e8f0;
            text-align: center;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.02);
        }
        .content-panel > *:last-child {
            margin-bottom: 0;
        }

        /* Assign panel style to all top-level views */
        #loginButtonsContainer,
        #mainActionButtons,
        #adminPanel,
        #userManagementPanel,
        #gameRoomManagementPanel,
        #playerJoinRoomPanel,
        #accountManagementPanel,
        #userDirectoryPanel,
        #investmentsPanel {
            /* All these IDs now share the .panel styling */
            /* (This is handled by adding class="panel" in the HTML) */
        }

        /* Specific Panel Overrides */
        #gameRoomViewPanel {
            width: 100%;
            max-width: 64rem; /* lg:max-w-4xl */
            background-color: #1f2937; /* gray-800 */
            padding: 1.5rem;
            border-radius: 1.5rem;
            border: 1px solid #4b5563;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        #gameRoomViewPanel h3, #gameRoomViewPanel h4, #gameRoomViewPanel h5, #gameRoomViewPanel p, #gameRoomViewPanel label {
            color: #f3f4f6;
            text-align: left;
        }
        #gameRoomViewPanel h3 { text-align: left; }
        #gameRoomViewPanel h4 { text-align: left; }
        #gameRoomViewPanel .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 0; /* Handled by gap */
        }
        #gameRoomViewPanel .panel-header h3 {
            margin: 0;
        }
        #gameRoomViewPanel .panel-header .btn {
            width: auto;
        }

        /* --- Tables --- */
        .table-container {
            width: 100%;
            overflow-x: auto; /* For mobile */
        }
        .user-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1.5rem;
            font-size: 0.875rem;
        }
        .user-table th, .user-table td {
            border: 1px solid #e2e8f0;
            padding: 0.75rem;
            text-align: left;
            vertical-align: middle;
        }
        .user-table th {
            background-color: #f1f5f9;
            color: #0284c7;
            font-weight: 600;
        }
        .user-table tr:nth-child(even) { background-color: #ffffff; }
        .user-table tr:nth-child(odd)  { background-color: #f8fafc; }
        .user-table select, .user-table input {
            width: 100%;
            min-width: 80px; /* Stop them from collapsing */
            padding: 0.5rem;
            font-size: 0.875rem;
        }
        .user-table .btn {
            width: auto; /* Buttons in tables aren't full-width */
        }

        /* --- Game Room Specific --- */
        #roomPlayersListContainer {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.75rem;
            max-height: 20rem; /* max-h-72 */
            overflow-y: auto;
            padding: 0.5rem;
            background-color: rgba(0,0,0,0.2);
            border-radius: 0.5rem;
        }
        @media (min-width: 640px) { /* sm */
            #roomPlayersListContainer { grid-template-columns: repeat(2, 1fr); }
        }
        @media (min-width: 1024px) { /* lg */
            #roomPlayersListContainer { grid-template-columns: repeat(3, 1fr); }
        }

        .player-card {
            padding: 0.75rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: 1px solid transparent;
            transition: all 0.2s ease-in-out;
            color: #ffffff;
            position: relative;
        }
        .player-card-ready    { background-color: #047857; border-color: #06b6d4; }
        .player-card-pending  { background-color: #ca8a04; border-color: #facc15; }
        .player-card-folded   { background-color: #b91c1c; border-color: #f87171; }
        .player-card-all-in   { background-color: #7e22ce; border-color: #c084fc; }
        .player-card-default  { background-color: #374151; border-color: #6b7280; }
        .player-card p { color: #ffffff; margin: 0; }
        .player-card .player-name { font-weight: 600; font-size: 1.125rem; }
        .player-card .player-chips { font-size: 0.875rem; color: #d1d5db; }
        .player-card .player-status { font-size: 0.875rem; font-weight: 500; margin-top: 0.25rem; }
        .player-card .player-bet { font-size: 0.75rem; color: #9ca3af; }

        /* Admin Menu on Player Card */
        .player-card .admin-menu-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: none;
            border: none;
            color: #d1d5db;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 99px;
            line-height: 1;
            font-size: 1.25rem;
        }
        .player-card .admin-menu-btn:hover { color: #fff; background-color: rgba(255,255,255,0.1); }
        .player-card .admin-menu-dropdown {
            position: absolute;
            top: 2rem;
            right: 0.5rem;
            background-color: #4b5563; /* gray-600 */
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            z-index: 10;
            min-width: 150px;
            overflow: hidden;
        }
        .player-card .admin-menu-dropdown button {
            display: block;
            width: 100%;
            text-align: left;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            color: white;
            background: none;
            border: none;
            cursor: pointer;
        }
        .player-card .admin-menu-dropdown button:hover { background-color: #6b7280; }
        .player-card .admin-menu-dropdown button:disabled { color: #9ca3af; background-color: transparent; cursor: not-allowed; }

        /* Game Room Input Area */
        .betting-area {
            padding: 1rem;
            border: 1px solid #4b5563;
            border-radius: 0.5rem;
            background-color: #374151; /* gray-700 */
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        #playerBetInput {
            background-color: #374151;
            border-color: #4b5563;
            color: #ffffff;
        }
        #playerBetInput:focus {
             background-color: #4b5563;
             border-color: #007bff;
        }
        #playerChipCountForBet {
            color: #9ca3af;
            font-size: 0.875rem;
            margin-top: 0.25rem;
            text-align: left;
        }

        #gameStatsContainer {
            padding: 1rem;
            border: 1px solid #4b5563;
            border-radius: 0.5rem;
            background-color: #374151; /* gray-700 */
        }
        #gameStatsContent ul {
            list-style-type: disc;
            list-style-position: inside;
            padding-left: 0;
            margin: 0;
        }
        #gameStatsContent li {
            font-size: 0.875rem;
            color: #d1d5db;
        }
        #adminGameControls {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #4b5563;
        }
        #updateChipsPanel {
            padding: 1rem;
            margin: 1rem 0;
            border: 1px solid #4b5563;
            border-radius: 0.5rem;
            background-color: #374151; /* gray-700 */
        }
        #updateChipsPlayerList {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-bottom: 1rem;
            max-height: 15rem;
            overflow-y: auto;
        }
        .chip-update-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background-color: #4b5563;
            border-radius: 0.375rem;
        }
        .chip-update-row span { color: #f3f4f6; }
        .chip-update-row select { width: auto; background-color: #374151; color: white; border-color: #6b7280; }
        .chip-update-controls {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
        }
        .chip-update-controls .btn { width: auto; }

        /* --- Account Management Panel --- */
        #accountManagementPanel {
            align-items: center;
        }
        #userProfilePic {
            width: 8rem; /* w-32 */
            height: 8rem; /* h-32 */
            border-radius: 9999px; /* rounded-full */
            border: 4px solid #007bff;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        #currentUserName {
            font-size: 1.5rem;
            font-weight: 600;
            color: #1f2937;
            margin: 0;
        }
        #currentUserUsername {
            font-size: 1rem;
            color: #4b5563;
            margin: 0;
        }
        #currentUserProvider {
            font-size: 0.875rem;
            color: #6b7280;
            margin: 0;
        }
        .account-actions {
            width: 100%;
            border-top: 1px solid #e5e7eb;
            padding-top: 1rem;
            margin-top: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        /* --- List Containers (for rooms) --- */
        .list-container {
            width: 100%;
            max-height: 24rem;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            padding: 0.5rem;
            border-radius: 0.5rem;
            background-color: #ffffff;
        }
        .list-item {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-start;
            padding: 1rem;
            background-color: #f8fafc;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }
        .list-item:not(:last-child) {
            margin-bottom: 0.75rem;
        }
        .list-item-info .name {
            font-weight: 600;
            color: #1e40af;
            font-size: 1.125rem;
        }
        .list-item-info .details {
            font-size: 0.875rem;
            color: #6b7280;
        }
        .list-item-actions {
            margin-top: 0.75rem;
            width: 100%;
            display: flex;
            gap: 0.5rem;
        }
        .list-item-actions .btn {
            width: auto;
        }
        @media (min-width: 640px) {
            .list-item {
                flex-direction: row;
                align-items: center;
            }
            .list-item-actions {
                margin-top: 0;
                width: auto;
            }
        }


        /* --- Popups / Modals --- */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(107, 114, 128, 0.5); /* bg-gray-600 bg-opacity-50 */
            overflow-y: auto;
            width: 100%;
            height: 100%;
            z-index: 40;
            display: flex; /* Use flex to center */
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        .modal-content {
            position: relative;
            /* top: 5rem; Removed, flex centering is better */
            margin: 0 auto;
            padding: 1.5rem; /* p-5 */
            border: 1px solid #e5e7eb;
            width: 100%;
            max-width: 24rem; /* w-96 */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border-radius: 0.375rem; /* rounded-md */
            background-color: white;
            text-align: center;
        }
        .modal-content h3 {
            font-size: 1.125rem; /* text-lg */
            line-height: 1.5rem;
            font-weight: 500;
            color: #111827; /* text-gray-900 */
        }
        #groupPlayerList {
            max-height: 15rem; /* max-h-60 */
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            padding: 0.5rem;
            margin-top: 1rem;
            margin-bottom: 1rem;
        }
        .modal-actions {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 1rem;
        }
    </style>
    <!-- 
      ============================================================
      =                  NEW CUSTOM STYLESHEET END                 =
      ============================================================
    -->

    <!-- ReCAPTCHA stuff -->
    <script src="https://www.google.com/recaptcha/api.js"></script>
    <script>
        function onSubmit(token) {
        document.getElementById("demo-form").submit();
        }
    </script>

    <!-- Note: This button isn't connected in the script, but I've left it. -->
    <button 
        class="g-recaptcha" 
        data-sitekey="6LdLLMIrAAAAABxuLcLCsaPMzLoihwb-Zt8F3A_O" 
        data-callback='onSubmit' 
        data-action='submit'>
    </button>

</head>

<body> <!-- Removed Tailwind classes -->

    <!-- 
      ============================================================
      =                 MAIN CONTAINER START                 =
      ============================================================
    <div id="mainContainer" class="w-full flex flex-col items-center">
        
        <!-- Main Application Title -->
        <h2 class="main-title">WPS 3.1</h2>

        <!-- Loading Indicator: Shown when app is initializing -->
        <div id="loadingIndicator" class="hidden loading-indicator">
            <svg class="animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <span>Initializing Firebase...</span>
        </div>

        <!-- Login Buttons: Shown when user is logged out -->
        <!-- UPDATED: Added class="panel" to match the new design system -->
        <div id="loginButtonsContainer" class="panel hidden">
            <!-- Google Login Button -->
            <!-- UPDATED: Changed classes from "btn-nav btn-google" to "btn btn-google" to match new CSS -->
            <button
                type="button"
                id="googleLoginButton"
                class="btn btn-google"
            >
                <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12.0001 4.5V7.5L17.2501 7.5C17.0279 8.65312 16.3989 9.69736 15.4883 10.4514C14.5776 11.2054 13.4357 11.6212 12.2501 11.6212C9.40006 11.6212 6.99999 9.40871 6.99999 6.55871C6.99999 3.70871 9.40006 1.49621 12.2501 1.49621C13.6874 1.49621 14.9754 2.05267 15.9388 2.92305L18.1565 0.705359C16.5912 -0.80332 14.4754 -1.54716e-07 12.2501 -1.54716e-07C7.26627 -1.54716e-07 3.00006 4.26627 3.00006 9.25006C3.00006 14.2338 7.26627 18.5 12.2501 18.5C14.6738 18.5 16.6346 17.6534 18.0626 16.1436C19.5398 14.6338 19.9999 12.3501 19.9999 9.94006C19.9999 9.25006 19.9312 8.57506 19.8001 7.92506L12.0001 7.92506V4.5Z" fill="#fff"/>
                </svg>
                Sign In with Google
            </button>
        </div>


        <!-- Message Box: Shows all success/error/info messages -->
        <div id="messageBox" class="message-box hidden"></div>

        <!-- 
          ============================================================
          =                LOGGED-IN BUTTONS START               =
          ============================================================
          
          This is the main navigation hub for logged-in users.
          It's now styled as its own panel.
        -->
        <div id="mainActionButtons" class="panel hidden">
            <button id="logoutButton" class="btn btn-logout">Logout</button>
            <button id="viewUserDirectoryButton" class="btn btn-green">View User Directory</button>
            <button id="openAccountManagementButton" class="btn btn-blue">Manage Account</button>
            <button id="openAdminPanelButton" class="btn btn-purple hidden">Admin Panel</button>
            <button id="joinGameButton" class="btn btn-orange">Join a Game</button>
        </div>
        <!-- =================== LOGGED-IN BUTTONS END =================== -->


        <!-- 
          ============================================================
          =                   ADMIN PANEL START                  =
          ============================================================
          
          This panel is shown when an Admin clicks the "Admin Panel" button.
          It's styled using class="panel".
        -->
        <div id="adminPanel" class="panel hidden">
            <h3>Admin Panel</h3>
            <p>
                Welcome, Administrator! From here, you can manage users, game data, and other aspects of the WPS system.
                <br>
                <strong class="strong-note">Note: User management will only show users who have logged in via Firebase Auth.</strong>
            </p>
            <button id="manageUsersButton" class="btn btn-indigo">Manage Users</button>
            <button id="manageGameRoomsButton" class="btn btn-green">Manage Game Rooms</button>
            <button id="closeAdminPanelButton" class="btn btn-gray btn-half">Close Admin Panel</button>
        </div>
        <!-- =================== ADMIN PANEL END =================== -->


        <!-- 
          ============================================================
          =                USER MANAGEMENT PANEL START             =
          ============================================================
        -->
        <div id="userManagementPanel" class="panel hidden">
            <h3>User Management</h3>
            <p>
                Assign roles to users who have logged in.
                <br>
                <strong class="strong-note">Important: Role management is client-side for demonstration.</strong>
            </p>
            
            <!-- Table container for horizontal scrolling on small screens -->
            <div class="table-container">
                <table class="user-table">
                    <thead>
                        <tr>
                            <th>Display Name</th>
                            <th>Chip Count</th>
                            <th>Role</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="userRolesTableBody">
                        <tr><td colspan="4" class="text-center text-gray-500">Loading users...</td></tr>
                    </tbody>
                </table>
            </div>
            
            <!-- Panel action buttons -->
            <div class="btn-group">
                <button id="saveUserRolesButton" class="btn btn-blue">Save Changes</button>
                <button id="hideUserManagementButton" class="btn btn-gray">Hide Panel</button>
            </div>
            
            <!-- Bulk User Actions -->
            <div class="content-panel"> <!-- Nested panel for emphasis -->
                <h4>Bulk User Actions</h4>
                <div class="btn-group">
                    <button id="setAllPlayerChipsButton" class="btn btn-orange">Set All Player Chips</button>
                    <button id="forceLogoutAllUsersButton" class="btn btn-red">Force Logout All Users (Except Self)</button>
                </div>
            </div>
        </div>
        <!-- =================== USER MANAGEMENT PANEL END =================== -->


        <!-- 
          ============================================================
          =              GAME ROOM MANAGEMENT PANEL START            =
          ============================================================
        -->
        <div id="gameRoomManagementPanel" class="panel hidden">
            <h3>Manage Game Rooms</h3>

            <!-- Create New Game Room Section -->
            <div class="content-panel">
                <h4>Create New Game Room</h4>
                <div class="form-group-inline">
                    <div class="form-group">
                        <label for="newRoomNameInput">Room Name:</label>
                        <input type="text" id="newRoomNameInput" placeholder="e.g., Main Event Table 1">
                    </div>
                    <button id="createGameRoomButton" class="btn btn-green">Create Room</button>
                </div>
            </div>

            <!-- Existing Game Rooms List Section -->
            <div class="content-panel">
                <h4>Existing Rooms</h4>
                <div id="gameRoomsListContainer" class="list-container">
                    <p>Loading rooms...</p>
                    <!-- Game rooms will be listed here by JavaScript -->
                </div>
            </div>

            <!-- Bulk Room Action -->
            <div class="content-panel">
                <button id="deleteAllGameRoomsButton" class="btn btn-red">Delete All Game Rooms (USE WITH CAUTION)</button>
            </div>

            <!-- Close button -->
            <button id="closeGameRoomManagementPanelButton" class="btn btn-gray btn-half">
                Close & Return to Admin Panel
            </button>
        </div>
        <!-- =================== GAME ROOM MANAGEMENT PANEL END =================== -->


        <!-- 
          ============================================================
          =                PLAYER JOIN ROOM PANEL START              =
          ============================================================
        -->
        <div id="playerJoinRoomPanel" class="panel hidden">
            <h3>Available Game Rooms</h3>
            
            <!-- List of available rooms -->
            <div id="availableRoomsListContainer" class="list-container">
                <p>Loading available rooms...</p>
                <!-- Available game rooms will be listed here by JavaScript -->
            </div>

            <!-- Close button -->
            <button id="closePlayerJoinRoomPanelButton" class="btn btn-gray btn-half">Close</button>
        </div>
        <!-- =================== PLAYER JOIN ROOM PANEL END =================== -->


        <!-- 
          ============================================================
          =                  GAME ROOM VIEW PANEL START              =
          ============================================================
          
          This is the main "in-game" view. It uses a special ID
          for the dark theme.
        -->
        <div id="gameRoomViewPanel" class="hidden"> <!-- Note: No .panel class -->
            <!-- Room Header -->
            <div class="panel-header">
                <h3 id="gameRoomViewName">Room Name Placeholder</h3>
                <button id="closeGameRoomViewButton" class="btn btn-gray">
                    Return to Lobby
                </button>
            </div>

            <!-- Player List Area -->
            <div>
                <h4>Players in Room</h4>
                <div id="roomPlayersListContainer">
                    <p>Waiting for players...</p>
                </div>
            </div>
            
            <!-- Game Stats Area -->
            <div id="gameStatsContainer">
                <h4>Game Stats</h4>
                <div id="gameStatsContent">
                    <p>Loading game stats...</p>
                </div>
                <!-- Admin Game Controls (hidden by default) -->
                <div id="adminGameControls" class="hidden">
                    <h5>Admin Controls</h5>
                    <div class="btn-group">
                        <button id="adminRoomResetButton" class="btn btn-yellow">Room Reset</button>
                        <button id="adminUpdateChipsButton" class="btn btn-teal">Update Chips</button>
                    </div>
                </div>
            </div>

            <!-- Update Chips Panel (Admin Only, Initially Hidden) -->
            <div id="updateChipsPanel" class="hidden">
                <h4>Update Player Chips After Hand</h4>
                <div id="updateChipsPlayerList" class="form-group">
                    <p>Loading players...</p>
                </div>
                <div class="chip-update-controls">
                    <button id="cancelChipUpdate" class="btn btn-gray">Cancel</button>
                    <button id="submitChipUpdate" class="btn btn-green">Submit Chip Updates</button>
                </div>
            </div>

            <!-- Player Bet Input Section -->
            <div class="betting-area">
                <h4>Your Bet</h4>
                <div class="form-group-inline">
                    <div class="form-group">
                        <label for="playerBetInput">Enter Amount:</label>
                        <input type="number" id="playerBetInput" placeholder="0" min="0">
                        <p id="playerChipCountForBet" class="small">Your chips: N/A</p>
                    </div>
                </div>
                <!-- Player Action Buttons -->
                <div class="btn-group">
                    <button id="placeBetButton" class="btn btn-green">Place Bet</button>
                    <button id="callButton" class="btn btn-blue">Call</button>
                    <button id="foldButton" class="btn btn-red">Fold</button>
                    <button id="allInButton" class="btn btn-yellow">All-In</button>
                </div>
            </div>

            <!-- Leave Room Button -->
            <button id="leaveCurrentGameRoomButton" class="btn btn-logout btn-half">
                Leave Room
            </button>
        </div>
        <!-- =================== GAME ROOM VIEW PANEL END =================== -->


        <!-- 
          ============================================================
          =                ACCOUNT MANAGEMENT PANEL START            =
          ============================================================
        -->
        <div id="accountManagementPanel" class="panel hidden">
            <h3>Account Management</h3>
            
            <img id="userProfilePic" src="" alt="Profile Picture">
            <p id="currentUserName"></p>
            <p id="currentUserUsername"></p>
            <p id="currentUserProvider"></p>

            <!-- Account Action Buttons -->
            <div class="account-actions">
                <button type="button" id="linkGoogleAccountButton" class="btn btn-blue">
                    <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12.0001 4.5V7.5L17.2501 7.5C17.0279 8.65312 16.3989 9.69736 15.4883 10.4514C14.5776 11.2054 13.4357 11.6212 12.2501 11.6212C9.40006 11.6212 6.99999 9.40871 6.99999 6.55871C6.99999 3.70871 9.40006 1.49621 12.2501 1.49621C13.6874 1.49621 14.9754 2.05267 15.9388 2.92305L18.1565 0.705359C16.5912 -0.80332 14.4754 -1.54716e-07 12.2501 -1.54716e-07C7.26627 -1.54716e-07 3.00006 4.26627 3.00006 9.25006C3.00006 14.2338 7.26627 18.5 12.2501 18.5C14.6738 18.5 16.6346 17.6534 18.0626 16.1436C19.5398 14.6338 19.9999 12.3501 19.9999 9.94006C19.9999 9.25006 19.9312 8.57506 19.8001 7.92506L12.0001 7.92506V4.5Z" fill="#fff"/>
                    </svg>
                    Link with Google
                </button>
                <button class="btn btn-gray" disabled>Change Password (Placeholder)</button>
                <button class="btn btn-gray" disabled>Update Profile (Placeholder)</button>
            </div>
            
            <!-- Close Button -->
            <button id="hideAccountManagementButton" class="btn btn-gray btn-half">Close</button>
        </div>
        <!-- =================== ACCOUNT MANAGEMENT PANEL END =================== -->


        <!-- 
          ============================================================
          =                 USER DIRECTORY PANEL START             =
          ============================================================
        -->
        <div id="userDirectoryPanel" class="panel hidden">
            <h3>User Directory</h3>
            <!-- Table container for horizontal scrolling -->
            <div class="table-container">
                <table class="user-table">
                    <thead>
                        <tr>
                            <th>Display Name</th>
                            <th>Role</th>
                            <th>Chip Count</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="userDirectoryTableBody">
                        <tr><td colspan="4">Loading...</td></tr>
        <!-- Logout Button -->
        <button
            id="logoutButton"
            class="hidden btn-nav btn-red"
        >
            Logout
        </button>

        <!-- View User Directory Button -->
        <button
            id="viewUserDirectoryButton"
            class="hidden btn-nav btn-green"
        >
            View User Directory
        </button>

        <!-- Manage Account Button -->
        <button
            id="openAccountManagementButton"
            class="hidden btn-nav btn-blue"
        >
            Manage Account
        </button>

        <!-- Admin Panel Button (Admin only) -->
        <button
            id="openAdminPanelButton"
            class="hidden btn-nav btn-purple"
        >
            Admin Panel
        </button>

        <!-- Join a Game Button -->
        <button
            id="joinGameButton"
            class="hidden btn-nav btn-orange"
        >
            Join a Game
        </button>
        
        <!-- 
          ============================================================
          =                GROUP CHAT MODAL START (Hidden)         =
          ============================================================
          
          A popup modal for creating new group chats.
        -->
        <div id="createGroupChatModal" class="modal-overlay hidden">
            <div class="modal-content">
                <h3>Create Group Chat</h3>
                <div class="form-group">
                    <input type="text" id="groupNameInput" placeholder="Group Name">
                </div>
                <div id="groupPlayerList">
                    <!-- Player list for group selection will be rendered here -->
                </div>
                <div class="modal-actions">
                    <button id="createGroupButton" class="btn btn-green">Create Group</button>
                    <button id="cancelGroupButton" class="btn btn-gray">Cancel</button>
                </div>
            </div>
        </div>
        <!-- =================== GROUP CHAT MODAL END =================== -->

    </div> <!-- End of #mainContainer -->
    <!-- =================== MAIN CONTAINER END =================== -->

    <!-- 
      ============================================================
      =                    JAVASCRIPT START                    =
      ============================================================
      
      All application logic is contained within this script tag.
      (No changes were made to the JavaScript logic)
    -->
    <script type="module">
        // Import Firebase SDKs
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-analytics.js";
        import { getAuth, signInWithCustomToken, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, linkWithPopup, signOut } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, addDoc, onSnapshot, collection, query, getDocs, deleteDoc, serverTimestamp, orderBy, updateDoc, arrayUnion, arrayRemove, deleteField, writeBatch } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";

        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyBefsHEBuiRyJ31NzF885ac3ugCefzngTU",
            authDomain: "wps-3-be723.firebaseapp.com",
            projectId: "wps-3-be723",
            storageBucket: "wps-3-be723.firebasestorage.app",
            messagingSenderId: "420146617877",
            appId: "1:420146617877:web:ea2e06a690732da76fb81c",
            measurementId: "G-H0Z4C2185Y"
        };

        const appId = typeof __app_id !== 'undefined' ? __app_id : firebaseConfig.projectId;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Initialize Firebase
        const firebaseApp = initializeApp(firebaseConfig);
        const analytics = getAnalytics(firebaseApp);
        const db = getFirestore(firebaseApp, '(default)'); // Using named database '(default)'
        const auth = getAuth(firebaseApp);
        const googleProvider = new GoogleAuthProvider();


        // Track Firebase authentication readiness and data loading state
        let firebaseAuthReady = false;
        let isLoggingOut = false;
        let dataLoadedAndListenersSetup = false;
        let unsubscribeOwnActiveSessionListener = null; // For self-logout listener


        // --- Super Admin UID (DO NOT TOUCH THIS!) ---
        // This UID will be used to identify the initial administrator account.
        const SUPER_ADMIN_UID = "Qr3XI0uNYrZ3AECim6XtRvp12MJ2";


        // --- DOM Elements ---
        // We get references to all the HTML elements we need to interact with.
        
        // Main elements
        const loginButtonsContainer = document.getElementById('loginButtonsContainer');
        const googleLoginButton = document.getElementById('googleLoginButton');
        const messageBox = document.getElementById('messageBox');
        const loadingIndicator = document.getElementById('loadingIndicator');

        // Main action buttons (New container)
        const mainActionButtons = document.getElementById('mainActionButtons');
        const logoutButton = document.getElementById('logoutButton');
        const viewUserDirectoryButton = document.getElementById('viewUserDirectoryButton');
        const openAccountManagementButton = document.getElementById('openAccountManagementButton');
        const openAdminPanelButton = document.getElementById('openAdminPanelButton');
        const joinGameButton = document.getElementById('joinGameButton');

        // Admin Panel
        const adminPanel = document.getElementById('adminPanel');
        const manageUsersButton = document.getElementById('manageUsersButton');
        const closeAdminPanelButton = document.getElementById('closeAdminPanelButton');

        // User Management Panel
        const userManagementPanel = document.getElementById('userManagementPanel');
        const userRolesTableBody = document.getElementById('userRolesTableBody');
        const saveUserRolesButton = document.getElementById('saveUserRolesButton');
        const hideUserManagementButton = document.getElementById('hideUserManagementButton');

        // Account Management Panel
        const accountManagementPanel = document.getElementById('accountManagementPanel');
        const userProfilePic = document.getElementById('userProfilePic');
        const currentUserName = document.getElementById('currentUserName');
        const currentUserUsername = document.getElementById('currentUserUsername');
        const currentUserProvider = document.getElementById('currentUserProvider');
        const linkGoogleAccountButton = document.getElementById('linkGoogleAccountButton');
        const hideAccountManagementButton = document.getElementById('hideAccountManagementButton');

        // User Directory Panel
        const userDirectoryPanel = document.getElementById('userDirectoryPanel'); 
        const userDirectoryTableBody = document.getElementById('userDirectoryTableBody'); 
        const hideUserDirectoryPanelButton = document.getElementById('hideUserDirectoryPanelButton');
        
        // Game Room Management (Admin)
        const manageGameRoomsButton = document.getElementById('manageGameRoomsButton');
        const gameRoomManagementPanel = document.getElementById('gameRoomManagementPanel');
        const newRoomNameInput = document.getElementById('newRoomNameInput');
        const createGameRoomButton = document.getElementById('createGameRoomButton');
        const gameRoomsListContainer = document.getElementById('gameRoomsListContainer');
        const closeGameRoomManagementPanelButton = document.getElementById('closeGameRoomManagementPanelButton');

        // Join Game (Player)
        const playerJoinRoomPanel = document.getElementById('playerJoinRoomPanel');
        const availableRoomsListContainer = document.getElementById('availableRoomsListContainer');
        const closePlayerJoinRoomPanelButton = document.getElementById('closePlayerJoinRoomPanelButton');

        // Game Room View (In-Game)
        const gameRoomViewPanel = document.getElementById('gameRoomViewPanel');
        const gameRoomViewName = document.getElementById('gameRoomViewName');
        const roomPlayersListContainer = document.getElementById('roomPlayersListContainer');
        const leaveCurrentGameRoomButton = document.getElementById('leaveCurrentGameRoomButton');
        const closeGameRoomViewButton = document.getElementById('closeGameRoomViewButton');
        const playerBetInput = document.getElementById('playerBetInput');
        const playerChipCountForBet = document.getElementById('playerChipCountForBet');
        const placeBetButton = document.getElementById('placeBetButton');
        const callButton = document.getElementById('callButton');
        const foldButton = document.getElementById('foldButton');
        const allInButton = document.getElementById('allInButton');

        // Admin Game Controls (In-Game)
        const adminGameControls = document.getElementById('adminGameControls');
        const adminRoomResetButton = document.getElementById('adminRoomResetButton');
        const adminUpdateChipsButton = document.getElementById('adminUpdateChipsButton');

        // Update Chips Panel (Admin In-Game)
        const updateChipsPanel = document.getElementById('updateChipsPanel');
        const updateChipsPlayerList = document.getElementById('updateChipsPlayerList');
        const cancelChipUpdate = document.getElementById('cancelChipUpdate');
        const submitChipUpdate = document.getElementById('submitChipUpdate');

        // Bulk User Action Buttons
        const setAllPlayerChipsButton = document.getElementById('setAllPlayerChipsButton');
        const forceLogoutAllUsersButton = document.getElementById('forceLogoutAllUsersButton');

        // Bulk Game Room Action Button
        const deleteAllGameRoomsButton = document.getElementById('deleteAllGameRoomsButton');

        // Investments Panel Elements (Feature currently hidden)
        const investmentsPanel = document.getElementById('investmentsPanel');
        const closeInvestmentsPanelButton = document.getElementById('closeInvestmentsPanelButton');
        // const sharesTab = document.getElementById('shares-tab');
        // const offersTab = document.getElementById('offers-tab');
        // const sharesContent = document.getElementById('sharesContent');
        // const offersContent = document.getElementById('offersContent');
        // const offerInvestmentForm = document.getElementById('offerInvestmentForm');
        // const investPlayerSelect = document.getElementById('investPlayerSelect');
        // const maxInvestableChips = document.getElementById('maxInvestableChips');
        // const investChipAmount = document.getElementById('investChipAmount');
        // const investPayoutPercent = document.getElementById('investPayoutPercent');
        // const investHandsPayout = document.getElementById('investHandsPayout');
        // const submitInvestmentOfferButton = document.getElementById('submitInvestmentOfferButton');
        // const mySharesListContainer = document.getElementById('mySharesListContainer');
        // const mySharesList = document.getElementById('mySharesList');
        // const incomingOffersListContainer = document.getElementById('incomingOffersListContainer');
        // const incomingOffersList = document.getElementById('incomingOffersList');
        // const myInvestmentsAsInvesteeContainer = document.getElementById('myInvestmentsAsInvesteeContainer');
        // const myInvestmentsAsInvesteeList = document.getElementById('myInvestmentsAsInvesteeList');

        // Messages Panel Elements (Feature currently hidden)
        // (Element variables are commented out as the feature is)

        // Group Chat Modal Elements (Feature currently hidden)
        const createGroupChatModal = document.getElementById('createGroupChatModal');
        const groupNameInput = document.getElementById('groupNameInput');
        const groupPlayerList = document.getElementById('groupPlayerList');
        const createGroupButton = document.getElementById('createGroupButton');
        const cancelGroupButton = document.getElementById('cancelGroupButton');
        // const createGroupChatButton = document.getElementById('createGroupChatButton');

        // --- Global State Variables ---
        // To keep track of data from Firestore in real-time.
        let allFirebaseUsersData = []; // Stores user profiles
        let firestoreUserRoles = {}; // Stores user roles
        let firestoreActiveSessions = []; // Stores active user sessions
        let firestoreGameRooms = []; // Stores game rooms
        let firestoreInvestments = []; // Stores investments
        let firestoreMessages = []; // Stores messages
        let currentJoinedRoomId = null; // Stores the ID of the room the player is in

        // Defined roles for the system
        const ROLES = ['disabled', 'player', 'admin', 'owner'];


        // --- Role Helper Functions ---
        
        /** Gets the current user's role, defaulting to 'player' */
        function getCurrentUserRole(uid) {
            if (!uid) return 'player';
            return firestoreUserRoles[uid]?.role || 'player';
        }

        /** Checks if a user has 'owner' privileges */
        function isOwner(uid) {
            if (!uid) return false;
            // SUPER_ADMIN_UID is always an owner
            return uid === SUPER_ADMIN_UID || getCurrentUserRole(uid) === 'owner';
        }

        /** Checks if a user has 'admin' or 'owner' privileges */
        function hasAdminAccess(uid) {
            if (!uid) return false;
            const role = getCurrentUserRole(uid);
            return uid === SUPER_ADMIN_UID || role === 'owner' || role === 'admin';
        }

        // --- Active Session Listener ---
        
        /** Listens for changes to the user's own session doc (for remote logout) */
        function setupOwnActiveSessionListener(uid) {
            if (unsubscribeOwnActiveSessionListener) {
                console.log("Unsubscribing from previous own active session listener.");
                unsubscribeOwnActiveSessionListener(); 
                unsubscribeOwnActiveSessionListener = null;
            }
            if (!uid) return; 

            const sessionDocRef = doc(activeSessionsCollectionRef, uid);
            console.log(`Setting up listener for own active session: active_sessions/${uid}`);

            unsubscribeOwnActiveSessionListener = onSnapshot(sessionDocRef, (docSnap) => {
                console.log(`Own active session listener event: exists=${docSnap.exists()}`);
                if (!docSnap.exists()) {
                    // Document was deleted
                    console.log("Own active session document deleted.");
                    if (auth.currentUser && auth.currentUser.uid === uid && !isLoggingOut) { 
                        console.log("Current user matches and not logging out. Initiating self-logout.");
                        isLoggingOut = true;
                        showMessage("Your session has been ended remotely. You are now being logged out.", "info");
                        
                        if (unsubscribeOwnActiveSessionListener) {
                            unsubscribeOwnActiveSessionListener();
                            unsubscribeOwnActiveSessionListener = null;
                        }
                        setTimeout(() => handleLogout(), 3000); 
                    }
                }
            }, (error) => {
                console.error(`Error listening to own active session (active_sessions/${uid}):`, error);
            });
        }


        // --- Firestore Collection References ---
        // These point to the specific collections in the database.
        const userRolesCollectionRef = collection(db, `artifacts/${appId}/public/data/user_roles`);
        const activityLogsCollectionRef = collection(db, `artifacts/${appId}/public/data/activity_logs`);
        const userProfilesCollectionRef = collection(db, `artifacts/${appId}/public/data/user_profiles`);
        const activeSessionsCollectionRef = collection(db, `artifacts/${appId}/public/data/active_sessions`);
        const gameRoomsCollectionRef = collection(db, `artifacts/${appId}/public/data/game_rooms`);
        const investmentsCollectionRef = collection(db, `artifacts/${appId}/public/data/investments`);
        const messagesCollectionRef = collection(db, `artifacts/${appId}/public/data/messages`);


        // --- Utility Functions ---

        /** * Hides all panels and shows the specified one.
         * Pass `null` to hide all and show the main logged-in/out buttons.
         */
        function showPanel(panelToShow) {
            const panelList = [
                {el: loginButtonsContainer, name: "loginButtonsContainer"},
                {el: mainActionButtons, name: "mainActionButtons"}, // New main hub
                {el: adminPanel, name: "adminPanel"},
                {el: userManagementPanel, name: "userManagementPanel"},
                {el: accountManagementPanel, name: "accountManagementPanel"},
                {el: userDirectoryPanel, name: "userDirectoryPanel"},
                {el: gameRoomManagementPanel, name: "gameRoomManagementPanel"},
                {el: playerJoinRoomPanel, name: "playerJoinRoomPanel"},
                {el: gameRoomViewPanel, name: "gameRoomViewPanel"},
                {el: investmentsPanel, name: "investmentsPanel"},
                {el: loadingIndicator, name: "loadingIndicator"}
                // {el: messagesPanel, name: "messagesPanel"}, // (Feature hidden)
            ];

            panelList.forEach(item => {
                if (!item.el) {
                    console.warn(`showPanel: DOM element for '${item.name}' is null.`);
                    return;
                }
                if (item.el === panelToShow) {
                    item.el.classList.remove('hidden');
                } else {
                    item.el.classList.add('hidden');
                }
            });
            
            // If no specific panel is shown (i.e., user is logged in but on main screen)
            if (panelToShow === null && auth.currentUser) {
                 showPanel(mainActionButtons); // Show the main button hub
                 if(hasAdminAccess(auth.currentUser.uid)) {
                    openAdminPanelButton.classList.remove('hidden');
                 } else {
                    openAdminPanelButton.classList.add('hidden');
                 }
            } else if (panelToShow === null && !auth.currentUser) {
                showPanel(loginButtonsContainer); // Show login
            }
        }

        /** Shows a message in the message box */
        function showMessage(message, type = 'error') {
            messageBox.textContent = message;
            messageBox.className = `message-box ${type}`;
            messageBox.classList.remove('hidden');
            setTimeout(hideMessage, 5000); // Auto-hide after 5 seconds
        }

        /** Hides the message box */
        function hideMessage() {
            messageBox.classList.add('hidden');
        }

        /** Formats a user's display name, adding "(School)" for wrsdk12.net emails */
        function formatDisplayName(user) {
            if (!user) return 'N/A';
            let displayName = user.displayName || user.email || 'N/A';
            
            if (typeof displayName !== 'string') displayName = 'N/A';

            if (user.email && typeof user.email === 'string') {
                const emailParts = user.email.split('@');
                if (emailParts.length === 2 && emailParts[1].toLowerCase() === 'wrsdk12.net') {
                    if (!displayName.endsWith(" (School)")) {
                        displayName += " (School)";
                    }
                }
            }
            return displayName;
        }
        
        // --- (Log System Functions were removed) ---


        // --- User Management Functions (Admin) ---

        /** Saves role and chip count changes from the Admin panel to Firestore */
        async function saveUserChangesToFirestore(changesMap) {
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to save user changes.", 'error');
                return;
            }

            const currentUserIsOwner = isOwner(auth.currentUser.uid);
            showMessage("Saving user changes...", 'info');

            try {
                // Fetch current roles/profiles for validation
                const rolesSnapshot = await getDocs(userRolesCollectionRef);
                const currentFirestoreRoles = {};
                rolesSnapshot.forEach(doc => currentFirestoreRoles[doc.id] = doc.data());

                const profilesSnapshot = await getDocs(userProfilesCollectionRef);
                const currentFirestoreProfiles = {};
                profilesSnapshot.forEach(doc => currentFirestoreProfiles[doc.id] = doc.data());

                for (const uid in changesMap) {
                    const { newRole, newChipCount } = changesMap[uid];
                    const oldRole = currentFirestoreRoles[uid]?.role || 'player';
                    const oldChipCount = currentFirestoreProfiles[uid]?.chip_count;

                    let roleChanged = oldRole !== newRole;
                    let chipCountChanged = typeof oldChipCount === 'undefined' || oldChipCount !== newChipCount;
                    
                    if (typeof newChipCount !== 'number') {
                        showMessage(`Invalid chip count for user ${uid}. Must be a number.`, 'error');
                        continue;
                    }

                    // ** Permission Checks **
                    if (uid === SUPER_ADMIN_UID) {
                        if (newRole !== 'owner') {
                            showMessage(`SUPER_ADMIN (${uid}) role cannot be changed from 'owner'.`, 'error');
                            roleChanged = false;
                        }
                        if (!currentUserIsOwner && chipCountChanged) {
                             showMessage(`Chip count for SUPER_ADMIN (${uid}) cannot be changed by non-owners.`, 'error');
                             chipCountChanged = false;
                        }
                    }
                    else if (newRole === 'owner' && !currentUserIsOwner) {
                        showMessage(`You do not have permission to assign 'owner' role to ${uid}.`, 'error');
                        roleChanged = false;
                    }
                    else if (oldRole === 'owner' && !currentUserIsOwner) {
                        if (roleChanged) {
                            showMessage(`You do not have permission to change role of owner ${uid}.`, 'error');
                            roleChanged = false;
                        }
                        if (chipCountChanged) {
                            showMessage(`You do not have permission to change chip count of owner ${uid}.`, 'error');
                            chipCountChanged = false;
                        }
                    }
                    else if (uid === auth.currentUser.uid && currentUserIsOwner && (newRole !== 'owner')) {
                        const ownersInFirestore = Object.keys(currentFirestoreRoles).filter(id => currentFirestoreRoles[id]?.role === 'owner');
                        if (ownersInFirestore.length === 1 && ownersInFirestore[0] === uid && uid !== SUPER_ADMIN_UID) {
                           showMessage("Cannot demote the last owner. Assign 'owner' to another user first.", 'error');
                           roleChanged = false;
                        }
                    }

                    // Proceed with updates
                    if (roleChanged) {
                        const roleDocRef = doc(userRolesCollectionRef, uid);
                        await setDoc(roleDocRef, { role: newRole }, { merge: true });
                    }
                    if (chipCountChanged && typeof newChipCount === 'number') {
                        const roundedChipCount = Math.round(newChipCount);
                        const profileDocRef = doc(userProfilesCollectionRef, uid);
                        await setDoc(profileDocRef, { chip_count: roundedChipCount }, { merge: true });
                    }
                }
                showMessage("User changes processed and saved to Firestore.", 'success');
            } catch (e) {
                console.error("Error saving user changes to Firestore:", e);
                showMessage("Failed to save user changes.", 'error');
            }
        }

        // --- (Investment Functions are here, but commented out as feature is hidden) ---
        // async function editPendingOffer(investmentId) { ... }
        // async function amendInvestment(investmentId) { ... }
        // async function cancelPendingOffer(investmentId) { ... }
        // async function declineInvestment(investmentId) { ... }
        // async function acceptInvestment(investmentId) { ... }

        // --- (In-Game Admin Functions are here) ---
        
        /** Admin: Place a bet for a player in the game room */
        async function adminPlaceBetForPlayer(roomId, targetPlayerId, targetPlayerName, currentChips) {
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to place bets for players.", "error");
                return;
            }
            // ... (rest of the function logic)
            const targetPlayerCurrentStatus = firestoreGameRooms.find(r => r.id === roomId)?.playerStatuses?.[targetPlayerId];
            if (targetPlayerCurrentStatus === 'folded' || targetPlayerCurrentStatus === 'all-in') {
                showMessage(`Cannot place bet for ${targetPlayerName}; player is ${targetPlayerCurrentStatus}.`, "info");
                return;
            }
            
            const betAmountString = prompt(`Enter bet amount for ${targetPlayerName} (current chips: ${currentChips}):`);
            if (betAmountString === null) return;

            const betAmount = parseInt(betAmountString, 10);
            if (isNaN(betAmount) || betAmount <= 0) {
                showMessage("Invalid bet amount. Please enter a positive number.", "error");
                return;
            }

            const targetUserProfile = allFirebaseUsersData.find(p => p.uid === targetPlayerId);
            const targetPlayerTotalChips = targetUserProfile ? (targetUserProfile.chip_count ?? 0) : 0;
            if (betAmount > targetPlayerTotalChips) {
                showMessage(`${targetPlayerName} does not have enough chips (has ${targetPlayerTotalChips}).`, "error");
                return;
            }

            showMessage(`Placing bet of ${betAmount} for ${targetPlayerName}...`, "info");
            const roomDocRef = doc(gameRoomsCollectionRef, roomId);
            try {
                const roomSnap = await getDoc(roomDocRef);
                if (!roomSnap.exists()) {
                    showMessage("Error: Room data not found.", "error");
                    return;
                }
                const roomData = roomSnap.data();
                const currentHighestBetInRoom = Object.values(roomData.currentBets || {}).reduce((max, bet) => Math.max(max, bet), 0);

                let action = 'admin_bet';
                if (betAmount > currentHighestBetInRoom && currentHighestBetInRoom > 0) action = 'admin_raise';
                else if (betAmount === currentHighestBetInRoom && currentHighestBetInRoom > 0) action = 'admin_call';

                let newStatus = 'ready';
                if (betAmount === targetPlayerTotalChips) {
                    newStatus = 'all-in';
                    action = 'admin_all_in';
                }

                const updates = {
                    [`currentBets.${targetPlayerId}`]: betAmount,
                    [`playerStatuses.${targetPlayerId}`]: newStatus,
                    [`playerLastActions.${targetPlayerId}`]: action
                };
                await updateDoc(roomDocRef, updates);
                showMessage(`Bet of ${betAmount} placed for ${targetPlayerName}.`, "success");
            } catch (error) {
                console.error(`Error placing bet for player ${targetPlayerId}:`, error);
                showMessage(`Failed to place bet for player: ${error.message}`, "error");
            }
        }

        /** Admin: Force a player to fold in the game room */
        async function adminForceFoldPlayer(roomId, targetPlayerId, targetPlayerName) {
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to force fold players.", "error");
                return;
            }
            if (targetPlayerId === auth.currentUser.uid) {
                showMessage("You cannot force fold yourself.", "info");
                return;
            }
            
            // Custom modal confirmation would go here. Using prompt as a placeholder
            // for now, but avoiding confirm().
            const confirmation = prompt(`Type 'FOLD' to confirm force-folding ${targetPlayerName || 'this player'}.`);
            if (confirmation !== 'FOLD') {
                showMessage("Action cancelled.", "info");
                return;
            }

            showMessage(`Forcing ${targetPlayerName || 'player'} to fold...`, "info");
            const roomDocRef = doc(gameRoomsCollectionRef, roomId);
            try {
                const updates = {
                    [`playerStatuses.${targetPlayerId}`]: 'folded',
                    [`playerLastActions.${targetPlayerId}`]: 'admin_folded'
                };
                await updateDoc(roomDocRef, updates);
                showMessage(`${targetPlayerName || 'Player'} has been folded.`, "success");
            } catch (error) {
                console.error(`Error force folding player ${targetPlayerId}:`, error);
                showMessage(`Failed to force fold player: ${error.message}`, "error");
            }
        }

        /** Admin: Remove a player from the game room */
        async function adminRemovePlayer(roomId, targetPlayerId, targetPlayerName) {
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to remove players.", "error");
                return;
            }
            if (targetPlayerId === auth.currentUser.uid) {
                showMessage("You cannot remove yourself. Use the 'Leave Room' button.", "info");
                return;
            }
            
            // Custom modal confirmation would go here. Using prompt as a placeholder
            const confirmation = prompt(`Type 'REMOVE' to confirm removing ${targetPlayerName || 'this player'} from the room.`);
            if (confirmation !== 'REMOVE') {
                showMessage("Action cancelled.", "info");
                return;
            }

            showMessage(`Removing ${targetPlayerName || 'player'}...`, "info");
            const roomDocRef = doc(gameRoomsCollectionRef, roomId);
            try {
                const updates = {
                    players: arrayRemove(targetPlayerId),
                    [`currentBets.${targetPlayerId}`]: deleteField(),
                    [`playerStatuses.${targetPlayerId}`]: deleteField(),
                    [`playerLastActions.${targetPlayerId}`]: deleteField()
                };
                await updateDoc(roomDocRef, updates);

                // Also delete their active session to force a UI kick
                try {
                    await deleteDoc(doc(activeSessionsCollectionRef, targetPlayerId));
                } catch (sessionError) {
                    console.error(`Error deleting active session for removed player ${targetPlayerId}:`, sessionError);
                }
                showMessage(`${targetPlayerName || 'Player'} has been removed.`, "success");
            } catch (error) {
                console.error(`Error removing player ${targetPlayerId}:`, error);
                showMessage(`Failed to remove player: ${error.message}`, "error");
            }
        }
        
        // --- (Player In-Game Functions are here) ---

        /** Player: Place a bet */
        async function handlePlaceBet(roomId) {
            if (!auth.currentUser) {
                showMessage("You must be logged in to place a bet.", "error");
                return;
            }
            // ... (rest of the function logic)
            const userId = auth.currentUser.uid;
            const betAmountString = playerBetInput.value.trim();
            const betAmount = parseInt(betAmountString, 10);

            const currentUserProfile = allFirebaseUsersData.find(p => p.uid === userId);
            const currentPlayerChips = currentUserProfile ? (currentUserProfile.chip_count ?? 0) : 0;

            if (isNaN(betAmount) || betAmount <= 0) {
                showMessage("Please enter a valid positive bet amount.", "error");
                return;
            }
            if (betAmount > currentPlayerChips) {
                showMessage("You cannot bet more chips than you have.", "error");
                return;
            }

            const roomDocRef = doc(gameRoomsCollectionRef, roomId);
            showMessage("Placing your bet...", "info");

            try {
                const roomSnap = await getDoc(roomDocRef);
                if (!roomSnap.exists()) {
                    showMessage("Error: Room data not found.", "error");
                    return;
                }
                const roomData = roomSnap.data();
                const currentHighestBet = Object.values(roomData.currentBets || {}).reduce((max, bet) => Math.max(max, bet), 0);
                
                let action = 'bet';
                if (betAmount > currentHighestBet && currentHighestBet > 0) action = 'raise';
                else if (betAmount === currentHighestBet && currentHighestBet > 0) action = 'call';
                else if (betAmount > 0 && currentHighestBet === 0) action = 'bet';

                const updates = {
                    [`currentBets.${userId}`]: betAmount,
                    [`playerStatuses.${userId}`]: 'ready',
                    [`playerLastActions.${userId}`]: action 
                };
                await updateDoc(roomDocRef, updates);
                
                showMessage(`Bet of ${betAmount} (${action}) placed successfully!`, "success");
                playerBetInput.value = '';
            } catch (error) {
                console.error("Error placing bet:", error);
                showMessage(`Failed to place bet: ${error.message}`, "error");
            }
        }

        /** Player: Leave the current game room */
        async function handleLeaveRoom(roomId) {
            if (!auth.currentUser) {
                showMessage("You must be logged in to leave a room.", "error");
                return;
            }
            // ... (rest of the function logic)
            const userId = auth.currentUser.uid;
            if (roomId === currentJoinedRoomId) {
                currentJoinedRoomId = null;
            }

            const roomDocRef = doc(gameRoomsCollectionRef, roomId);
            showMessage("Leaving room...", "info");
            try {
                await updateDoc(roomDocRef, {
                    players: arrayRemove(userId)
                });
                showMessage("You have left the room.", "success");
                showPanel(playerJoinRoomPanel);
            } catch (error) {
                console.error("Error leaving room:", error);
                showMessage(`Failed to leave room: ${error.message}`, "error");
            }
        }

        /** Renders the table in the User Management (Admin) panel */
        function renderUserRolesTable() {
            userRolesTableBody.innerHTML = '';
            
            if (allFirebaseUsersData.length === 0) {
                userRolesTableBody.innerHTML = '<tr><td colspan="4" class="text-center text-gray-500 py-4">No users found.</td></tr>';
                return;
            }

            const currentUserId = auth.currentUser?.uid;
            const activeSessionUIDs = firestoreActiveSessions.map(session => session.id);
            const currentUserIsAdminOrOwner = hasAdminAccess(currentUserId);
            const currentUserIsOwner = isOwner(currentUserId);

            allFirebaseUsersData.sort((a, b) => (a.displayName || '').localeCompare(b.displayName || ''));

            allFirebaseUsersData.forEach(user => {
                const row = userRolesTableBody.insertRow();
                const displayNameCell = row.insertCell();
                const chipCountCell = row.insertCell();
                const userRoleCell = row.insertCell();

                displayNameCell.textContent = formatDisplayName(user);

                // Chip count input
                const chipInput = document.createElement('input');
                chipInput.type = 'number';
                // chipInput.className = 'w-20'; // Handled by .user-table input
                chipInput.setAttribute('data-uid', user.uid);
                chipInput.setAttribute('name', `chip_count_${user.uid}`);
                chipInput.value = (typeof user.chip_count === 'number') ? user.chip_count : 0;
                chipCountCell.appendChild(chipInput);

                // Role select dropdown
                const select = document.createElement('select');
                select.setAttribute('data-uid', user.uid);
                select.setAttribute('name', `role_${user.uid}`);

                const userCurrentRole = getCurrentUserRole(user.uid);
                ROLES.forEach(role => {
                    const option = document.createElement('option');
                    option.value = role;
                    option.textContent = role;
                    select.appendChild(option);
                });
                select.value = userCurrentRole;

                // **Disable fields based on permissions**
                let disableRoleSelect = false;
                let disableChipInput = false;

                if (!currentUserIsAdminOrOwner) {
                    disableRoleSelect = true;
                    disableChipInput = true;
                } else {
                    if (user.uid === SUPER_ADMIN_UID) {
                        disableRoleSelect = true;
                        select.value = 'owner';
                        if (!currentUserIsOwner) {
                            disableChipInput = true;
                        }
                    }
                    else if (userCurrentRole === 'owner' && !currentUserIsOwner) {
                        disableRoleSelect = true;
                        disableChipInput = true;
                    }
                }
                select.disabled = disableRoleSelect;
                chipInput.disabled = disableChipInput;

                if (!currentUserIsOwner) {
                    const ownerOption = select.querySelector('option[value="owner"]');
                    if (ownerOption) ownerOption.disabled = true;
                }

                if (user.uid === currentUserId && currentUserIsOwner) {
                    const ownersInFirestore = Object.keys(firestoreUserRoles).filter(id => firestoreUserRoles[id]?.role === 'owner');
                    if (ownersInFirestore.length === 1 && ownersInFirestore[0] === user.uid && user.uid !== SUPER_ADMIN_UID) {
                        ['disabled', 'player', 'admin'].forEach(roleToDisable => {
                            const option = select.querySelector(`option[value="${roleToDisable}"]`);
                            if (option) option.disabled = true;
                        });
                    }
                }
                userRoleCell.appendChild(select);

                // Actions cell (Force Logout)
                const actionsCell = row.insertCell();
                const forceLogoutButton = document.createElement('button');
                forceLogoutButton.textContent = 'Force Logout';
                forceLogoutButton.className = 'btn btn-red btn-sm'; // New button classes
                
                const targetUserIsOnline = activeSessionUIDs.includes(user.uid);
                let disableLogoutButton = false;

                if (user.uid === currentUserId) disableLogoutButton = true;
                else if (!targetUserIsOnline) disableLogoutButton = true;
                else {
                    if (currentUserIsOwner) disableLogoutButton = false;
                    else if (currentUserIsAdminOrOwner) {
                        if (userCurrentRole === 'owner' || userCurrentRole === 'admin') {
                            disableLogoutButton = true;
                        }
                    } else disableLogoutButton = true;
                }

                forceLogoutButton.disabled = disableLogoutButton;
                if (!disableLogoutButton) {
                    forceLogoutButton.onclick = () => forceLogoutUser(user.uid, formatDisplayName(user));
                }
                actionsCell.appendChild(forceLogoutButton);
            });
        }

        /** Collects changes from the User Management table and sends to save function */
        function collectAndSaveChanges() {
            const changesMap = {};
            const rows = userRolesTableBody.querySelectorAll('tr');

            rows.forEach(row => {
                const roleSelect = row.querySelector('select[data-uid]');
                const chipInput = row.querySelector('input[type="number"][data-uid]');

                if (roleSelect && chipInput) {
                    const uid = roleSelect.getAttribute('data-uid');
                    const newRole = roleSelect.value;
                    const newChipCount = parseInt(chipInput.value, 10);

                    if (isNaN(newChipCount)) {
                        showMessage(`Invalid chip count for user with UID ${uid}.`, 'error');
                        return;
                    }
                    changesMap[uid] = { newRole, newChipCount };
                }
            });

            if (Object.keys(changesMap).length > 0) {
                saveUserChangesToFirestore(changesMap);
            } else {
                showMessage("No user data found to save.", "info");
            }
        }
        
        // --- End User Management Functions ---

        /** Admin: Force a specific user to log out */
        async function forceLogoutUser(targetUid, targetUserDisplayName) {
            console.log(`Attempting to force logout for UID: ${targetUid}`);
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to force logout users.", 'error');
                return;
            }
            // ... (rest of the permission checks) ...
            const currentUserId = auth.currentUser.uid;
            const currentUserIsOwner = isOwner(currentUserId);
            const targetUserRole = getCurrentUserRole(targetUid); 

            if (targetUid === currentUserId) {
                showMessage("You cannot force logout yourself.", 'error');
                return;
            }
            if (!currentUserIsOwner && (targetUserRole === 'owner' || targetUserRole === 'admin')) {
                showMessage("Admins cannot force logout other Admins or Owners.", 'error');
                return;
            }
            
            // Custom modal confirmation would go here. Using prompt as a placeholder
            const confirmation = prompt(`Type 'LOGOUT' to confirm force-logging out ${targetUserDisplayName || targetUid}.`);
            if (confirmation !== 'LOGOUT') {
                showMessage("Action cancelled.", "info");
                return;
            }
            
            showMessage(`Forcing logout for ${targetUserDisplayName || targetUid}...`, 'info');
            try {
                await deleteDoc(doc(activeSessionsCollectionRef, targetUid));
                showMessage(`${targetUserDisplayName || targetUid} has been marked as logged out.`, 'success');
                if (!userManagementPanel.classList.contains('hidden')) {
                    renderUserRolesTable();
                }
            } catch (error) {
                console.error("Error during force logout:", error);
                showMessage(`Failed to force logout. Error: ${error.message}`, 'error');
            }
        }


        // --- "User Directory" Panel Functions ---
        
        /** Shows the public user directory */
        async function showUserDirectoryPanel() { 
            showPanel(userDirectoryPanel);
            await renderUserDirectoryTable(); 
        }

        /** Hides the public user directory */
        function hideUserDirectoryPanel() { 
            showPanel(null); // Return to main button view
        }

        /** Renders the table for the public user directory */
        async function renderUserDirectoryTable() { 
            userDirectoryTableBody.innerHTML = '<tr><td colspan="4">Loading users...</td></tr>';
            try {
                const activeSessionUIDs = firestoreActiveSessions.map(session => session.id);
                // Use the globally available allFirebaseUsersData
                const users = allFirebaseUsersData; 

                userDirectoryTableBody.innerHTML = '';
                if (users.length === 0) {
                    userDirectoryTableBody.innerHTML = '<tr><td colspan="4">No users found.</td></tr>';
                    return;
                }

                users.sort((a, b) => (formatDisplayName(a) || '').toLowerCase().localeCompare((formatDisplayName(b) || '').toLowerCase()));

                users.forEach(user => {
                    const row = userDirectoryTableBody.insertRow();
                    const displayNameCell = row.insertCell();
                    const roleCell = row.insertCell();
                    const chipCountCell = row.insertCell();
                    const statusCell = row.insertCell();

                    displayNameCell.textContent = formatDisplayName(user);
                    chipCountCell.textContent = (typeof user.chip_count === 'number') ? user.chip_count : '0';
                    roleCell.textContent = (typeof user.role === 'string') ? user.role : 'Player';

                    // Determine status: In-Game > Online > Offline
                    let userStatus = "Offline";
                    let statusClass = "status-offline";
                    let isInGame = firestoreGameRooms.some(room => room.players && room.players.includes(user.uid));

                    if (isInGame) {
                        userStatus = "In-Game";
                        statusClass = "status-ingame";
                    } else if (activeSessionUIDs.includes(user.uid)) {
                        userStatus = 'Online';
                        statusClass = 'status-online';
                    }
                    
                    statusCell.textContent = userStatus;
                    statusCell.className = statusClass;
                });

            } catch (error) {
                console.error("Error rendering user directory:", error);
                userDirectoryTableBody.innerHTML = '<tr><td colspan="4">Error loading users.</td></tr>';
            }
        }
        // --- End "User Directory" Panel Functions ---


        // --- Account Management Functions ---

        /** Populates the Account Management panel with user info */
        function renderAccountManagementPanel(displayUser) {
            const firebaseUser = auth.currentUser;
            if (!firebaseUser) return; // Should not happen if panel is visible

            userProfilePic.src = displayUser.profilePic || firebaseUser.photoURL || 'https://placehold.co/100x100/cccccc/ffffff?text=U';
            userProfilePic.alt = `${displayUser.name || 'User'}'s profile picture`;
            currentUserName.textContent = displayUser.name || 'N/A';
            currentUserUsername.textContent = `Email: ${displayUser.username || 'N/A'}`;

            const providers = firebaseUser.providerData.map(p => p.providerId);
            let providerId = 'Unknown';
            if (providers.includes('google.com')) {
                providerId = 'Google';
                linkGoogleAccountButton.classList.add('hidden');
            } else {
                providerId = 'Email/Password or Anonymous';
                linkGoogleAccountButton.classList.remove('hidden');
            }
            currentUserProvider.textContent = `Provider: ${providerId}`;
        }

        /** Handles linking an existing account with a Google account */
        async function handleGoogleLink() {
            if (!auth.currentUser) {
                showMessage("No active user session to link.", 'error');
                return;
            }
            showMessage("Attempting to link with Google...", 'info');
            try {
                const result = await linkWithPopup(auth.currentUser, googleProvider);
                const linkedUser = result.user;
                console.log("Account linked successfully with Google:", linkedUser);

                const updatedLoggedInUser = {
                    ...JSON.parse(localStorage.getItem('loggedInUser') || "{}"),
                    username: linkedUser.email || linkedUser.uid,
                    name: linkedUser.displayName || linkedUser.email,
                    profilePic: linkedUser.photoURL,
                    firebaseUid: linkedUser.uid
                };
                localStorage.setItem('loggedInUser', JSON.stringify(updatedLoggedInUser));
                
                showMessage("Account successfully linked with Google!", 'success');
                renderAccountManagementPanel(updatedLoggedInUser);
            } catch (error) {
                console.error("Error linking Google account:", error);
                let errorMessage = "Failed to link Google account.";
                if (error.code === 'auth/credential-already-in-use') {
                    errorMessage = "This Google account is already linked to another user.";
                }
                showMessage(errorMessage, 'error');
            }
        }

        /** Main function to run after a user successfully logs in */
        async function handleLoginSuccess(user) {
            console.log("handleLoginSuccess: User authenticated, UID:", user.uid);
            
            if (!dataLoadedAndListenersSetup) {
                showPanel(loadingIndicator);
                loadingIndicator.querySelector('span').textContent = 'Loading user data...';
                await loadInitialData(); // Load profiles
                console.log("handleLoginSuccess: Setting up Firestore listeners...");
                await setupFirestoreListeners(); // Wait for listeners
                console.log("handleLoginSuccess: Firestore listeners initial data loaded.");
                dataLoadedAndListenersSetup = true;
            }

            let userRole = getCurrentUserRole(user.uid);

            // Ensure SUPER_ADMIN_UID is always 'owner' in Firestore
            if (user.uid === SUPER_ADMIN_UID && userRole !== 'owner') {
                if (firestoreUserRoles[user.uid]?.role !== 'owner') {
                    console.log(`SUPER_ADMIN_UID (${user.uid}) ensuring 'owner' role.`);
                    try {
                        await setDoc(doc(userRolesCollectionRef, user.uid), { role: 'owner' }, { merge: true });
                        firestoreUserRoles[user.uid] = { role: 'owner' };
                        userRole = 'owner';
                    } catch (e) {
                        console.error("CRITICAL: Failed to set SUPER_ADMIN_UID role:", e);
                    }
                } else {
                    userRole = 'owner';
                }
            }

            // Ensure a user profile exists in Firestore
            const userProfileRef = doc(userProfilesCollectionRef, user.uid);
            const userProfileSnap = await getDoc(userProfileRef);
            
            const userData = {
                uid: user.uid,
                email: user.email || null,
                displayName: user.displayName || user.email || 'Anonymous',
                photoURL: user.photoURL || null,
                lastLogin: new Date().toISOString().slice(0,10),
                role: userRole
            };

            if (!userProfileSnap.exists()) {
                userData.chip_count = 0; // Initialize chips for new users
                console.log("New user profile created with chip_count: 0 for", user.uid);
            } else {
                const existingData = userProfileSnap.data();
                userData.chip_count = (typeof existingData.chip_count === 'number') ? existingData.chip_count : 0;
            }

            await setDoc(userProfileRef, userData, { merge: true });
            console.log("User profile updated/created in Firestore:", user.uid);

            // Add to active_sessions
            try {
                await setDoc(doc(activeSessionsCollectionRef, user.uid), {
                    email: user.email || 'N/A',
                    role: userRole,
                    loginTime: new Date().toISOString()
                }, { merge: true });
                console.log("User session added/updated in active_sessions:", user.uid);
                setupOwnActiveSessionListener(user.uid);
            } catch (e) {
                console.error("Error adding/updating user session:", e);
            }

            // Prepare data for local storage
            const userHasAdminAccess = hasAdminAccess(user.uid);
            const finalUserForLocalStorage = {
                username: user.email || user.uid,
                name: formatDisplayName(user),
                profilePic: user.photoURL || 'https://placehold.co/50x50/cccccc/ffffff?text=U',
                hasAdminAccess: userHasAdminAccess,
                firebaseUid: user.uid,
                role: userRole
            };
            localStorage.setItem('loggedInUser', JSON.stringify(finalUserForLocalStorage));

            // ** Check for 'disabled' role **
            if (userRole === 'disabled') {
                showMessage("Your account has been disabled. Please contact an administrator.", 'error');
                isLoggingOut = true;
                handleLogout();
                showPanel(loginButtonsContainer);
                messageBox.classList.remove('hidden');
                loadingIndicator.classList.add('hidden');
                return; // Stop execution
            }

            // Show welcome message
            showMessage(`Welcome, ${finalUserForLocalStorage.name}! Role: ${userRole}`, 'success');
            
            // Show neutral view with main action buttons
            showPanel(null);
        }

        /** Handles user logout */
        async function handleLogout() {
            if (unsubscribeOwnActiveSessionListener) {
                console.log("Unsubscribing from own active session listener during logout.");
                unsubscribeOwnActiveSessionListener();
                unsubscribeOwnActiveSessionListener = null;
            }

            const loggedInUserString = localStorage.getItem('loggedInUser');
            let firebaseUidToClear = auth.currentUser?.uid || JSON.parse(loggedInUserString || "{}").firebaseUid;

            isLoggingOut = true;

            if (firebaseUidToClear) {
                // Attempt to remove user from any game room
                for (const room of firestoreGameRooms) {
                    if (room.players && room.players.includes(firebaseUidToClear)) {
                        console.log(`User ${firebaseUidToClear} leaving room ${room.id} on logout.`);
                        try {
                            await updateDoc(doc(gameRoomsCollectionRef, room.id), {
                                players: arrayRemove(firebaseUidToClear)
                            });
                        } catch (e) {
                            console.error(`Error removing user from room ${room.id} during logout:`, e);
                        }
                        break; 
                    }
                }

                // Attempt to remove from active_sessions
                try {
                    await deleteDoc(doc(activeSessionsCollectionRef, firebaseUidToClear));
                    console.log("User session removed from active_sessions:", firebaseUidToClear);
                } catch (e) {
                    console.error("Error removing user session:", e);
                }
            }

            try {
                if (auth.currentUser) {
                    await signOut(auth);
                    console.log("Firebase: Signed out.");
                }
            } catch (error) {
                console.error("Firebase: Error signing out:", error);
            }

            localStorage.removeItem('loggedInUser');
            dataLoadedAndListenersSetup = false;
            showMessage('You have been logged out.', 'info');
            showPanel(loginButtonsContainer);
        }

        /** Cleans up session on tab close */
        window.addEventListener('beforeunload', async (event) => {
            if (auth.currentUser && !isLoggingOut) { 
                const userId = auth.currentUser.uid;
                console.log('beforeunload: Attempting cleanup for user:', userId);
                
                // Best-effort: Remove from game room
                for (const room of firestoreGameRooms) {
                    if (room.players && room.players.includes(userId)) {
                        updateDoc(doc(gameRoomsCollectionRef, room.id), {
                            players: arrayRemove(userId)
                        }).catch(e => console.warn(`beforeunload: Error removing user from room ${room.id}:`, e));
                        break;
                    }
                }
                
                // Best-effort: Clear active session
                try {
                    deleteDoc(doc(activeSessionsCollectionRef, userId))
                        .catch(e => console.warn('beforeunload: Error in active session cleanup:', e));
                } catch (e) {
                    console.warn("Error during beforeunload session cleanup:", e);
                }
            }
        });

        // --- Initial Data Loading ---
        
        /** Fetches initial user profiles (run once on login) */
        async function loadInitialData() {
            console.log("loadInitialData: Loading user profiles...");
            if (!auth.currentUser) {
                console.warn("loadInitialData: Skipping, no user.");
                return;
            }
            try {
                const querySnapshot = await getDocs(userProfilesCollectionRef);
                allFirebaseUsersData = querySnapshot.docs.map(doc => doc.data());
                console.log("Loaded Firebase user profiles:", allFirebaseUsersData.length);
            } catch (error) {
                console.error("Failed to fetch user profiles:", error);
                showMessage(`Failed to load user data: ${error.message}.`, 'error');
            }
        }

        // --- Firestore Real-time Listeners ---
        
        /** Sets up all real-time data listeners */
        function setupFirestoreListeners() {
            console.log("setupFirestoreListeners: Setting up listeners...");
            if (!auth.currentUser) {
                console.warn("setupFirestoreListeners: Skipping, no user.");
                return Promise.resolve();
            }

            // Promise for User Roles
            const rolesPromise = new Promise((resolve, reject) => {
                let initialLoad = true;
                onSnapshot(userRolesCollectionRef, (snapshot) => {
                    firestoreUserRoles = {};
                    snapshot.forEach(doc => firestoreUserRoles[doc.id] = doc.data());
                    console.log("Firestore: User Roles snapshot. Count:", Object.keys(firestoreUserRoles).length);
                    
                    if (!userManagementPanel.classList.contains('hidden')) renderUserRolesTable();

                    // Check for mid-session role changes
                    const currentUser = auth.currentUser;
                    if (currentUser) {
                        const storedUser = JSON.parse(localStorage.getItem('loggedInUser'));
                        if (storedUser && currentUser.uid === storedUser.firebaseUid) {
                             const newRole = getCurrentUserRole(currentUser.uid);
                             const newAdminAccess = hasAdminAccess(currentUser.uid);
                             if (storedUser.role !== newRole || storedUser.hasAdminAccess !== newAdminAccess) {
                                 console.log(`Real-time: Role/access changed for ${currentUser.uid}.`);
                                 storedUser.role = newRole;
                                 storedUser.hasAdminAccess = newAdminAccess;
                                 localStorage.setItem('loggedInUser', JSON.stringify(storedUser));
                                 if (newRole === 'disabled') {
                                    showMessage("Your account has been disabled.", 'error');
                                    handleLogout();
                                 }
                                 // Update UI based on new role
                                 showPanel(null); 
                             }
                        }
                    }
                    if (initialLoad) { initialLoad = false; resolve(); }
                }, (error) => { console.error("Firestore: Error listening to user roles:", error); reject(error); });
            });

            // Promise for User Profiles
            const profilesPromise = new Promise((resolve, reject) => {
                let initialLoad = true;
                onSnapshot(userProfilesCollectionRef, (snapshot) => {
                    allFirebaseUsersData = snapshot.docs.map(doc => doc.data());
                    console.log("Firestore: User Profiles snapshot. Count:", allFirebaseUsersData.length);
                    if (!userManagementPanel.classList.contains('hidden')) renderUserRolesTable();
                    if (!userDirectoryPanel.classList.contains('hidden')) renderUserDirectoryTable();
                    if (currentJoinedRoomId && !gameRoomViewPanel.classList.contains('hidden')) renderGameRoomView(currentJoinedRoomId);
                    // if (!investmentsPanel.classList.contains('hidden')) populateInvestmentPlayerSelect(); // Feature hidden

                    if (initialLoad) { initialLoad = false; resolve(); }
                }, (error) => { console.error("Firestore: Error listening to user profiles:", error); reject(error); });
            });

            // Promise for Active Sessions
            const activeSessionsPromise = new Promise((resolve, reject) => {
                let initialLoad = true;
                onSnapshot(activeSessionsCollectionRef, (snapshot) => {
                    firestoreActiveSessions = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    console.log("Firestore: Active Sessions snapshot. Count:", firestoreActiveSessions.length);
                    if (!userDirectoryPanel.classList.contains('hidden')) renderUserDirectoryTable();
                    if (!userManagementPanel.classList.contains('hidden')) renderUserRolesTable();
                    
                    if (initialLoad) { initialLoad = false; resolve(); }
                }, (error) => { console.error("Firestore: Error listening to active sessions:", error); reject(error); });
            });

            // Promise for Game Rooms
            const gameRoomsPromise = new Promise((resolve, reject) => {
                let initialLoad = true;
                const q = query(gameRoomsCollectionRef, orderBy("createdAt", "desc"));
                onSnapshot(q, (snapshot) => {
                    firestoreGameRooms = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    console.log("Firestore: Game Rooms snapshot. Count:", firestoreGameRooms.length);
                    
                    if (!gameRoomManagementPanel.classList.contains('hidden')) renderGameRoomsList();
                    if (!userDirectoryPanel.classList.contains('hidden')) renderUserDirectoryTable();
                    if (!playerJoinRoomPanel.classList.contains('hidden')) renderAvailableRoomsList();

                    // Update in-game view if player is in a room
                    if (currentJoinedRoomId && !gameRoomViewPanel.classList.contains('hidden')) {
                        const updatedRoomData = firestoreGameRooms.find(room => room.id === currentJoinedRoomId);
                        if (updatedRoomData) {
                            renderGameRoomView(currentJoinedRoomId);
                        } else {
                            showMessage("The room you were in is no longer available.", "info");
                            currentJoinedRoomId = null;
                            showPanel(playerJoinRoomPanel);
                        }
                    }
                    if (initialLoad) { initialLoad = false; resolve(); }
                }, (error) => { console.error("Firestore: Error listening to game rooms:", error); reject(error); });
            });

            // Promise for Investments (Feature hidden)
            const investmentsPromise = new Promise((resolve, reject) => {
                let initialLoad = true;
                const q = query(investmentsCollectionRef, orderBy("offerDate", "desc"));
                onSnapshot(q, (snapshot) => {
                    firestoreInvestments = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    console.log("Firestore: Investments snapshot. Count:", firestoreInvestments.length);

                    /* // Feature hidden
                    if (auth.currentUser && !investmentsPanel.classList.contains('hidden')) {
                        renderMySharesList();
                        renderIncomingOffersList();
                        renderMyInvestmentsAsInvesteeList();
                    }
                    */
                    if (initialLoad) { initialLoad = false; resolve(); }
                }, (error) => { console.error("Firestore: Error listening to investments:", error); reject(error); });
            });

            return Promise.all([rolesPromise, profilesPromise, activeSessionsPromise, gameRoomsPromise, investmentsPromise]);
        }


        // --- App Initialization ---
        
        /** Runs when the page content is loaded */
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOMContentLoaded fired. Script is running.');
            showPanel(loadingIndicator); // Show loading indicator

            // Set up the Firebase auth state change listener
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    // User is authenticated
                    console.log("Firebase: Authenticated.", user.uid);
                    firebaseAuthReady = true;

                    if (!isLoggingOut && !dataLoadedAndListenersSetup) {
                        console.log("onAuthStateChanged: User present, triggering handleLoginSuccess.");
                        await handleLoginSuccess(user);
                    } else if (isLoggingOut) {
                        console.log("onAuthStateChanged: User present but logging out.");
                        showPanel(loginButtonsContainer);
                        isLoggingOut = false; // Reset flag
                    }
                } else {
                    // No Firebase user
                    console.log("Firebase: No user authenticated.");
                    firebaseAuthReady = true;

                    if (initialAuthToken && !isLoggingOut) {
                        // Canvas: Attempt custom token sign-in
                        console.log("Firebase: Canvas detected. Attempting custom token sign-in.");
                        loadingIndicator.querySelector('span').textContent = 'Authenticating with Canvas...';
                        try {
                            await signInWithCustomToken(auth, initialAuthToken);
                            // Success will re-trigger onAuthStateChanged with `user`
                        } catch (error) {
                            console.error("Firebase: Custom auth failed:", error);
                            showMessage(`Firebase custom auth failed: ${error.message}.`, 'error');
                            showPanel(loginButtonsContainer);
                        } finally {
                            loadingIndicator.classList.add('hidden');
                        }
                    } else {
                        // Regular web or after logout
                        console.log("Firebase: Displaying login options.");
                        showPanel(loginButtonsContainer);
                        loadingIndicator.classList.add('hidden');
                    }
                    dataLoadedAndListenersSetup = false; 
                }
            });
        });

        // --- Main Event Listeners ---

        /** Google Login Button Click */
        googleLoginButton.addEventListener('click', async () => {
            console.log('Google Login button clicked.');
            if (!firebaseAuthReady) {
                showMessage("Firebase is not ready. Please wait.", 'info');
                return;
            }
            googleLoginButton.disabled = true;
            showMessage("Signing in with Google...", 'info');
            try {
                const result = await signInWithPopup(auth, googleProvider);
                // handleLoginSuccess is triggered by onAuthStateChanged
            } catch (error) {
                console.error("Google Sign-In failed:", error);
                let errorMessage = "Google sign-in failed.";
                if (error.code === 'auth/popup-closed-by-user') {
                    errorMessage = "Google login window was closed.";
                }
                showMessage(errorMessage, 'error');
            } finally {
                googleLoginButton.disabled = false;
            }
        });

        /** Logout Button Click */
        logoutButton.addEventListener('click', handleLogout);

        // --- Admin Panel Button Event Listeners ---
        
        /** "Manage Users" button in Admin Panel */
        manageUsersButton.addEventListener('click', () => {
            if (auth.currentUser && hasAdminAccess(auth.currentUser.uid)) {
                showPanel(userManagementPanel);
                renderUserRolesTable();
            } else {
                showMessage("You do not have administrative access.", 'error');
            }
        });

        /** "Hide Panel" button in User Management */
        hideUserManagementButton.addEventListener('click', () => {
            showPanel(adminPanel);
        });

        /** "Save Changes" button in User Management */
        saveUserRolesButton.addEventListener('click', collectAndSaveChanges);

        /** "Set All Player Chips" button in User Management */
        setAllPlayerChipsButton.addEventListener('click', handleSetAllPlayerChips);
        
        /** "Force Logout All" button in User Management */
        forceLogoutAllUsersButton.addEventListener('click', handleForceLogoutAllUsers);

        /** "Delete All Game Rooms" button in Game Room Management */
        deleteAllGameRoomsButton.addEventListener('click', handleDeleteAllGameRooms);

        // --- Account Management Button Event Listeners ---
        
        /** "Hide Account Management" button */
        hideAccountManagementButton.addEventListener('click', () => {
            showPanel(null); // Return to main button view
        });

        /** "Link with Google" button */
        linkGoogleAccountButton.addEventListener('click', handleGoogleLink);

        // --- User Directory Panel Button Event Listeners ---
        
        /** "View User Directory" main button */
        viewUserDirectoryButton.addEventListener('click', () => { 
            if (auth.currentUser) {
                showUserDirectoryPanel();
            } else {
                showMessage("You must be logged in to view the directory.", 'error');
            }
        });

        /** "Close" button in User Directory */
        hideUserDirectoryPanelButton.addEventListener('click', hideUserDirectoryPanel); 

        // --- Main Navigation Button Event Listeners ---

        /** "Admin Panel" main button */
        openAdminPanelButton.addEventListener('click', () => {
            if (auth.currentUser && hasAdminAccess(auth.currentUser.uid)) {
                showPanel(adminPanel);
            } else {
                showMessage("You do not have permission to access the Admin Panel.", "error");
            }
        });

        /** "Manage Account" main button */
        openAccountManagementButton.addEventListener('click', () => {
            const loggedInUser = JSON.parse(localStorage.getItem('loggedInUser'));
            if (loggedInUser && auth.currentUser) {
                showPanel(accountManagementPanel);
                renderAccountManagementPanel(loggedInUser); 
            } else {
                showMessage("You need to be logged in to manage your account.", "info");
                showPanel(loginButtonsContainer);
            }
        });

        /** "Close Admin Panel" button */
        closeAdminPanelButton.addEventListener('click', () => {
            showPanel(null); // Return to main button view
        });

        // --- Game Room Management Panel Event Listeners (Admin) ---
        
        /** "Manage Game Rooms" button in Admin Panel */
        manageGameRoomsButton.addEventListener('click', () => {
            if (auth.currentUser && hasAdminAccess(auth.currentUser.uid)) {
                showPanel(gameRoomManagementPanel);
                renderGameRoomsList();
            } else {
                showMessage("You do not have permission to manage game rooms.", "error");
            }
        });

        /** "Close" button in Game Room Management */
        closeGameRoomManagementPanelButton.addEventListener('click', () => {
            showPanel(adminPanel); // Return to main admin panel
        });

        /** "Create Room" button */
        async function createGameRoom() {
            const roomName = newRoomNameInput.value.trim();
            if (!roomName) {
                showMessage("Room name cannot be empty.", "error");
                return;
            }
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to create game rooms.", "error");
                return;
            }

            showMessage("Creating game room...", "info");
            try {
                await addDoc(gameRoomsCollectionRef, {
                    roomName: roomName,
                    createdBy: auth.currentUser.uid,
                    createdAt: serverTimestamp(),
                    status: "open",
                    players: []
                });
                showMessage(`Game room "${roomName}" created!`, "success");
                newRoomNameInput.value = '';
                // List will update via Firestore listener
            } catch (error) {
                console.error("Error creating game room:", error);
                showMessage(`Failed to create game room: ${error.message}`, "error");
            }
        }
        createGameRoomButton.addEventListener('click', createGameRoom);

        /** "Delete" button for a specific room */
        async function handleDeleteRoom(roomId, roomName) {
            console.log(`handleDeleteRoom called for: ${roomId}`);
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to delete rooms.", "error");
                return;
            }
            
            // Custom modal confirmation would go here. Using prompt as a placeholder
            const confirmation = prompt(`Type 'DELETE' to confirm deleting room: "${roomName}".`);
            if (confirmation !== 'DELETE') {
                showMessage("Action cancelled.", "info");
                return;
            }

            showMessage(`Deleting room "${roomName}"...`, "info");
            try {
                await deleteDoc(doc(gameRoomsCollectionRef, roomId));
                showMessage(`Room "${roomName}" deleted.`, "success");
                // List will update via Firestore listener
            } catch (error) {
                console.error("Error deleting game room:", error);
                showMessage(`Failed to delete room: ${error.message}`, "error");
            }
        }

        // --- Player Join Game Panel Listeners ---
        
        /** "Join a Game" main button */
        joinGameButton.addEventListener('click', () => {
            if (auth.currentUser) {
                showPanel(playerJoinRoomPanel);
                renderAvailableRoomsList();
            } else {
                showMessage("Please log in to join a game.", "info");
                showPanel(loginButtonsContainer);
            }
        });

        /** "Close" button in Join Room panel */
        closePlayerJoinRoomPanelButton.addEventListener('click', () => {
            showPanel(null); // Return to main button view
        });

        // --- Game Room List Rendering Functions ---

        /** Renders the list of rooms in the Admin panel */
        function renderGameRoomsList() {
            console.log("renderGameRoomsList CALLED");
            if (!gameRoomsListContainer) return; 

            gameRoomsListContainer.innerHTML = '';
            if (firestoreGameRooms.length === 0) {
                gameRoomsListContainer.innerHTML = '<p>No game rooms created yet.</p>';
                return;
            }

            const sortedRooms = [...firestoreGameRooms].sort((a, b) => (b.createdAt?.seconds || 0) - (a.createdAt?.seconds || 0));

            sortedRooms.forEach(room => {
                const li = document.createElement('div');
                li.className = 'list-item';
                
                const roomInfoDiv = document.createElement('div');
                roomInfoDiv.className = 'list-item-info';
                roomInfoDiv.innerHTML = `
                    <span class="name">${room.roomName || 'Unnamed Room'}</span>
                    <span class="details">Status: ${room.status || 'N/A'}</span>
                `;
                li.appendChild(roomInfoDiv);

                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'list-item-actions';
                
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.className = 'btn btn-red btn-sm';
                deleteButton.onclick = () => handleDeleteRoom(room.id, room.roomName || 'Unnamed Room');
                actionsDiv.appendChild(deleteButton);
                
                li.appendChild(actionsDiv);
                gameRoomsListContainer.appendChild(li);
            });
        }

        /** Renders the list of rooms for players to join */
        function renderAvailableRoomsList() {
            if (!availableRoomsListContainer) return;

            availableRoomsListContainer.innerHTML = '';
            const openRooms = firestoreGameRooms.filter(room => room.status === 'open');

            if (openRooms.length === 0) {
                availableRoomsListContainer.innerHTML = '<p>No game rooms available.</p>';
                return;
            }

            const playerUID = auth.currentUser?.uid;

            openRooms.forEach(room => {
                const li = document.createElement('div');
                li.className = 'list-item';
                
                const roomInfoDiv = document.createElement('div');
                roomInfoDiv.className = 'list-item-info';
                roomInfoDiv.innerHTML = `
                    <span class="name">${room.roomName || 'Unnamed Room'}</span>
                    <span class="details">Players: ${room.players?.length || 0}</span>
                `;
                li.appendChild(roomInfoDiv);

                const joinButton = document.createElement('button');
                joinButton.className = 'btn btn-blue btn-sm';
                joinButton.setAttribute('data-room-id', room.id);

                let playerIsCurrentlyInThisRoom = playerUID && room.players && room.players.includes(playerUID);
                let playerIsCurrentlyInAnyOtherRoom = !playerIsCurrentlyInThisRoom && playerUID && firestoreGameRooms.some(r => r.id !== room.id && r.players && r.players.includes(playerUID));

                if (playerIsCurrentlyInThisRoom) {
                    joinButton.textContent = 'View Current Game';
                    joinButton.className = 'btn btn-green btn-sm';
                    joinButton.onclick = () => {
                        currentJoinedRoomId = room.id;
                        showPanel(gameRoomViewPanel);
                        renderGameRoomView(room.id);
                    };
                } else if (playerIsCurrentlyInAnyOtherRoom) {
                    joinButton.textContent = 'Join';
                    joinButton.disabled = true;
                    joinButton.title = "You are already in another room";
                } else {
                    joinButton.textContent = 'Join';
                    joinButton.disabled = (room.status !== 'open');
                    joinButton.onclick = () => handleJoinRoom(room.id);
                }
                
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'list-item-actions';
                actionsDiv.appendChild(joinButton);
                li.appendChild(actionsDiv);
                availableRoomsListContainer.appendChild(li);
            });
        }

        /** Renders the main view when a player is in a game room */
        function renderGameRoomView(roomId) {
            if (!gameRoomViewPanel || !auth.currentUser) {
                showPanel(playerJoinRoomPanel); // Fallback to lobby
                return;
            }

            const room = firestoreGameRooms.find(r => r.id === roomId);
            if (!room) {
                showMessage("Error: The room could not be found.", "error");
                currentJoinedRoomId = null;
                showPanel(playerJoinRoomPanel);
                return;
            }

            gameRoomViewName.textContent = room.roomName || 'Unnamed Room';
            const isAdmin = hasAdminAccess(auth.currentUser.uid);

            // Show/hide admin controls
            if (isAdmin) {
                adminGameControls.classList.remove('hidden');
                adminRoomResetButton.onclick = () => adminRoomReset(roomId);
                adminUpdateChipsButton.onclick = () => toggleUpdateChipsPanel(roomId, true);
                cancelChipUpdate.onclick = () => toggleUpdateChipsPanel(roomId, false);
                submitChipUpdate.onclick = () => handleSubmitChipUpdate(roomId);
            } else {
                adminGameControls.classList.add('hidden');
                updateChipsPanel.classList.add('hidden');
            }

            // Populate player list
            roomPlayersListContainer.innerHTML = '';
            const highestBet = Object.values(room.currentBets || {}).reduce((max, bet) => Math.max(max, bet), 0);

            if (!room.players || room.players.length === 0) {
                roomPlayersListContainer.innerHTML = '<p>No players in this room yet.</p>';
            } else {
                room.players.forEach(playerId => {
                    const playerProfile = allFirebaseUsersData.find(p => p.uid === playerId);
                    const playerName = playerProfile ? formatDisplayName(playerProfile) : `Player ${playerId.substring(0,6)}`;
                    const playerChips = playerProfile ? (playerProfile.chip_count ?? 0) : 'N/A';
                    
                    const rawStatus = room.playerStatuses ? room.playerStatuses[playerId] : 'pending';
                    const playerBetAmount = room.currentBets ? (room.currentBets[playerId] ?? 0) : 0;

                    // Determine display status and card class
                    let displayStatus = rawStatus;
                    let cardStatusClass = 'player-card-default'; // Default

                    if (rawStatus === 'folded') {
                        displayStatus = 'Folded';
                        cardStatusClass = 'player-card-folded';
                    } else if (rawStatus === 'all-in') {
                        displayStatus = 'All-In';
                        cardStatusClass = 'player-card-all-in';
                    } else if (highestBet > 0 && playerBetAmount < highestBet) {
                        displayStatus = 'Pending';
                        cardStatusClass = 'player-card-pending';
                    } else { // Includes playerBetAmount === highestBet, or highestBet is 0
                        displayStatus = 'Ready';
                        cardStatusClass = 'player-card-ready';
                    }

                    const playerCard = document.createElement('div');
                    playerCard.className = `player-card ${cardStatusClass}`;
                    
                    // Create and append card content
                    playerCard.innerHTML = `
                        <p class="player-name">${playerName}</p>
                        <p class="player-chips">Chips: ${playerChips}</p>
                        <p class="player-status">Status: ${displayStatus}</p>
                        <p class="player-bet">Bet: ${playerBetAmount}</p>
                    `;

                    // Admin Menu for Player Card
                    if (isAdmin) {
                        const adminMenuButton = document.createElement('button');
                        adminMenuButton.innerHTML = '&#8942;'; // Vertical ellipsis
                        adminMenuButton.className = 'admin-menu-btn';
                        
                        const adminMenuDropdown = document.createElement('div');
                        adminMenuDropdown.className = 'admin-menu-dropdown hidden';
                        adminMenuDropdown.id = `admin-menu-${playerId}`;

                        // Remove Player
                        const removePlayerButton = document.createElement('button');
                        removePlayerButton.textContent = 'Remove Player';
                        removePlayerButton.disabled = (playerId === auth.currentUser.uid);
                        removePlayerButton.onclick = (e) => { e.stopPropagation(); adminRemovePlayer(roomId, playerId, playerName); adminMenuDropdown.classList.add('hidden'); };
                        adminMenuDropdown.appendChild(removePlayerButton);

                        // Force Fold
                        const forceFoldButton = document.createElement('button');
                        forceFoldButton.textContent = 'Force Fold';
                        forceFoldButton.disabled = (playerId === auth.currentUser.uid || rawStatus === 'folded' || rawStatus === 'all-in');
                        forceFoldButton.onclick = (e) => { e.stopPropagation(); adminForceFoldPlayer(roomId, playerId, playerName); adminMenuDropdown.classList.add('hidden'); };
                        adminMenuDropdown.appendChild(forceFoldButton);

                        // Place Bet
                        const placeBetForPlayerButton = document.createElement('button');
                        placeBetForPlayerButton.textContent = 'Place Bet for Player';
                        placeBetForPlayerButton.disabled = (rawStatus === 'folded' || rawStatus === 'all-in');
                        placeBetForPlayerButton.onclick = (e) => { e.stopPropagation(); adminPlaceBetForPlayer(roomId, playerId, playerName, playerChips); adminMenuDropdown.classList.add('hidden'); };
                        adminMenuDropdown.appendChild(placeBetForPlayerButton);
                        
                        playerCard.appendChild(adminMenuButton);
                        playerCard.appendChild(adminMenuDropdown);

                        adminMenuButton.onclick = (event) => {
                            event.stopPropagation();
                            document.querySelectorAll('.admin-menu-dropdown').forEach(menu => {
                                if (menu.id !== adminMenuDropdown.id) menu.classList.add('hidden');
                            });
                            adminMenuDropdown.classList.toggle('hidden');
                        };
                    }
                    roomPlayersListContainer.appendChild(playerCard);
                });
                
                // Add body click listener to close admin menus
                document.body.addEventListener('click', (event) => {
                    if (!event.target.closest('.player-card')) {
                         document.querySelectorAll('.admin-menu-dropdown').forEach(menu => menu.classList.add('hidden'));
                    }
                }, { capture: true, once: true });
            }

            // Update player's chip count for betting UI
            const currentUserProfileForBetUI = allFirebaseUsersData.find(p => p.uid === auth.currentUser.uid);
            if (currentUserProfileForBetUI && playerChipCountForBet) {
                playerChipCountForBet.textContent = `Your chips: ${currentUserProfileForBetUI.chip_count ?? 0}`;
                if (playerBetInput) playerBetInput.max = currentUserProfileForBetUI.chip_count ?? 0;
            } else if (playerChipCountForBet) {
                playerChipCountForBet.textContent = 'Your chips: N/A';
                 if (playerBetInput) playerBetInput.removeAttribute('max');
            }

            // Update Game Stats
            const gameStatsContent = document.getElementById('gameStatsContent');
            if (gameStatsContent) {
                gameStatsContent.innerHTML = '';
                const totalPot = Object.values(room.currentBets || {}).reduce((sum, bet) => sum + bet, 0);
                
                gameStatsContent.innerHTML = `
                    <p><strong>Total Pot:</strong> ${totalPot} chips</p>
                    <p><strong>Highest Bet:</strong> ${highestBet} chips</p>
                    <h5 class="text-md font-semibold mt-3 mb-1 text-gray-200">Active Player Bets:</h5>
                `;

                const activePlayersUl = document.createElement('ul');
                let activePlayerFound = false;
                if (room.players) {
                    room.players.forEach(playerId => {
                        if (room.playerStatuses?.[playerId] !== 'folded') {
                            const playerProfile = allFirebaseUsersData.find(p => p.uid === playerId);
                            const playerName = playerProfile ? formatDisplayName(playerProfile) : `UID: ${playerId.substring(0,6)}`;
                            activePlayersUl.innerHTML += `<li>${playerName}: ${room.currentBets?.[playerId] ?? 0} chips</li>`;
                            activePlayerFound = true;
                        }
                    });
                }
                if (!activePlayerFound) activePlayersUl.innerHTML = '<p class="text-sm text-gray-400">No players active in pot.</p>';
                gameStatsContent.appendChild(activePlayersUl);
            }

            // Wire up panel buttons
            leaveCurrentGameRoomButton.onclick = () => { handleLeaveRoom(roomId); };
            closeGameRoomViewButton.onclick = () => { currentJoinedRoomId = null; showPanel(playerJoinRoomPanel); };

            // Wire up player action buttons
            placeBetButton.onclick = () => handlePlaceBet(roomId);
            callButton.onclick = () => handleCallBet(roomId);
            foldButton.onclick = () => handleFold(roomId);
            allInButton.onclick = () => handleAllIn(roomId);

            // Disable action buttons if player is folded or all-in
            const currentPlayerStatus = room.playerStatuses ? room.playerStatuses[auth.currentUser.uid] : null;
            const actionButtons = [placeBetButton, foldButton, allInButton, callButton, playerBetInput];
            
            if (currentPlayerStatus === 'folded' || currentPlayerStatus === 'all-in') {
                actionButtons.forEach(btn => btn.disabled = true);
            } else {
                actionButtons.forEach(btn => btn.disabled = false);
                
                // Logic for Call/Check button
                const currentPlayerBet = room.currentBets ? (room.currentBets[auth.currentUser.uid] ?? 0) : 0;
                if (highestBet === 0 || currentPlayerBet === highestBet) {
                    callButton.textContent = 'Check';
                } else {
                    callButton.textContent = 'Call ' + highestBet;
                }
            }
        }

        /** Player: Call the current highest bet or Check */
        async function handleCallBet(roomId) {
            if (!auth.currentUser) return;
            const userId = auth.currentUser.uid;
            const roomDocRef = doc(gameRoomsCollectionRef, roomId);
            // ... (rest of the function logic)
            const roomSnap = await getDoc(roomDocRef);
            if (!roomSnap.exists()) { showMessage("Error: Room data not found.", "error"); return; }
            
            const roomData = roomSnap.data();
            const highestBetInRoom = Object.values(roomData.currentBets || {}).reduce((max, bet) => Math.max(max, bet), 0);
            const currentUserProfile = allFirebaseUsersData.find(p => p.uid === userId);
            const currentPlayerChips = currentUserProfile ? (currentUserProfile.chip_count ?? 0) : 0;
            const currentPlayerBet = roomData.currentBets ? (roomData.currentBets[userId] ?? 0) : 0;

            let betAmount = 0;
            let newStatus = 'ready';
            let actionMessage = "";
            let action = "call";

            if (highestBetInRoom === 0 || currentPlayerBet === highestBetInRoom) { // Check
                betAmount = currentPlayerBet;
                action = 'check';
                actionMessage = "You checked.";
            } else { // Call
                if (currentPlayerChips >= (highestBetInRoom - currentPlayerBet) ) { // Full call
                    betAmount = highestBetInRoom;
                    actionMessage = `You called ${betAmount}.`;
                    action = 'call';
                } else { // Partial call (all-in)
                    betAmount = currentPlayerChips + currentPlayerBet;
                    newStatus = 'all-in';
                    action = 'call_all_in';
                    actionMessage = `You called by going all-in (total bet: ${betAmount}).`;
                }
            }

            showMessage(`Performing action: ${action}...`, "info");
            try {
                await updateDoc(roomDocRef, {
                    [`currentBets.${userId}`]: betAmount,
                    [`playerStatuses.${userId}`]: newStatus,
                    [`playerLastActions.${userId}`]: action
                });
                showMessage(actionMessage, "success");
            } catch (error) {
                console.error(`Error during ${action}:`, error);
                showMessage(`Failed to ${action}: ${error.message}`, "error");
            }
        }

        /** Player: Go all-in */
        async function handleAllIn(roomId) {
            if (!auth.currentUser) return;
            const userId = auth.currentUser.uid;
            // ... (rest of the function logic)
            const userProfile = allFirebaseUsersData.find(p => p.uid === userId);
            if (!userProfile || typeof userProfile.chip_count !== 'number') {
                showMessage("Could not retrieve your chip count.", "error");
                return;
            }
            const allInAmount = userProfile.chip_count;
            if (allInAmount <= 0) {
                showMessage("You have no chips to go all-in with.", "info");
                return;
            }
            showMessage(`Going all-in with ${allInAmount} chips...`, "info");
            try {
                await updateDoc(doc(gameRoomsCollectionRef, roomId), {
                    [`currentBets.${userId}`]: allInAmount,
                    [`playerStatuses.${userId}`]: 'all-in',
                    [`playerLastActions.${userId}`]: 'all-in'
                });
                showMessage(`You are all-in with ${allInAmount}!`, "success");
            } catch (error) {
                console.error("Error going all-in:", error);
                showMessage(`Failed to go all-in: ${error.message}`, "error");
            }
        }

        /** Admin: Placeholder for declaring a winner */
        async function adminDeclareWinner(roomId, targetPlayerId, targetPlayerName) {
            // This function is complex and involves pot calculation.
            // For now, it's a placeholder.
            console.log(`ADMIN ACTION: Declare Winner triggered for ${targetPlayerName}.`);
            // alert(`Admin action: Declared ${targetPlayerName} as winner. (Pot distribution not yet implemented.)`);
            showMessage(`Placeholder: ${targetPlayerName} declared winner. No chips moved.`, "info");
        }

        /** Player: Fold your hand */
        async function handleFold(roomId) {
            if (!auth.currentUser) return;
            const userId = auth.currentUser.uid;
            // ... (rest of the function logic)
            showMessage("Folding your hand...", "info");
            try {
                await updateDoc(doc(gameRoomsCollectionRef, roomId), {
                    [`playerStatuses.${userId}`]: 'folded',
                    [`playerLastActions.${userId}`]: 'fold'
                });
                showMessage("You have folded.", "success");
            } catch (error) {
                console.error("Error folding:", error);
                showMessage(`Failed to fold: ${error.message}`, "error");
            }
        }

        /** Player: Join a game room */
        async function handleJoinRoom(roomId) {
            if (!auth.currentUser) {
                showMessage("You must be logged in to join.", "error");
                return;
            }
            const userId = auth.currentUser.uid;
            // ... (rest of the function logic)
            for (const r of firestoreGameRooms) {
                if (r.players && r.players.includes(userId)) {
                    showMessage("You are already in another game room.", "error");
                    return;
                }
            }
            const roomDocRef = doc(gameRoomsCollectionRef, roomId);
            showMessage("Joining room...", "info");
            try {
                const roomSnap = await getDoc(roomDocRef);
                if (!roomSnap.exists() || roomSnap.data().status !== 'open') {
                    showMessage("This room is no longer open to join.", "error");
                    renderAvailableRoomsList();
                    return;
                }
                
                await updateDoc(roomDocRef, {
                    players: arrayUnion(userId),
                    [`currentBets.${userId}`]: 0,
                    [`playerStatuses.${userId}`]: 'pending',
                    [`playerLastActions.${userId}`]: 'joined'
                });
                showMessage("Successfully joined the room!", "success");
                currentJoinedRoomId = roomId;
                showPanel(gameRoomViewPanel);
                renderGameRoomView(roomId);
            } catch (error) {
                console.error("Error joining room:", error);
                showMessage(`Failed to join room: ${error.message}`, "error");
            }
        }

        // --- Admin Game Control Functions ---

        /** Admin: Reset all bets and unfold players in a room */
        async function adminRoomReset(roomId) {
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) return;
            const room = firestoreGameRooms.find(r => r.id === roomId);
            if (!room || !room.players) return;
            
            // Custom modal confirmation would go here. Using prompt as a placeholder
            const confirmation = prompt(`Type 'RESET' to reset all bets and unfold all players.`);
            if (confirmation !== 'RESET') {
                showMessage("Action cancelled.", "info");
                return;
            }

            showMessage("Resetting room...", "info");
            try {
                const updates = {};
                room.players.forEach(playerId => {
                    updates[`currentBets.${playerId}`] = 0;
                    updates[`playerStatuses.${playerId}`] = 'pending';
                    updates[`playerLastActions.${playerId}`] = 'room_reset';
                });
                await updateDoc(doc(gameRoomsCollectionRef, roomId), updates);
                showMessage("Room has been reset.", "success");
            } catch (error) {
                console.error("Error resetting room:", error);
                showMessage(`Failed to reset room: ${error.message}`, "error");
            }
        }

        /** Admin: Show/hide the "Update Chips" panel */
        function toggleUpdateChipsPanel(roomId, show) {
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) return;
            if (show) {
                populateUpdateChipsPanel(roomId);
                updateChipsPanel.classList.remove('hidden');
            } else {
                updateChipsPanel.classList.add('hidden');
            }
        }

        /** Admin: Populate the "Update Chips" panel with players */
        function populateUpdateChipsPanel(roomId) {
            if (!updateChipsPlayerList) return;
            updateChipsPlayerList.innerHTML = '';
            const room = firestoreGameRooms.find(r => r.id === roomId);
            if (!room || !room.players || room.players.length === 0) {
                updateChipsPlayerList.innerHTML = '<p>No players in room.</p>';
                return;
            }

            room.players.forEach(playerId => {
                const playerProfile = allFirebaseUsersData.find(p => p.uid === playerId);
                const playerName = playerProfile ? formatDisplayName(playerProfile) : `Player ${playerId.substring(0,6)}`;
                const playerStatus = room.playerStatuses ? room.playerStatuses[playerId] : 'unknown';

                const row = document.createElement('div');
                row.className = 'chip-update-row';

                if (playerStatus === 'folded') {
                    row.innerHTML = `<span style="text-decoration: line-through;">${playerName} (Folded)</span>`;
                } else {
                    row.innerHTML = `
                        <span>${playerName}</span>
                        <select data-player-id="${playerId}">
                            <option value="0">No Win / Loser</option>
                            <option value="1">Winner 1st</option>
                            <option value="2">Winner 2nd</option>
                            <option value="3">Winner 3rd</option>
                        </select>
                    `;
                }
                updateChipsPlayerList.appendChild(row);
            });
        }

        /** Admin: Handle the chip update submission (pot distribution) */
        async function handleSubmitChipUpdate(roomId) {
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) return;
            const room = firestoreGameRooms.find(r => r.id === roomId);
            if (!room || !room.players) return;

            // Collect rankings
            const playerRankings = [];
            updateChipsPlayerList.querySelectorAll('select[data-player-id]').forEach(select => {
                playerRankings.push({
                    playerId: select.getAttribute('data-player-id'),
                    rank: parseInt(select.value, 10)
                });
            });

            if (playerRankings.some(p => p.rank > 0 && (room.playerStatuses[p.playerId] === 'folded'))) {
                 showMessage("Error: Folded players cannot be assigned a winning rank.", "error");
                 return;
            }

            // 1. Calculate max win for each eligible player
            console.log("Step 1: Calculating max win.");
            const players = room.players.map(playerId => {
                const playerProfile = allFirebaseUsersData.find(p => p.uid === playerId);
                return {
                    id: playerId,
                    name: playerProfile ? formatDisplayName(playerProfile) : `Player ${playerId.substring(0,6)}`,
                    bet: room.currentBets[playerId] || 0,
                    status: room.playerStatuses[playerId],
                    rank: playerRankings.find(p => p.playerId === playerId)?.rank || 0,
                    winnings: 0,
                    chips: playerProfile.chip_count
                };
            });

            const bets = players.map(p => p.bet);
            const eligiblePlayers = players.filter(p => p.status !== 'folded');

            eligiblePlayers.forEach(player => {
                player.maxWin = bets.reduce((maxWin, bet) => maxWin + Math.min(bet, player.bet), 0);
            });
            console.log("Eligible players with max win:", eligiblePlayers);

            // 2. Set available pot
            let available_pot = bets.reduce((a, b) => a + b, 0);
            console.log("Step 2: Initial available pot:", available_pot);

            // 3-6. Distribute pot by rank
            for (let i = 1; i <= 3; i++) {
                console.log(`Step 3-6: Calculating for rank ${i}`);
                const winners = eligiblePlayers.filter(p => p.rank === i);
                if (winners.length > 0) {
                    const win_quotient = available_pot / winners.length;
                    console.log(`Rank ${i} win quotient:`, win_quotient);
                    winners.forEach(winner => {
                        winner.winnings = Math.min(winner.maxWin, win_quotient);
                        available_pot -= winner.winnings;
                        console.log(`Winner ${winner.name} winnings:`, winner.winnings, "Pot left:", available_pot);
                    });
                }
            }

            // 7. Check for pot remainder
            console.log("Step 7: Final available pot check:", available_pot);
            // Use a small epsilon for floating point comparison
            if (Math.abs(available_pot) > 0.01) {
                showMessage(`Error: Pot not distributed correctly (Remainder: ${available_pot}). Winnings reset.`, "error");
                return;
            }

            // 8. Update Firestore and reset room
            showMessage("Distributing pot and updating chips...", "info");
            const batch = writeBatch(db);
            players.forEach(player => {
                const playerProfileRef = doc(userProfilesCollectionRef, player.id);
                // Round to nearest integer for chip counts
                const newChipCount = Math.round(player.chips - player.bet + player.winnings);
                batch.update(playerProfileRef, { chip_count: newChipCount });
            });
            
            await batch.commit();
            
            showMessage("Pot distributed successfully! Resetting room.", "success");
            adminRoomReset(roomId);
            toggleUpdateChipsPanel(roomId, false);
        }

        // --- Bulk User Management Functions (Admin) ---
        
        /** Admin: Set all users' chip counts to a specific value */
        async function handleSetAllPlayerChips() {
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) return;
            const newChipAmountString = prompt("Enter chip amount for ALL users:");
            if (newChipAmountString === null) return;

            let newChipAmount = parseInt(newChipAmountString, 10);
            if (isNaN(newChipAmount) || newChipAmount < 0) {
                showMessage("Invalid chip amount.", 'error');
                return;
            }
            newChipAmount = Math.round(newChipAmount);

            const confirmation = prompt(`Type 'CHIPS' to set ALL USERS' chip count to ${newChipAmount}.`);
            if (confirmation !== 'CHIPS') {
                showMessage("Action cancelled.", "info");
                return;
            }

            showMessage("Updating all chip counts...", 'info');
            try {
                const querySnapshot = await getDocs(userProfilesCollectionRef);
                const batch = writeBatch(db);
                querySnapshot.forEach(docSnap => {
                    batch.update(doc(userProfilesCollectionRef, docSnap.id), { chip_count: newChipAmount });
                });
                await batch.commit();
                showMessage(`Successfully set chip count to ${newChipAmount} for ${querySnapshot.size} users.`, 'success');
            } catch (error) {
                console.error("Error setting all player chips:", error);
                showMessage(`Failed to update chip counts: ${error.message}`, 'error');
            }
        }

        /** Admin: Force logout all other users */
        async function handleForceLogoutAllUsers() {
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) return;
            
            const confirmation = prompt(`Type 'LOGOUT ALL' to force logout ALL OTHER users. (Admins/Owners may be protected).`);
            if (confirmation !== 'LOGOUT ALL') {
                showMessage("Action cancelled.", "info");
                return;
            }

            showMessage("Forcing logout for all applicable users...", 'info');
            try {
                const activeSessionsSnapshot = await getDocs(activeSessionsCollectionRef);
                const currentAdminUid = auth.currentUser.uid;
                const currentUserIsOwner = isOwner(currentAdminUid);
                const batch = writeBatch(db);
                let usersLoggedOutCount = 0;

                activeSessionsSnapshot.forEach(docSnap => {
                    const sessionUid = docSnap.id;
                    if (sessionUid === currentAdminUid) return; // Skip self
                    
                    const targetUserRole = getCurrentUserRole(sessionUid);
                    if (!currentUserIsOwner && (targetUserRole === 'owner' || targetUserRole === 'admin')) {
                        console.log(`Skipping force logout for ${sessionUid} (Role: ${targetUserRole})`);
                        return;
                    }

                    batch.delete(doc(activeSessionsCollectionRef, sessionUid));
                    usersLoggedOutCount++;
                });

                await batch.commit();
                showMessage(`Initiated force logout for ${usersLoggedOutCount} users.`, 'success');
            } catch (error) {
                console.error("Error forcing logout all:", error);
                showMessage(`Failed to force logout all users: ${error.message}`, 'error');
            }
        }

        // --- Bulk Game Room Management Function (Admin) ---

        /** Admin: Delete ALL game rooms */
        async function handleDeleteAllGameRooms() {
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) return;
            
            const confirmation1 = prompt("EXTREME CAUTION: Type 'DELETE ALL' to delete ALL game rooms. This cannot be undone.");
            if (confirmation1 !== 'DELETE ALL') {
                showMessage("Action cancelled.", "info");
                return;
            }
            const confirmation2 = prompt("SECOND WARNING: Confirm again by typing 'DELETE ALL ROOMS'.");
             if (confirmation2 !== 'DELETE ALL ROOMS') {
                showMessage("Action cancelled.", "info");
                return;
            }

            showMessage("Deleting all game rooms...", 'info');
            try {
                const gameRoomsSnapshot = await getDocs(gameRoomsCollectionRef);
                if (gameRoomsSnapshot.empty) {
                    showMessage("No game rooms found to delete.", 'info');
                    return;
                }

                const batch = writeBatch(db);
                gameRoomsSnapshot.forEach(docSnap => batch.delete(doc(gameRoomsCollectionRef, docSnap.id)));
                await batch.commit();
                
                showMessage(`Successfully deleted ${gameRoomsSnapshot.size} game room(s).`, 'success');
            } catch (error) {
                console.error("Error deleting all game rooms:", error);
                showMessage(`Failed to delete all game rooms: ${error.message}`, 'error');
            }
        }

        // --- (Investments Panel Event Listeners are here, but commented out) ---
        // ...

        // --- (Investment Logic Functions are here, but commented out) ---
        // ...

    </script>
    <!-- =================== JAVASCRIPT END =================== -->

</body>
</html>