<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WPS 3.0</title>
    <!-- Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the Inter font and overall body */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* Light grey background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px; /* Add some padding for smaller screens */
            box-sizing: border-box; /* Ensure padding doesn't cause overflow */
        }
        /* Style for the message box (e.g., error/success messages) */
        .message-box {
            padding: 10px;
            border-radius: 8px;
            margin-top: 15px;
            text-align: center;
            font-weight: bold;
        }
        .message-box.error {
            background-color: #fee2e2; /* Red-ish background */
            color: #ef4444; /* Red text */
            border: 1px solid #ef4444;
        }
        .message-box.success {
            background-color: #d1fae5; /* Green-ish background */
            color: #10b981; /* Green text */
            border: 1px solid #10b981;
        }
        .message-box.info {
            background-color: #bfdbfe; /* Blue-ish background */
            color: #3b82f6; /* Blue text */
            border: 1px solid #3b82f6;
        }
        /* Styling for log entries */
        .log-entry {
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            padding: 8px;
            margin-bottom: 4px;
            border-radius: 4px;
            font-size: 0.875rem;
            color: #4b5563;
            text-align: left;
        }
        .log-entry strong {
            color: #1f2937;
        }
        /* Table styles for user management */
        .user-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        .user-table th, .user-table td {
            border: 1px solid #e2e8f0;
            padding: 8px;
            text-align: left;
        }
        .user-table th {
            background-color: #e0f2fe;
            color: #2563eb;
            font-weight: bold;
        }
        .user-table tr:nth-child(even) {
            background-color: #f8fafc;
        }
        .user-table select {
            width: 100%;
            padding: 4px;
            border-radius: 4px;
            border: 1px solid #cbd5e1;
        }
    </style>

    <!-- ReCAPTCHA stuff -->
    <script src="https://www.google.com/recaptcha/api.js"></script>
    <script>
        function onSubmit(token) {
        document.getElementById("demo-form").submit();
        }
    </script>

    <button 
        class="g-recaptcha" 
        data-sitekey="6LdLLMIrAAAAABxuLcLCsaPMzLoihwb-Zt8F3A_O" 
        data-callback='onSubmit' 
        data-action='submit'>
    </button>

</head>

<body class="bg-gray-100 font-inter">

    <!-- Main Login Container -->
    <div class="bg-white p-8 rounded-xl shadow-lg w-full max-w-sm sm:max-w-md md:max-w-lg lg:max-w-xl flex flex-col items-center">
        <h2 class="text-3xl md:text-4xl font-bold text-gray-800 mb-6">WPS 3.0</h2>

        <!-- Loading Indicator -->
        <div id="loadingIndicator" class="hidden flex items-center justify-center p-4">
            <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <span class="text-gray-600">Initializing Firebase...</span>
        </div>

        <!-- Login Buttons -->
        <div id="loginButtonsContainer" class="w-full flex flex-col items-center space-y-3 hidden">
            <button
                type="button"
                id="googleLoginButton"
                class="w-full flex items-center justify-center bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg"
            >
                <!-- Google Icon SVG -->
                <svg class="w-5 h-5 mr-2" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12.0001 4.5V7.5L17.2501 7.5C17.0279 8.65312 16.3989 9.69736 15.4883 10.4514C14.5776 11.2054 13.4357 11.6212 12.2501 11.6212C9.40006 11.6212 6.99999 9.40871 6.99999 6.55871C6.99999 3.70871 9.40006 1.49621 12.2501 1.49621C13.6874 1.49621 14.9754 2.05267 15.9388 2.92305L18.1565 0.705359C16.5912 -0.80332 14.4754 -1.54716e-07 12.2501 -1.54716e-07C7.26627 -1.54716e-07 3.00006 4.26627 3.00006 9.25006C3.00006 14.2338 7.26627 18.5 12.2501 18.5C14.6738 18.5 16.6346 17.6534 18.0626 16.1436C19.5398 14.6338 19.9999 12.3501 19.9999 9.94006C19.9999 9.25006 19.9312 8.57506 19.8001 7.92506L12.0001 7.92506V4.5Z" fill="#fff"/>
                </svg>
                Sign In with Google
            </button>
            <!-- Email/Password button removed -->
        </div>


        <!-- Message Box for Login Status -->
        <div id="messageBox" class="message-box hidden w-full text-sm md:text-base"></div>

        <!-- Logout Button (Initially hidden) -->
        <button
            id="logoutButton"
            class="hidden mt-4 w-full bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg"
        >
            Logout
        </button>

        <!-- "View User Directory" Button (Initially hidden) -->
        <button
            id="viewUserDirectoryButton"
            class="hidden mt-4 w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg"
        >
            View User Directory
        </button>

        <!-- "Open Account Management" Button (Initially hidden) -->
        <button
            id="openAccountManagementButton"
            class="hidden mt-4 w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg"
        >
            Manage Account
        </button>

        <!-- "Open Admin Panel" Button (Initially hidden, for admins) -->
        <button
            id="openAdminPanelButton"
            class="hidden mt-4 w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg"
        >
            Admin Panel
        </button>

        <!-- "Join a Game" Button (Initially hidden, for all logged-in users) -->
        <button
            id="joinGameButton"
            class="hidden mt-4 w-full bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-orange-500 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg"
        >
            Join a Game
        </button>

        <!-- "Investments" Button (Initially hidden, for all logged-in users) -->
        <!-- <button
            id="investmentsButton"
            class="hidden mt-4 w-full bg-teal-500 hover:bg-teal-600 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-teal-500 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg"
        >
            Investments
        </button> -->

        <!-- "Messages" Button (Initially hidden, for all logged-in users)
        <button
            id="messagesButton"
            class="hidden mt-4 w-full bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg"
        >
            Messages
        </button>-->

        <!-- Admin Panel (Initially hidden) -->
        <div id="adminPanel" class="hidden mt-8 p-6 bg-gray-50 rounded-xl shadow-inner w-full text-center">
            <h3 class="text-2xl md:text-3xl font-bold text-gray-700 mb-4">Admin Panel</h3>
            <p class="text-gray-600 mb-6 text-sm md:text-base">
                Welcome, Administrator! From here, you can manage users, game data, and other aspects of the WPS system.
                <br>
                <strong class="text-red-500">Note: User management will only show users who have logged in via Firebase Auth.</strong>
            </p>
            <div class="space-y-4">
                <button id="manageUsersButton" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Manage Users
                </button>
                <button id="manageGameRoomsButton" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Manage Game Rooms
                </button>
                <!-- Removed "Manage Game Data (Placeholder)" button -->
                <!-- Removed "Configure Games" button -->
                <!-- "View Activity Logs" button removed -->
                <!-- Removed "Account Management" button (id="manageAccountButton") from Admin Panel -->
                <button id="closeAdminPanelButton" class="mt-6 w-1/2 mx-auto bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Close Admin Panel
                </button>
            </div>
        </div>

        <!-- User Management Panel (Initially hidden) -->
        <div id="userManagementPanel" class="hidden mt-8 p-6 bg-gray-50 rounded-xl shadow-inner w-full max-w-md md:max-w-lg lg:max-w-xl">
            <h3 class="text-2xl md:text-3xl font-bold text-gray-700 mb-4 text-center">User Management</h3>
            <p class="text-gray-600 mb-4 text-center text-sm md:text-base">
                Assign roles to users who have logged in.
                <br>
                <strong class="text-red-500">Important: This is a client-side role management for demonstration. For production, consider using Firebase Cloud Functions for secure role assignment.</strong>
            </p>
            <div class="overflow-x-auto">
                <table class="user-table text-sm md:text-base">
                    <thead>
                        <tr>
                            <th>Display Name</th>
                            <th>Chip Count</th>
                            <th>Role</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="userRolesTableBody">
                        <!-- User rows will be rendered here -->
                        <tr><td colspan="3" class="text-center text-gray-500">Loading users...</td></tr>
                    </tbody>
                </table>
            </div>
            <div class="flex justify-between space-x-2 mt-4">
                <button id="saveUserRolesButton" class="w-1/2 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Save Changes
                </button>
                <button id="hideUserManagementButton" class="w-1/2 bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Hide Panel
                </button>
            </div>
            <!-- Bulk User Actions -->
            <div class="mt-6 border-t pt-4 space-y-3">
                <h4 class="text-lg font-semibold text-gray-700 text-center mb-2">Bulk User Actions</h4>
                <button id="setAllPlayerChipsButton" class="w-full bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out">
                    Set All Player Chips
                </button>
                <button id="forceLogoutAllUsersButton" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out">
                    Force Logout All Users (Except Self)
                </button>
            </div>
        </div>

        <!-- Game Room Management Panel (Initially hidden) -->
        <div id="gameRoomManagementPanel" class="hidden mt-8 p-6 bg-gray-50 rounded-xl shadow-inner w-full max-w-lg md:max-w-xl">
            <h3 class="text-2xl md:text-3xl font-bold text-gray-700 mb-6 text-center">Manage Game Rooms</h3>

            <!-- Create New Game Room Section -->
            <div class="mb-6 p-4 border border-gray-200 rounded-lg bg-white">
                <h4 class="text-lg font-semibold text-gray-700 mb-3">Create New Game Room</h4>
                <div class="flex flex-col sm:flex-row items-stretch sm:items-end space-y-2 sm:space-y-0 sm:space-x-2">
                    <div class="flex-grow">
                        <label for="newRoomNameInput" class="block text-sm font-medium text-gray-700 mb-1">Room Name:</label>
                        <input type="text" id="newRoomNameInput" placeholder="e.g., Main Event Table 1" class="w-full border rounded-lg py-2 px-3 text-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                    <button id="createGameRoomButton" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out sm:w-auto w-full">
                        Create Room
                    </button>
                </div>
            </div>

            <!-- Existing Game Rooms List Section -->
            <div>
                <h4 class="text-lg font-semibold text-gray-700 mb-3">Existing Rooms</h4>
                <div id="gameRoomsListContainer" class="max-h-80 overflow-y-auto border border-gray-200 p-2 rounded-lg bg-white">
                    <p class="text-gray-500 text-center py-4">Loading rooms...</p>
                    <!-- Game rooms will be listed here by JavaScript -->
                </div>
            </div>

            <div class="flex justify-center mt-6">
                <button id="closeGameRoomManagementPanelButton" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105">
                    Close & Return to Admin Panel
                </button>
            </div>

            <!-- Bulk Room Action -->
            <div class="mt-6 border-t pt-4">
                <button id="deleteAllGameRoomsButton" class="w-full bg-red-700 hover:bg-red-800 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out">
                    Delete All Game Rooms (USE WITH CAUTION)
                </button>
            </div>
        </div>

        <!-- Player Join Room Panel (Initially hidden) -->
        <div id="playerJoinRoomPanel" class="hidden mt-8 p-6 bg-gray-50 rounded-xl shadow-inner w-full max-w-lg md:max-w-xl">
            <h3 class="text-2xl md:text-3xl font-bold text-gray-700 mb-6 text-center">Available Game Rooms</h3>
            
            <div id="availableRoomsListContainer" class="max-h-96 overflow-y-auto border border-gray-200 p-2 rounded-lg bg-white">
                <p class="text-gray-500 text-center py-4">Loading available rooms...</p>
                <!-- Available game rooms will be listed here by JavaScript -->
            </div>

            <div class="flex justify-center mt-6">
                <button id="closePlayerJoinRoomPanelButton" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105">
                    Close
                </button>
            </div>
            <!--<div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                Player List
                <div class="md:col-span-1 bg-white p-4 rounded-lg shadow">
                    <div class="flex justify-between items-center mb-4">
                        <h4 class="text-lg font-semibold text-gray-800">Players</h4>
                        <button id="createGroupChatButton" class="bg-green-500 hover:bg-green-600 text-white font-bold py-1 px-2 rounded-lg text-sm">+</button>
                    </div>
                    <input type="text" id="playerSearchInput" placeholder="Search players..." class="w-full border rounded-lg py-2 px-3 text-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500 mb-4">
                    <div id="messagesPlayerList" class="max-h-96 overflow-y-auto">
                        <div class="p-2 hover:bg-gray-100 cursor-pointer rounded-md font-bold" data-gid="group_1678886400000">General</div>
                    </div>
                </div>

                Chat Area
                <div class="md:col-span-2 bg-white p-4 rounded-lg shadow flex flex-col">
                    <div id="chatHeader" class="border-b pb-2 mb-4">
                        <h4 class="text-lg font-semibold text-gray-800">Select a conversation</h4>
                    </div>
                    <div id="chatMessages" class="flex-grow overflow-y-auto mb-4">
                        <div class="p-2 my-1 rounded-lg bg-gray-200 text-gray-800 self-start">Welcome to the chat!</div>
                    </div>
                    <div id="chatInputContainer" class="mt-auto">
                        <div class="flex">
                            <input type="text" id="messageInput" placeholder="Type a message..." class="w-full border rounded-l-lg py-2 px-3 text-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <button id="sendMessageButton" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-r-lg">Send</button>
                        </div>
                    </div>
                </div>
            </div>-->
        </div>

        <!-- Game Room View Panel (Initially hidden) -->
        <div id="gameRoomViewPanel" class="hidden mt-8 p-4 sm:p-6 bg-gray-800 text-white rounded-xl shadow-xl w-full max-w-2xl lg:max-w-4xl">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-2xl md:text-3xl font-bold" id="gameRoomViewName">Room Name Placeholder</h3>
                <button id="closeGameRoomViewButton" class="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-4 rounded-lg text-sm transition duration-150">
                    Return to Lobby
                </button>
            </div>

            <!-- Player List Area -->
            <div class="mb-6">
                <h4 class="text-xl font-semibold mb-3 text-gray-300">Players in Room</h4>
                <div id="roomPlayersListContainer" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3 max-h-72 overflow-y-auto p-2 bg-gray-700 rounded">
                    <!-- Player cards will be rendered here by JavaScript -->
                    <p class="text-gray-400 col-span-full text-center py-4">Waiting for players...</p>
                </div>
            </div>
            
            <!-- Game Stats Area -->
            <div id="gameStatsContainer" class="mb-6 p-4 border border-gray-600 rounded-lg bg-gray-700">
                <h4 class="text-lg font-semibold text-gray-300 mb-3">Game Stats</h4>
                <div id="gameStatsContent" class="text-gray-300">
                    <p>Loading game stats...</p>
                </div>
                <!-- Admin Game Controls -->
                <div id="adminGameControls" class="mt-4 pt-4 border-t border-gray-600 hidden">
                    <h5 class="text-md font-semibold text-gray-200 mb-2">Admin Controls</h5>
                    <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-2">
                        <button id="adminRoomResetButton" class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-3 rounded-lg text-sm transition duration-150 ease-in-out flex-1">
                            Room Reset
                        </button>
                        <button id="adminUpdateChipsButton" class="bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-3 rounded-lg text-sm transition duration-150 ease-in-out flex-1">
                            Update Chips
                        </button>
                    </div>
                </div>
            </div>

            <!-- Update Chips Panel (Admin Only, Initially Hidden) -->
            <div id="updateChipsPanel" class="hidden p-4 my-4 border border-gray-600 rounded-lg bg-gray-700">
                <h4 class="text-lg font-semibold text-gray-200 mb-3">Update Player Chips After Hand</h4>
                <div id="updateChipsPlayerList" class="space-y-3 mb-4 max-h-60 overflow-y-auto">
                    <!-- Player entries will be populated here by JavaScript -->
                    <p class="text-gray-400">Loading players...</p>
                </div>
                <div class="flex justify-end space-x-3">
                    <button id="cancelChipUpdate" class="bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg text-sm transition duration-150">
                        Cancel
                    </button>
                    <button id="submitChipUpdate" class="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-lg text-sm transition duration-150">
                        Submit Chip Updates
                    </button>
                </div>
            </div>

            <!-- Player Bet Input Section -->
            <div class="p-4 border border-gray-600 rounded-lg bg-gray-700">
                <h4 class="text-lg font-semibold text-gray-300 mb-3">Your Bet</h4>
                <div class="flex flex-col sm:flex-row items-stretch sm:items-end space-y-3 sm:space-y-0 sm:space-x-3">
                    <div class="flex-grow">
                        <label for="playerBetInput" class="block text-sm font-medium text-gray-300 mb-1">Enter Amount:</label>
                        <input type="number" id="playerBetInput" placeholder="0" class="w-full border-gray-500 bg-gray-600 text-white rounded-lg py-2 px-3 focus:outline-none focus:ring-2 focus:ring-blue-500" min="0">
                        <p class="text-xs text-gray-400 mt-1">Your chips: <span id="playerChipCountForBet">N/A</span></p>
                    </div>
                    <button id="placeBetButton" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out sm:w-auto w-full">
                        Place Bet
                    </button>
                    <button id="callButton" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out sm:w-auto w-full">
                        Call
                    </button>
                    <button id="foldButton" class="bg-red-700 hover:bg-red-800 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out sm:w-auto w-full">
                        Fold
                    </button>
                    <button id="allInButton" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out sm:w-auto w-full">
                        All-In
                    </button>
                </div>
            </div>

            <div class="flex justify-center mt-6">
                 <button id="leaveCurrentGameRoomButton" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105">
                    Leave Room
                </button>
            </div>
        </div>


        <!-- Account Management Panel (Initially hidden) -->
        <div id="accountManagementPanel" class="hidden mt-8 p-6 bg-gray-50 rounded-xl shadow-inner w-full max-w-md md:max-w-lg text-center">
            <h3 class="text-2xl md:text-3xl font-bold text-gray-700 mb-4">Account Management</h3>
            <div class="flex flex-col items-center space-y-4">
                <img id="userProfilePic" class="w-24 h-24 md:w-32 md:h-32 rounded-full border-4 border-blue-400 shadow-md" src="" alt="Profile Picture">
                <p class="text-xl md:text-2xl font-semibold text-gray-800" id="currentUserName"></p>
                <p class="text-gray-600 text-sm md:text-base" id="currentUserUsername"></p>
                <p class="text-gray-500 text-xs md:text-sm" id="currentUserProvider"></p>

                <div class="w-full space-y-3 pt-4 border-t border-gray-200 mt-4">
                    <button
                        type="button"
                        id="linkGoogleAccountButton"
                        class="w-full flex items-center justify-center bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg"
                    >
                        <svg class="w-5 h-5 mr-2" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12.0001 4.5V7.5L17.2501 7.5C17.0279 8.65312 16.3989 9.69736 15.4883 10.4514C14.5776 11.2054 13.4357 11.6212 12.2501 11.6212C9.40006 11.6212 6.99999 9.40871 6.99999 6.55871C6.99999 3.70871 9.40006 1.49621 12.2501 1.49621C13.6874 1.49621 14.9754 2.05267 15.9388 2.92305L18.1565 0.705359C16.5912 -0.80332 14.4754 -1.54716e-07 12.2501 -1.54716e-07C7.26627 -1.54716e-07 3.00006 4.26627 3.00006 9.25006C3.00006 14.2338 7.26627 18.5 12.2501 18.5C14.6738 18.5 16.6346 17.6534 18.0626 16.1436C19.5398 14.6338 19.9999 12.3501 19.9999 9.94006C19.9999 9.25006 19.9312 8.57506 19.8001 7.92506L12.0001 7.92506V4.5Z" fill="#fff"/>
                        </svg>
                        Link with Google
                    </button>
                    <button class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                        Change Password (Placeholder)
                    </button>
                    <button class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                        Update Profile (Placeholder)
                    </button>
                </div>
                <button id="hideAccountManagementButton" class="w-full bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Close Account Management
                </button>
            </div>
        </div>


        <!-- Activity Log Viewer (REMOVED) -->

        <!-- User Directory Panel -->
        <div id="userDirectoryPanel" class="hidden mt-8 p-6 bg-gray-50 rounded-xl shadow-inner w-full max-w-lg md:max-w-xl lg:max-w-2xl">
            <h3 class="text-2xl md:text-3xl font-bold text-gray-700 mb-4 text-center">User Directory</h3>
            <div class="overflow-x-auto">
                <table class="user-table text-sm md:text-base">
                    <thead>
                        <tr>
                            <th>Display Name</th>
                            <th>Chip Count</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="userDirectoryTableBody">
                        <!-- User rows will be rendered here by JavaScript -->
                        <tr><td colspan="2" class="text-center text-gray-500 py-4">Loading...</td></tr>
                    </tbody>
                </table>
            </div>
            <div class="flex justify-center mt-4">
                <button id="hideUserDirectoryPanelButton" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Close
                </button>
            </div>
        </div>

        <!-- Investments Panel (Initially hidden) -->
        <div id="investmentsPanel" class="hidden mt-8 p-6 bg-gray-50 rounded-xl shadow-inner w-full max-w-2xl lg:max-w-4xl">
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-2xl md:text-3xl font-bold text-gray-700">Investments</h3>
                <button id="closeInvestmentsPanelButton" class="bg-gray-400 hover:bg-gray-500 text-white font-semibold py-2 px-4 rounded-lg text-sm transition duration-150">
                    Close
                </button>
            </div>

            <!-- Tabs for Shares and Offers -->
            <div class="mb-4 border-b border-gray-200">
                <ul class="flex flex-wrap -mb-px text-sm font-medium text-center" id="investmentsTabs" role="tablist">
                    <li class="mr-2" role="presentation">
                        <button class="inline-block p-4 border-b-2 rounded-t-lg" id="shares-tab" data-tabs-target="#sharesContent" type="button" role="tab" aria-controls="sharesContent" aria-selected="true">Shares</button>
                    </li>
                    <li class="mr-2" role="presentation">
                        <button class="inline-block p-4 border-b-2 rounded-t-lg hover:text-gray-600 hover:border-gray-300" id="offers-tab" data-tabs-target="#offersContent" type="button" role="tab" aria-controls="offersContent" aria-selected="false">Offers</button>
                    </li>
                </ul>
            </div>

            <!-- Tab Content -->
            <div id="investmentsTabContent">
                <!-- Shares Section -->
                <div class="hidden p-4 rounded-lg bg-white" id="sharesContent" role="tabpanel" aria-labelledby="shares-tab">
                    <h4 class="text-xl font-semibold text-gray-800 mb-4">My Shares</h4>
                    <!-- Offer Investment Form -->
                    <div class="mb-6 p-4 border border-gray-200 rounded-lg bg-gray-100">
                        <h5 class="text-lg font-semibold text-gray-700 mb-4">Offer New Investment</h5>
                        <form id="offerInvestmentForm" class="space-y-4">
                            <div>
                                <label for="investPlayerSelect" class="block text-sm font-medium text-gray-700 mb-1">Select Player to Invest In:</label>
                                <select id="investPlayerSelect" name="investPlayer" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
                                    <option value="">Loading players...</option>
                                    <!-- Options will be populated by JavaScript -->
                                </select>
                            </div>
                            <div>
                                <label for="investChipAmount" class="block text-sm font-medium text-gray-700 mb-1">Chips to Send (1 - <span id="maxInvestableChips">Your Chips</span>):</label>
                                <input type="number" id="investChipAmount" name="chipAmount" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" placeholder="e.g., 100" min="1">
                            </div>
                            <div>
                                <label for="investPayoutPercent" class="block text-sm font-medium text-gray-700 mb-1">Requested Payout Percentage (% of Investee's Total Chips):</label>
                                <input type="number" id="investPayoutPercent" name="payoutPercent" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" placeholder="e.g., 10" min="1" max="100">
                            </div>
                            <div>
                                <label for="investHandsPayout" class="block text-sm font-medium text-gray-700 mb-1">Hands Until Payout:</label>
                                <input type="number" id="investHandsPayout" name="handsToPayout" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" placeholder="e.g., 5" min="1">
                            </div>
                            <button type="submit" id="submitInvestmentOfferButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out">
                                Submit Investment Offer
                            </button>
                        </form>
                    </div>

                    <!-- List of My Shares -->
                    <div id="mySharesListContainer">
                        <h5 class="text-lg font-semibold text-gray-700 mb-3">My Active & Pending Shares</h5>
                        <div id="mySharesList" class="space-y-3 max-h-96 overflow-y-auto">
                            <p class="text-gray-500 p-3 text-center">You have no active or pending shares.</p>
                            <!-- Sample Share Item Structure (to be replaced by JS) -->
                            <!--
                            <div class="p-3 border rounded-md bg-gray-50 shadow-sm">
                                <div class="flex justify-between items-center mb-1">
                                    <p class="font-semibold text-gray-800">Investment in: <span class="font-normal">PlayerX</span></p>
                                    <span class="text-xs px-2 py-0.5 rounded-full bg-yellow-200 text-yellow-800">Pending</span>
                                </div>
                                <p class="text-sm text-gray-600">Invested: <span class="font-medium">100 chips</span></p>
                                <p class="text-sm text-gray-600">Requested Payout: <span class="font-medium">10%</span></p>
                                <p class="text-sm text-gray-600">Hands for Payout: <span class="font-medium">5</span></p>
                                <p class="text-sm text-gray-600">Date Offered: <span class="font-medium">YYYY-MM-DD</span></p>
                                <div class="mt-2 space-x-2">
                                    <button class="text-xs bg-blue-500 hover:bg-blue-600 text-white py-1 px-2 rounded">Edit</button>
                                    <button class="text-xs bg-red-500 hover:bg-red-600 text-white py-1 px-2 rounded">Delete</button>
                                    <button class="text-xs bg-gray-500 hover:bg-gray-600 text-white py-1 px-2 rounded hidden">View Message</button>
                                </div>
                            </div>
                            <div class="p-3 border rounded-md bg-green-50 shadow-sm">
                                <div class="flex justify-between items-center mb-1">
                                    <p class="font-semibold text-gray-800">Investment in: <span class="font-normal">PlayerZ</span></p>
                                    <span class="text-xs px-2 py-0.5 rounded-full bg-green-200 text-green-800">Active</span>
                                </div>
                                <p class="text-sm text-gray-600">Invested: <span class="font-medium">200 chips</span></p>
                                <p class="text-sm text-gray-600">Agreed Payout: <span class="font-medium">15%</span></p>
                                <p class="text-sm text-gray-600">Hands Remaining: <span class="font-medium">3</span></p>
                                <p class="text-sm text-gray-600">Date Accepted: <span class="font-medium">YYYY-MM-DD</span></p>
                                <p class="text-sm text-gray-600">Est. Return: <span class="font-medium">Calculating...</span></p>
                            </div>
                            -->
                        </div>
                    </div>
                </div>

                <!-- Offers Section -->
                <div class="hidden p-4 rounded-lg bg-white" id="offersContent" role="tabpanel" aria-labelledby="offers-tab">
                    <h4 class="text-xl font-semibold text-gray-800 mb-4">Investment Offers</h4>
                    <!-- Incoming Offers List -->
                    <div id="incomingOffersListContainer" class="mb-6">
                        <h5 class="text-lg font-semibold text-gray-700 mb-3">Incoming Investment Offers</h5>
                        <div id="incomingOffersList" class="space-y-3 max-h-80 overflow-y-auto">
                            <p class="text-gray-500 p-3 text-center">You have no incoming investment offers.</p>
                            <!-- Sample Incoming Offer Item Structure (to be replaced by JS) -->
                            <!--
                            <div class="p-3 border rounded-md bg-gray-50 shadow-sm">
                                <p class="font-semibold text-gray-800">Offer from: <span class="font-normal">PlayerY</span></p>
                                <p class="text-sm text-gray-600">Offering: <span class="font-medium">50 chips</span></p>
                                <p class="text-sm text-gray-600">For Payout: <span class="font-medium">5%</span> of your total chips</p>
                                <p class="text-sm text-gray-600">Payout in: <span class="font-medium">3 hands</span></p>
                                <p class="text-sm text-gray-600">Date Offered: <span class="font-medium">YYYY-MM-DD</span></p>
                                <div class="mt-3 space-x-2">
                                    <button class="text-xs bg-green-500 hover:bg-green-600 text-white font-bold py-1 px-3 rounded">Accept</button>
                                    <button class="text-xs bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-3 rounded">Decline</button>
                                    <button class="text-xs bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-1 px-3 rounded">Amend</button>
                                </div>
                                <div class="mt-2 p-2 bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 text-xs hidden">
                                    <p><strong>Amendment Message from Investor:</strong><span class="ml-1">Investor wants 6% instead.</span></p>
                                </div>
                            </div>
                            -->
                        </div>
                    </div>

                    <!-- My Accepted & Completed Investments List -->
                    <div id="myInvestmentsAsInvesteeContainer">
                        <h5 class="text-lg font-semibold text-gray-700 mb-3">My Investments (As Investee)</h5>
                        <div id="myInvestmentsAsInvesteeList" class="space-y-3 max-h-80 overflow-y-auto">
                            <p class="text-gray-500 p-3 text-center">You have not accepted any investments.</p>
                            <!-- Sample Accepted/Completed Investment Item Structure (to be replaced by JS) -->
                            <!--
                            <div class="p-3 border rounded-md bg-blue-50 shadow-sm">
                                <div class="flex justify-between items-center mb-1">
                                    <p class="font-semibold text-gray-800">Investment from: <span class="font-normal">PlayerZ</span></p>
                                    <span class="text-xs px-2 py-0.5 rounded-full bg-blue-200 text-blue-800">Active</span>
                                </div>
                                <p class="text-sm text-gray-600">Received: <span class="font-medium">50 chips</span></p>
                                <p class="text-sm text-gray-600">Agreed Payout: <span class="font-medium">5%</span> of your total chips</p>
                                <p class="text-sm text-gray-600">Hands Remaining for Payout: <span class="font-medium">2</span></p>
                                <p class="text-sm text-gray-600">Date Accepted: <span class="font-medium">YYYY-MM-DD</span></p>
                                <p class="text-sm text-gray-600">Current Est. Payout: <span class="font-medium">Calculating...</span></p>
                            </div>
                            <div class="p-3 border rounded-md bg-gray-200 shadow-sm opacity-75">
                                <div class="flex justify-between items-center mb-1">
                                    <p class="font-semibold text-gray-700">Investment from: <span class="font-normal">PlayerOld</span></p>
                                    <span class="text-xs px-2 py-0.5 rounded-full bg-gray-300 text-gray-700">Completed</span>
                                </div>
                                <p class="text-sm text-gray-500">Received: <span class="font-medium">100 chips</span></p>
                                <p class="text-sm text-gray-500">Paid Out: <span class="font-medium">10%</span> (e.g. 25 chips)</p>
                                <p class="text-sm text-gray-500">Date Completed: <span class="font-medium">YYYY-MM-DD</span></p>
                            </div>
                            -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Create Group Chat Modal -->
        <div id="createGroupChatModal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full">
            <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
                <div class="mt-3 text-center">
                    <h3 class="text-lg leading-6 font-medium text-gray-900">Create Group Chat</h3>
                    <div class="mt-2 px-7 py-3">
                        <input type="text" id="groupNameInput" placeholder="Group Name" class="w-full border rounded-lg py-2 px-3 text-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500 mb-4">
                        <div id="groupPlayerList" class="max-h-60 overflow-y-auto border rounded-lg p-2">
                            <!-- Player list for group selection will be rendered here -->
                        </div>
                    </div>
                    <div class="items-center px-4 py-3">
                        <button id="createGroupButton" class="px-4 py-2 bg-green-500 text-white text-base font-medium rounded-md w-full shadow-sm hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-300">
                            Create Group
                        </button>
                        <button id="cancelGroupButton" class="mt-2 px-4 py-2 bg-gray-500 text-white text-base font-medium rounded-md w-full shadow-sm hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-300">
                            Cancel
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Messages Panel (Initially hidden)
        <div id="messagesPanel" class="hidden mt-8 p-6 bg-gray-50 rounded-xl shadow-inner w-full max-w-2xl lg:max-w-4xl">
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-2xl md:text-3xl font-bold text-gray-700">Messages</h3>
                <button id="closeMessagesPanelButton" class="bg-gray-400 hover:bg-gray-500 text-white font-semibold py-2 px-4 rounded-lg text-sm transition duration-150">
                    Close
                </button>
            </div>
        </div>-->

    </div>

    <script type="module">
        // Import Firebase SDKs
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-analytics.js";
        import { getAuth, signInWithCustomToken, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, linkWithPopup, signOut } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, addDoc, onSnapshot, collection, query, getDocs, deleteDoc, serverTimestamp, orderBy, updateDoc, arrayUnion, arrayRemove, deleteField, writeBatch } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";

        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyBefsHEBuiRyJ31NzF885ac3ugCefzngTU",
            authDomain: "wps-3-be723.firebaseapp.com",
            projectId: "wps-3-be723",
            storageBucket: "wps-3-be723.firebasestorage.app",
            messagingSenderId: "420146617877",
            appId: "1:420146617877:web:ea2e06a690732da76fb81c",
            measurementId: "G-H0Z4C2185Y"
        };

        const appId = typeof __app_id !== 'undefined' ? __app_id : firebaseConfig.projectId;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Initialize Firebase
        const firebaseApp = initializeApp(firebaseConfig);
        const analytics = getAnalytics(firebaseApp);
        const db = getFirestore(firebaseApp, '(default)'); // Using named database '(default)'
        const auth = getAuth(firebaseApp);
        const googleProvider = new GoogleAuthProvider();


        // Track Firebase authentication readiness and data loading state
        let firebaseAuthReady = false;
        let isLoggingOut = false;
        let dataLoadedAndListenersSetup = false;
        let unsubscribeOwnActiveSessionListener = null; // For self-logout listener


        // --- Super Admin UID (DO NOT TOUCH THIS!) ---
        // This UID will be used to identify the initial administrator account.
        // It should be the Firebase UID of your Google account.
        const SUPER_ADMIN_UID = "Qr3XI0uNYrZ3AECim6XtRvp12MJ2";


        // --- DOM Elements ---
        const loginButtonsContainer = document.getElementById('loginButtonsContainer');
        const googleLoginButton = document.getElementById('googleLoginButton');
        // const emailPasswordLoginButton = document.getElementById('emailPasswordLoginButton'); // Removed
        const messageBox = document.getElementById('messageBox');
        const logoutButton = document.getElementById('logoutButton');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const adminPanel = document.getElementById('adminPanel');

        const manageUsersButton = document.getElementById('manageUsersButton');
        const userManagementPanel = document.getElementById('userManagementPanel');
        const userRolesTableBody = document.getElementById('userRolesTableBody');
        const saveUserRolesButton = document.getElementById('saveUserRolesButton');
        const hideUserManagementButton = document.getElementById('hideUserManagementButton');

        // const viewLogsButton = document.getElementById('viewLogsButton'); // Removed
        // const logViewer = document.getElementById('logViewer'); // Removed
        // const logEntriesContainer = document.getElementById('logEntries'); // Removed
        // const clearLogsButton = document.getElementById('clearLogsButton'); // Removed
        // const hideLogsButton = document.getElementById('hideLogsButton'); // Removed

        const manageAccountButton = document.getElementById('manageAccountButton');
        const accountManagementPanel = document.getElementById('accountManagementPanel');
        const userProfilePic = document.getElementById('userProfilePic');
        const currentUserName = document.getElementById('currentUserName');
        const currentUserUsername = document.getElementById('currentUserUsername');
        const currentUserProvider = document.getElementById('currentUserProvider');
        const linkGoogleAccountButton = document.getElementById('linkGoogleAccountButton');
        const hideAccountManagementButton = document.getElementById('hideAccountManagementButton');

        const viewUserDirectoryButton = document.getElementById('viewUserDirectoryButton'); // Changed ID
        const userDirectoryPanel = document.getElementById('userDirectoryPanel'); 
        const userDirectoryTableBody = document.getElementById('userDirectoryTableBody'); 
        const hideUserDirectoryPanelButton = document.getElementById('hideUserDirectoryPanelButton');

        const openAdminPanelButton = document.getElementById('openAdminPanelButton');
        const openAccountManagementButton = document.getElementById('openAccountManagementButton');
        const closeAdminPanelButton = document.getElementById('closeAdminPanelButton');

        const manageGameRoomsButton = document.getElementById('manageGameRoomsButton');
        const gameRoomManagementPanel = document.getElementById('gameRoomManagementPanel');
        const newRoomNameInput = document.getElementById('newRoomNameInput');
        const createGameRoomButton = document.getElementById('createGameRoomButton');
        const gameRoomsListContainer = document.getElementById('gameRoomsListContainer');
        const closeGameRoomManagementPanelButton = document.getElementById('closeGameRoomManagementPanelButton');

        const joinGameButton = document.getElementById('joinGameButton');
        const playerJoinRoomPanel = document.getElementById('playerJoinRoomPanel');
        const availableRoomsListContainer = document.getElementById('availableRoomsListContainer');
        const closePlayerJoinRoomPanelButton = document.getElementById('closePlayerJoinRoomPanelButton');

        const gameRoomViewPanel = document.getElementById('gameRoomViewPanel');
        const gameRoomViewName = document.getElementById('gameRoomViewName');
        const roomPlayersListContainer = document.getElementById('roomPlayersListContainer');
        const leaveCurrentGameRoomButton = document.getElementById('leaveCurrentGameRoomButton');
        const closeGameRoomViewButton = document.getElementById('closeGameRoomViewButton');
        const playerBetInput = document.getElementById('playerBetInput');
        const playerChipCountForBet = document.getElementById('playerChipCountForBet');
        const placeBetButton = document.getElementById('placeBetButton');
        const callButton = document.getElementById('callButton'); // Added Call button
        const foldButton = document.getElementById('foldButton'); // Added Fold button
        const allInButton = document.getElementById('allInButton'); // Added All-In button

        // Admin Game Controls in Game Room View
        const adminGameControls = document.getElementById('adminGameControls');
        const adminRoomResetButton = document.getElementById('adminRoomResetButton');
        const adminUpdateChipsButton = document.getElementById('adminUpdateChipsButton');

        // Update Chips Panel Elements
        const updateChipsPanel = document.getElementById('updateChipsPanel');
        const updateChipsPlayerList = document.getElementById('updateChipsPlayerList');
        const cancelChipUpdate = document.getElementById('cancelChipUpdate');
        const submitChipUpdate = document.getElementById('submitChipUpdate');

        // Bulk User Action Buttons
        const setAllPlayerChipsButton = document.getElementById('setAllPlayerChipsButton');
        const forceLogoutAllUsersButton = document.getElementById('forceLogoutAllUsersButton');

        // Bulk Game Room Action Button
        const deleteAllGameRoomsButton = document.getElementById('deleteAllGameRoomsButton');

        // Investments Panel Elements
        // const investmentsButton = document.getElementById('investmentsButton');
        //const messagesButton = document.getElementById('messagesButton');
        const investmentsPanel = document.getElementById('investmentsPanel');
        const closeInvestmentsPanelButton = document.getElementById('closeInvestmentsPanelButton');
        const sharesTab = document.getElementById('shares-tab');
        const offersTab = document.getElementById('offers-tab');
        const sharesContent = document.getElementById('sharesContent');
        const offersContent = document.getElementById('offersContent');

        // Investment Offer Form Elements (Shares Tab)
        const offerInvestmentForm = document.getElementById('offerInvestmentForm');
        const investPlayerSelect = document.getElementById('investPlayerSelect');
        const maxInvestableChips = document.getElementById('maxInvestableChips'); // Span to show user's current chips
        const investChipAmount = document.getElementById('investChipAmount');
        const investPayoutPercent = document.getElementById('investPayoutPercent');
        const investHandsPayout = document.getElementById('investHandsPayout');
        const submitInvestmentOfferButton = document.getElementById('submitInvestmentOfferButton');
        
        // My Shares List Elements (Shares Tab)
        const mySharesListContainer = document.getElementById('mySharesListContainer');
        const mySharesList = document.getElementById('mySharesList');

        // Incoming Offers List Elements (Offers Tab)
        const incomingOffersListContainer = document.getElementById('incomingOffersListContainer');
        const incomingOffersList = document.getElementById('incomingOffersList');

        // My Investments as Investee List Elements (Offers Tab)
        const myInvestmentsAsInvesteeContainer = document.getElementById('myInvestmentsAsInvesteeContainer');
        const myInvestmentsAsInvesteeList = document.getElementById('myInvestmentsAsInvesteeList');

        // Messages Panel Elements
//        const messagesPanel = document.getElementById('messagesPanel');
//        const closeMessagesPanelButton = document.getElementById('closeMessagesPanelButton');
//        const playerSearchInput = document.getElementById('playerSearchInput');
//        const messagesPlayerList = document.getElementById('messagesPlayerList');
//        const chatHeader = document.getElementById('chatHeader');
//        const chatMessages = document.getElementById('chatMessages');
//        const messageInput = document.getElementById('messageInput');
//        const sendMessageButton = document.getElementById('sendMessageButton');

        // Group Chat Modal Elements
        const createGroupChatModal = document.getElementById('createGroupChatModal');
        const groupNameInput = document.getElementById('groupNameInput');
        const groupPlayerList = document.getElementById('groupPlayerList');
        const createGroupButton = document.getElementById('createGroupButton');
        const cancelGroupButton = document.getElementById('cancelGroupButton');
        const createGroupChatButton = document.getElementById('createGroupChatButton');


        // const logFilterType = document.getElementById('logFilterType'); // Removed
        // const logSearchText = document.getElementById('logSearchText'); // Removed
        // const logSortOrderRadios = document.querySelectorAll('input[name="logSortOrder"]'); // Removed

        let allFirebaseUsersData = []; // Stores user profiles fetched from Firestore
        let firestoreUserRoles = {}; // Stores roles fetched from Firestore
        // let firestoreActivityLogs = []; // Removed
        let firestoreActiveSessions = []; // Stores active sessions from Firestore
        let firestoreGameRooms = []; // Stores game rooms fetched from Firestore
        let firestoreInvestments = []; // Stores investments fetched from Firestore
        let firestoreMessages = [];
        let currentJoinedRoomId = null; // Stores the ID of the room the current player has joined

        const ROLES = ['disabled', 'player', 'admin', 'owner']; // Defined roles for the system


        // --- Role Helper Functions ---
        function getCurrentUserRole(uid) {
            if (!uid) return 'player'; // Default for cases where UID might be null
            return firestoreUserRoles[uid]?.role || 'player'; // Default to 'player'
        }

        function isOwner(uid) {
            if (!uid) return false;
            // SUPER_ADMIN_UID is always considered an owner for bootstrapping purposes.
            // Otherwise, explicit 'owner' role is required.
            return uid === SUPER_ADMIN_UID || getCurrentUserRole(uid) === 'owner';
        }

        function hasAdminAccess(uid) {
            if (!uid) return false;
            const role = getCurrentUserRole(uid);
            // SUPER_ADMIN_UID, 'owner', or 'admin' roles grant admin panel access.
            return uid === SUPER_ADMIN_UID || role === 'owner' || role === 'admin';
        }

        // --- Listener for Own Active Session (for remote/forced logout detection) ---
        function setupOwnActiveSessionListener(uid) {
            if (unsubscribeOwnActiveSessionListener) {
                console.log("Unsubscribing from previous own active session listener.");
                unsubscribeOwnActiveSessionListener(); 
                unsubscribeOwnActiveSessionListener = null;
            }

            if (!uid) {
                console.error("Cannot setup own active session listener without UID.");
                return; 
            }

            const sessionDocRef = doc(activeSessionsCollectionRef, uid);
            console.log(`Setting up listener for own active session: active_sessions/${uid}`);

            unsubscribeOwnActiveSessionListener = onSnapshot(sessionDocRef, (docSnap) => {
                console.log(`Own active session listener event: exists=${docSnap.exists()}`);
                if (!docSnap.exists()) {
                    // Document was deleted
                    console.log("Own active session document deleted, potentially by force logout or other means.");
                    if (auth.currentUser && auth.currentUser.uid === uid && !isLoggingOut) { 
                        // Check if still the same user and not already in the process of logging out
                        console.log("Current user matches and not already logging out. Initiating self-logout.");
                        isLoggingOut = true; // Set flag early to prevent race conditions/re-entry
                        showMessage("Your session has been ended remotely. You are now being logged out.", "info");
                        
                        if (unsubscribeOwnActiveSessionListener) {
                            console.log("Unsubscribing from own active session listener before forced logout.");
                            unsubscribeOwnActiveSessionListener();
                            unsubscribeOwnActiveSessionListener = null;
                        }

                        // Delay slightly to allow message to be seen, then logout
                        setTimeout(() => {
                            handleLogout(); 
                        }, 3000); 
                    } else {
                        console.log("Self-logout condition not met:", 
                                    {currentUser: auth.currentUser?.uid, targetUid: uid, isLoggingOutFlag: isLoggingOut});
                    }
                }
            }, (error) => {
                console.error(`Error listening to own active session (active_sessions/${uid}):`, error);
                // Optionally, inform the user if this critical listener fails
                // showMessage("Error: Could not monitor session status. Please refresh.", "error");
            });
        }


        // Firestore Collection References (implicitly pointing to 'user-data' database)
        const userRolesCollectionRef = collection(db, `artifacts/${appId}/public/data/user_roles`);
        const activityLogsCollectionRef = collection(db, `artifacts/${appId}/public/data/activity_logs`);
        const userProfilesCollectionRef = collection(db, `artifacts/${appId}/public/data/user_profiles`);
        const activeSessionsCollectionRef = collection(db, `artifacts/${appId}/public/data/active_sessions`);
        const gameRoomsCollectionRef = collection(db, `artifacts/${appId}/public/data/game_rooms`);
        const investmentsCollectionRef = collection(db, `artifacts/${appId}/public/data/investments`); // New collection for investments
        const messagesCollectionRef = collection(db, `artifacts/${appId}/public/data/messages`);


        // --- Utility Functions ---
        function showPanel(panelToShow) {
            const panelList = [
                {el: loginButtonsContainer, name: "loginButtonsContainer"},
                {el: adminPanel, name: "adminPanel"},
                {el: userManagementPanel, name: "userManagementPanel"},
                {el: accountManagementPanel, name: "accountManagementPanel"},
                {el: userDirectoryPanel, name: "userDirectoryPanel"},
                {el: gameRoomManagementPanel, name: "gameRoomManagementPanel"},
                {el: playerJoinRoomPanel, name: "playerJoinRoomPanel"},
                {el: gameRoomViewPanel, name: "gameRoomViewPanel"},
                {el: investmentsPanel, name: "investmentsPanel"}, // Added Investments Panel
//                {el: messagesPanel, name: "messagesPanel"},
                {el: loadingIndicator, name: "loadingIndicator"}
            ];

            panelList.forEach(item => {
                if (!item.el) {
                    console.warn(`showPanel: DOM element for '${item.name}' is null or undefined. Check ID and HTML.`);
                    return; // Skip this problematic panel
                }
                if (item.el === panelToShow) {
                    item.el.classList.remove('hidden');
                } else {
                    item.el.classList.add('hidden');
                }
            });
        }

        // --- Messages Panel Event Listeners ---
//        messagesButton.addEventListener('click', () => {
//            if (auth.currentUser) {
//                showPanel(messagesPanel);
//            } else {
//                showMessage("Please log in to access messages.", "info");
//                showPanel(loginButtonsContainer);
//            }
//        });

//        closeMessagesPanelButton.addEventListener('click', () => {
//            showPanel(null); // Return to neutral view
//        });

//        function renderMessagesPlayerList(filter = '') {
//            console.log("Rendering messages player list with filter:", filter);
//            if (!messagesPlayerList || !auth.currentUser) {
//                console.log("Cannot render player list: list element or user not available.");
//                return;
//            }

//            const currentUid = auth.currentUser.uid;
//            messagesPlayerList.innerHTML = '';

//            const filteredPlayers = allFirebaseUsersData
//                .filter(user => user.uid !== currentUid && getCurrentUserRole(user.uid) !== 'disabled' && formatDisplayName(user).toLowerCase().includes(filter.toLowerCase()))
//                .sort((a, b) => (formatDisplayName(a) || '').localeCompare(formatDisplayName(b) || ''));

//            const filteredGroups = firestoreMessages.filter(msg => msg.isGroup && msg.members.includes(currentUid) && msg.name.toLowerCase().includes(filter.toLowerCase()));

//            if (filteredPlayers.length === 0 && filteredGroups.length === 0) {
//                messagesPlayerList.innerHTML = '<p class="text-gray-500 p-3 text-center">No players or groups found.</p>';
//                return;
//            }

//            filteredGroups.forEach(group => {
//                const groupDiv = document.createElement('div');
//                groupDiv.className = 'p-2 hover:bg-gray-100 cursor-pointer rounded-md font-bold';
//                groupDiv.textContent = group.name;
//                groupDiv.setAttribute('data-gid', group.id);
//                messagesPlayerList.appendChild(groupDiv);
//            });

//            filteredPlayers.forEach(user => {
//                const playerDiv = document.createElement('div');
//                playerDiv.className = 'p-2 hover:bg-gray-100 cursor-pointer rounded-md';
//                playerDiv.textContent = formatDisplayName(user);
//                playerDiv.setAttribute('data-uid', user.uid);
//                messagesPlayerList.appendChild(playerDiv);
//            });
//        }

//        messagesButton.addEventListener('click', () => {
//            console.log("Messages button clicked.");
//            if (auth.currentUser) {
//                showPanel(messagesPanel);
//                renderMessagesPlayerList();
//            } else {
//                showMessage("Please log in to access messages.", "info");
//                showPanel(loginButtonsContainer);
//            }
//        });

//        playerSearchInput.addEventListener('input', (e) => {
//            renderMessagesPlayerList(e.target.value);
//        });

//        let currentChatId = null;
//        let unsubscribeMessagesListener = null;

//        onSnapshot(query(messagesCollectionRef), (snapshot) => {
//            console.log("Messages collection snapshot received.");
//            firestoreMessages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
//            console.log("Firestore messages:", firestoreMessages);
//            renderMessagesPlayerList(playerSearchInput.value);
//        });

//        messagesPlayerList.addEventListener('click', (e) => {
//            console.log("Player list clicked.");
//            if (e.target.matches('[data-uid]')) {
//                const otherPlayerId = e.target.getAttribute('data-uid');
//                const otherPlayerName = e.target.textContent;
//                const currentUid = auth.currentUser.uid;

//                currentChatId = [currentUid, otherPlayerId].sort().join('_');

//                chatHeader.innerHTML = `<h4 class="text-lg font-semibold text-gray-800">${otherPlayerName}</h4>`;

//                if (unsubscribeMessagesListener) {
//                    unsubscribeMessagesListener();
//                }

//                const q = query(collection(db, `messages/${currentChatId}/messages`), orderBy("timestamp"));
//                unsubscribeMessagesListener = onSnapshot(q, (snapshot) => {
//                    chatMessages.innerHTML = '';
//                    snapshot.forEach(doc => {
//                        const message = doc.data();
//                        const messageDiv = document.createElement('div');
//                        messageDiv.textContent = message.text;
//                        const isSender = message.senderId === currentUid;
//                        messageDiv.className = `p-2 my-1 rounded-lg ${isSender ? 'bg-blue-500 text-white self-end' : 'bg-gray-200 text-gray-800 self-start'}`;
//                        chatMessages.appendChild(messageDiv);
//                    });
//                    chatMessages.scrollTop = chatMessages.scrollHeight;
//                });
//            } else if (e.target.matches('[data-gid]')) {
//                const groupId = e.target.getAttribute('data-gid');
//                const groupName = e.target.textContent;
//                const currentUid = auth.currentUser.uid;

//                currentChatId = groupId;

//                chatHeader.innerHTML = `<h4 class="text-lg font-semibold text-gray-800">${groupName}</h4>`;

//                if (unsubscribeMessagesListener) {
//                    unsubscribeMessagesListener();
//                }

//                const q = query(collection(db, `messages/${currentChatId}/messages`), orderBy("timestamp"));
//                unsubscribeMessagesListener = onSnapshot(q, (snapshot) => {
//                    chatMessages.innerHTML = '';
//                    snapshot.forEach(doc => {
//                        const message = doc.data();
//                        const messageDiv = document.createElement('div');
//                        const senderName = allFirebaseUsersData.find(p => p.uid === message.senderId)?.displayName || 'Unknown';
//                        messageDiv.textContent = `${senderName}: ${message.text}`;
//                        const isSender = message.senderId === currentUid;
//                        messageDiv.className = `p-2 my-1 rounded-lg ${isSender ? 'bg-blue-500 text-white self-end' : 'bg-gray-200 text-gray-800 self-start'}`;
//                        chatMessages.appendChild(messageDiv);
//                    });
//                    chatMessages.scrollTop = chatMessages.scrollHeight;
//                });
//            }
//        });

//        sendMessageButton.addEventListener('click', async () => {
//            const text = messageInput.value.trim();
//            if (text && currentChatId) {
//                await addDoc(collection(db, `messages/${currentChatId}/messages`), {
//                    text,
//                    senderId: auth.currentUser.uid,
//                    timestamp: serverTimestamp()
//                });
//                messageInput.value = '';
//            }
//        });

//        createGroupChatButton.addEventListener('click', () => {
//            createGroupChatModal.classList.remove('hidden');
//            renderGroupPlayerList();
//        });

//        cancelGroupButton.addEventListener('click', () => {
//            createGroupChatModal.classList.add('hidden');
//        });

//        function renderGroupPlayerList() {
//            if (!groupPlayerList || !auth.currentUser) return;

//            const currentUid = auth.currentUser.uid;
//            groupPlayerList.innerHTML = '';

//            const availablePlayers = allFirebaseUsersData
//                .filter(user => user.uid !== currentUid && getCurrentUserRole(user.uid) !== 'disabled')
//                .sort((a, b) => (formatDisplayName(a) || '').localeCompare(formatDisplayName(b) || ''));

//            if (availablePlayers.length === 0) {
//                groupPlayerList.innerHTML = '<p class="text-gray-500 p-3 text-center">No other players available.</p>';
//                return;
//            }

//            availablePlayers.forEach(user => {
//                const playerDiv = document.createElement('div');
//                playerDiv.className = 'flex items-center p-2 hover:bg-gray-100 rounded-md';
//                const checkbox = document.createElement('input');
//                checkbox.type = 'checkbox';
//                checkbox.value = user.uid;
//                checkbox.className = 'mr-2';
//                playerDiv.appendChild(checkbox);
//                const label = document.createElement('label');
//                label.textContent = formatDisplayName(user);
//                playerDiv.appendChild(label);
//                groupPlayerList.appendChild(playerDiv);
//            });
//        }

//        createGroupButton.addEventListener('click', async () => {
//            const groupName = groupNameInput.value.trim();
//            if (!groupName) {
//                showMessage("Please enter a group name.", "error");
//                return;
//            }

//            const selectedPlayers = Array.from(groupPlayerList.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value);
//            if (selectedPlayers.length === 0) {
//                showMessage("Please select at least one player.", "error");
//                return;
//            }
//
//            const members = [auth.currentUser.uid, ...selectedPlayers];
//            const groupChatId = `group_${new Date().getTime()}`;

//            await setDoc(doc(db, "messages", groupChatId), {
//                name: groupName,
//                members: members,
//                isGroup: true
//            });

//            createGroupChatModal.classList.add('hidden');
//            groupNameInput.value = '';
//        });

        function showMessage(message, type = 'error') {
            messageBox.textContent = message;
            messageBox.className = `message-box ${type} w-full`;
            messageBox.classList.remove('hidden');
            setTimeout(hideMessage, 5000); // Auto-hide messages after 5 seconds
        }

        function hideMessage() {
            messageBox.classList.add('hidden');
        }

        // --- Helper function to format display names ---
        function formatDisplayName(user) {
            if (!user || typeof user.displayName !== 'string' || typeof user.email !== 'string') {
                // Return a fallback if essential user properties are missing or not strings
                return (user && typeof user.displayName === 'string') ? user.displayName : (user && typeof user.email === 'string' ? user.email : 'N/A');
            }

            let displayName = user.displayName;
            // Ensure email is present and is a string before trying to operate on it
            if (user.email && typeof user.email === 'string') {
                const emailParts = user.email.split('@');
                if (emailParts.length === 2) {
                    const emailDomain = emailParts[1].toLowerCase();
                    if (emailDomain === 'wrsdk12.net') {
                        if (!displayName.endsWith(" (School)")) {
                            displayName += " (School)";
                        }
                    }
                }
            }
            return displayName;
        }


        // --- Log System Functions (Firestore Integrated) ---
        // addLogEntry function and its calls are being removed.

        // Log-related functions populateLogFilterTypes, renderLogs, clearLogs REMOVED.
        
        // --- End Log System Functions ---


        // --- User Management Functions (Firestore Integrated) ---
        async function saveUserChangesToFirestore(changesMap) { // Renamed and updated parameter
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to save user changes.", 'error');
                // addLogEntry("Save User Changes Attempt Failed", { reason: "Permission denied", by: auth.currentUser?.uid }); // Removed
                return;
            }

            const currentUserIsOwner = isOwner(auth.currentUser.uid);
            showMessage("Saving user changes...", 'info');

            try {
                // Fetch current roles and profiles for robust old value checks and to avoid unnecessary writes.
                const rolesSnapshot = await getDocs(userRolesCollectionRef);
                const currentFirestoreRoles = {};
                rolesSnapshot.forEach(doc => currentFirestoreRoles[doc.id] = doc.data());

                const profilesSnapshot = await getDocs(userProfilesCollectionRef);
                const currentFirestoreProfiles = {};
                profilesSnapshot.forEach(doc => currentFirestoreProfiles[doc.id] = doc.data());

                for (const uid in changesMap) {
                    const { newRole, newChipCount } = changesMap[uid];
                    const oldRole = currentFirestoreRoles[uid]?.role || 'player';
                    const oldChipCount = currentFirestoreProfiles[uid]?.chip_count; // Can be undefined or number

                    let roleChanged = oldRole !== newRole;
                    // Chip count comparison needs to handle undefined and ensure numeric comparison
                    let chipCountChanged = typeof oldChipCount === 'undefined' || oldChipCount !== newChipCount;
                    if (typeof newChipCount !== 'number') { // Ensure newChipCount is a number before saving
                        showMessage(`Invalid chip count for user ${uid}. Must be a number.`, 'error');
                        // addLogEntry("Invalid Chip Count Input", {targetUser: uid, value: newChipCount}); // Removed
                        continue; // Skip this user if chip count is not a number
                    }


                    // **Permission Checks**
                    // These apply to both role and chip count changes for simplicity unless specific fine-grained control is needed.
                    // If a user cannot have their role changed, they likely shouldn't have chip count changed by that admin either.

                    // 0. SUPER_ADMIN_UID: Role must be 'owner', chip count cannot be changed by non-owners (effectively, should not be changed by anyone but system/self if needed)
                    if (uid === SUPER_ADMIN_UID) {
                        if (newRole !== 'owner') {
                            showMessage(`SUPER_ADMIN (${uid}) role cannot be changed from 'owner'.`, 'error');
                            // addLogEntry("SUPER_ADMIN Role Change Blocked", { attemptedRole: newRole, by: auth.currentUser.uid }); // Removed
                            roleChanged = false; // Do not proceed with role change
                        }
                        // For SUPER_ADMIN, only allow chip count change if current user is owner (which SUPER_ADMIN is).
                        // Effectively, this means SUPER_ADMIN can change their own chips if UI allowed, or another owner could.
                        // But generally, we want to protect SUPER_ADMIN from accidental changes by other admins.
                        // The UI already disables these fields if current user is not owner.
                        // This server-side check ensures it.
                        if (!currentUserIsOwner && chipCountChanged) {
                             showMessage(`Chip count for SUPER_ADMIN (${uid}) cannot be changed by non-owners.`, 'error');
                             // addLogEntry("SUPER_ADMIN Chip Count Change Blocked", { by: auth.currentUser.uid }); // Removed
                             chipCountChanged = false; // Do not proceed
                        }
                    }
                    // 1. Only an owner can assign the 'owner' role.
                    else if (newRole === 'owner' && !currentUserIsOwner) {
                        showMessage(`You do not have permission to assign 'owner' role to ${uid}.`, 'error');
                        // addLogEntry("Assign Owner Role Failed", { targetUser: uid, by: auth.currentUser.uid }); // Removed
                        roleChanged = false;
                    }
                    // 2. An admin cannot change an owner's role or chip count. Only another owner can.
                    else if (oldRole === 'owner' && !currentUserIsOwner) {
                        if (roleChanged) {
                            showMessage(`You do not have permission to change role of owner ${uid}.`, 'error');
                            // addLogEntry("Modify Owner Role Failed", { targetUser: uid, by: auth.currentUser.uid }); // Removed
                            roleChanged = false;
                        }
                        if (chipCountChanged) {
                            showMessage(`You do not have permission to change chip count of owner ${uid}.`, 'error');
                            // addLogEntry("Modify Owner Chip Count Failed", { targetUser: uid, by: auth.currentUser.uid }); // Removed
                            chipCountChanged = false;
                        }
                    }
                    // 3. Prevent last owner from demoting themselves (SUPER_ADMIN is a fallback).
                    else if (uid === auth.currentUser.uid && currentUserIsOwner && (newRole === 'disabled' || newRole === 'player' || newRole === 'admin')) {
                        const ownersInFirestore = Object.keys(currentFirestoreRoles).filter(id => currentFirestoreRoles[id]?.role === 'owner');
                        // Check against currentFirestoreRoles which is fresh from DB
                        if (ownersInFirestore.length === 1 && ownersInFirestore[0] === uid && uid !== SUPER_ADMIN_UID) {
                           showMessage("Cannot demote the last owner. Assign 'owner' to another user first.", 'error');
                           // addLogEntry("Last Owner Demotion Blocked", { user: uid, newRole: newRole }); // Removed
                           roleChanged = false;
                        }
                    }

                    // Proceed with updates if changes are valid and permissible
                    if (roleChanged) {
                        const roleDocRef = doc(userRolesCollectionRef, uid);
                        await setDoc(roleDocRef, { role: newRole }, { merge: true });
                        // addLogEntry("User Role Changed", { targetUser: uid, oldRole, newRole, by: auth.currentUser.email }); // Removed
                    }

                    if (chipCountChanged && typeof newChipCount === 'number') { // Double check it's a number
                        const roundedChipCount = Math.round(newChipCount);
                        const profileDocRef = doc(userProfilesCollectionRef, uid);
                        await setDoc(profileDocRef, { chip_count: roundedChipCount }, { merge: true });
                        // addLogEntry("User Chip Count Changed", { targetUser: uid, oldChipCount: oldChipCount === undefined ? "N/A" : oldChipCount, newChipCount: roundedChipCount, by: auth.currentUser.email }); // Removed
                    }
                }
                showMessage("User changes processed and saved to Firestore.", 'success');
            } catch (e) {
                console.error("Error saving user changes to Firestore:", e);
                showMessage("Failed to save user changes.", 'error');
            }
        }

        async function editPendingOffer(investmentId) {
            if (!auth.currentUser) {
                showMessage("You must be logged in to edit an offer.", "error");
                return;
            }
            const currentUid = auth.currentUser.uid;
            const investment = firestoreInvestments.find(inv => inv.id === investmentId);

            if (!investment) {
                showMessage("Investment offer not found.", "error");
                return;
            }

            if (investment.investorUid !== currentUid) {
                showMessage("You are not authorized to edit this offer.", "error");
                return;
            }

            if (investment.status !== 'pending_investee_action') {
                showMessage("This offer can only be edited if it's pending investee action.", "info");
                return;
            }

            // Allow editing even if there are messages, as per simplified flow.
            // Messages will be cleared upon successful edit.

            const newOfferAmountStr = prompt("Enter new offer amount:", investment.offerAmount);
            if (newOfferAmountStr === null) return; // User cancelled
            const newOfferAmount = parseInt(newOfferAmountStr, 10);

            const newPayoutPercentStr = prompt("Enter new requested payout percentage (1-100%):", investment.requestedPayoutPercent);
            if (newPayoutPercentStr === null) return;
            const newPayoutPercent = parseInt(newPayoutPercentStr, 10);

            const newHandsPayoutStr = prompt("Enter new hands until payout:", investment.handsForPayout);
            if (newHandsPayoutStr === null) return;
            const newHandsPayout = parseInt(newHandsPayoutStr, 10);

            // Validation for new values
            const investorProfile = allFirebaseUsersData.find(p => p.uid === currentUid);
            const investorChips = investorProfile ? (investorProfile.chip_count || 0) : 0;

            if (isNaN(newOfferAmount) || newOfferAmount <= 0) {
                showMessage("Invalid new offer amount.", "error");
                return;
            }
            if (newOfferAmount > investorChips) {
                showMessage("You do not have enough chips for this new offer amount.", "error");
                return;
            }
            if (isNaN(newPayoutPercent) || newPayoutPercent <= 0 || newPayoutPercent > 100) {
                showMessage("Invalid new payout percentage (must be 1-100).", "error");
                return;
            }
            if (isNaN(newHandsPayout) || newHandsPayout <= 0) {
                showMessage("Invalid new number of hands for payout.", "error");
                return;
            }

            showMessage("Updating investment offer...", "info");
            const investmentDocRef = doc(investmentsCollectionRef, investmentId);
            try {
                await updateDoc(investmentDocRef, {
                    offerAmount: newOfferAmount,
                    requestedPayoutPercent: newPayoutPercent,
                    handsForPayout: newHandsPayout,
                    handsRemaining: newHandsPayout, // Reset handsRemaining as well
                    investorMessage: "", // Clear investor message upon successful edit
                    investeeMessage: "", // Clear investee message upon successful edit
                    lastUpdated: serverTimestamp()
                    // Status remains 'pending_investee_action'
                });
                showMessage("Investment offer updated successfully. Investee will see the new terms.", "success");
                // UI will update via Firestore listener.
            } catch (error) {
                console.error("Error updating investment offer:", error);
                showMessage(`Failed to update offer: ${error.message}`, "error");
            }
        }

        async function amendInvestment(investmentId) {
            if (!auth.currentUser) {
                showMessage("You must be logged in to amend an investment.", "error");
                return;
            }
            const currentUid = auth.currentUser.uid;
            const investment = firestoreInvestments.find(inv => inv.id === investmentId);

            if (!investment) {
                showMessage("Investment offer not found.", "error");
                return;
            }

            if (investment.investeeUid !== currentUid) {
                showMessage("You are not authorized to amend this investment.", "error");
                return;
            }

            if (investment.status !== 'pending_investee_action') {
                showMessage(`This investment cannot be amended at this time (Status: ${investment.status}).`, "info");
                return;
            }

            const amendmentMessage = prompt("Enter your amendment message to the investor (e.g., suggest different terms):");

            if (amendmentMessage === null) { // User cancelled the prompt
                return; // Do nothing if prompt is cancelled
            }

            if (!amendmentMessage.trim()) {
                showMessage("Amendment message cannot be empty if you choose to submit.", "error");
                return;
            }

            showMessage("Submitting your amendment...", "info");
            const investmentDocRef = doc(investmentsCollectionRef, investmentId);

            try {
                await updateDoc(investmentDocRef, {
                    // Status remains 'pending_investee_action'
                    investeeMessage: amendmentMessage,
                    lastUpdated: serverTimestamp()
                });
                showMessage("Feedback submitted to the investor. They may choose to edit their offer or cancel it.", "success");
                // UI will update via Firestore listener, which calls renderIncomingOffersList.
            } catch (error) {
                console.error("Error submitting amendment:", error);
                showMessage(`Failed to submit amendment: ${error.message}`, "error");
            }
        }

        async function cancelPendingOffer(investmentId) {
            if (!auth.currentUser) {
                showMessage("You must be logged in to cancel an offer.", "error");
                return;
            }
            const currentUid = auth.currentUser.uid;
            const investment = firestoreInvestments.find(inv => inv.id === investmentId);

            if (!investment) {
                showMessage("Investment offer not found.", "error");
                return;
            }

            if (investment.investorUid !== currentUid) {
                showMessage("You are not authorized to cancel this offer.", "error");
                return;
            }

            if (investment.status !== 'pending_investee_action' && investment.status !== 'pending_investor_action') {
                showMessage(`This offer cannot be cancelled (Status: ${investment.status}). It must be pending action.`, "info");
                return;
            }

            if (!confirm("Are you sure you want to cancel this investment offer?")) {
                return;
            }

            showMessage("Cancelling investment offer...", "info");
            const investmentDocRef = doc(investmentsCollectionRef, investmentId);

            try {
                await updateDoc(investmentDocRef, {
                    status: 'cancelled_by_investor',
                    lastUpdated: serverTimestamp()
                });
                showMessage("Investment offer cancelled.", "success");
                // UI will update via Firestore listener.
            } catch (error) {
                console.error("Error cancelling investment offer:", error);
                showMessage(`Failed to cancel offer: ${error.message}`, "error");
            }
        }

        async function declineInvestment(investmentId) {
            if (!auth.currentUser) {
                showMessage("You must be logged in to decline an investment.", "error");
                return;
            }
            const currentUid = auth.currentUser.uid;
            const investment = firestoreInvestments.find(inv => inv.id === investmentId);

            if (!investment) {
                showMessage("Investment offer not found.", "error");
                return;
            }

            if (investment.investeeUid !== currentUid) {
                showMessage("You are not authorized to decline this investment.", "error");
                return;
            }

            if (investment.status !== 'pending_investee_action') {
                showMessage(`This investment is no longer pending your action (Status: ${investment.status}).`, "info");
                return;
            }

            showMessage("Declining investment offer...", "info");
            const investmentDocRef = doc(investmentsCollectionRef, investmentId);

            try {
                await updateDoc(investmentDocRef, {
                    status: 'declined_by_investee',
                    lastUpdated: serverTimestamp()
                });
                showMessage("Investment offer declined.", "success");
                // UI will update via Firestore listener.
            } catch (error) {
                console.error("Error declining investment:", error);
                showMessage(`Failed to decline investment: ${error.message}`, "error");
            }
        }

        async function adminPlaceBetForPlayer(roomId, targetPlayerId, targetPlayerName, currentChips) {
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to place bets for players.", "error");
                return;
            }

            const targetPlayerCurrentStatus = firestoreGameRooms.find(r => r.id === roomId)?.playerStatuses?.[targetPlayerId];
            if (targetPlayerCurrentStatus === 'folded' || targetPlayerCurrentStatus === 'all-in') {
                showMessage(`Cannot place bet for ${targetPlayerName}; player is ${targetPlayerCurrentStatus}.`, "info");
                return;
            }
            
            const betAmountString = prompt(`Enter bet amount for ${targetPlayerName} (current chips: ${currentChips}):`);
            if (betAmountString === null) { // User cancelled prompt
                return;
            }

            const betAmount = parseInt(betAmountString, 10);

            if (isNaN(betAmount) || betAmount <= 0) {
                showMessage("Invalid bet amount. Please enter a positive number.", "error");
                return;
            }

            // Validate against player's actual chip count from their profile
            const targetUserProfile = allFirebaseUsersData.find(p => p.uid === targetPlayerId);
            const targetPlayerTotalChips = targetUserProfile ? (targetUserProfile.chip_count ?? 0) : 0;

            if (betAmount > targetPlayerTotalChips) {
                showMessage(`${targetPlayerName} does not have enough chips (has ${targetPlayerTotalChips}). Bet cannot exceed this amount.`, "error");
                return;
            }

            showMessage(`Placing bet of ${betAmount} for ${targetPlayerName}...`, "info");
            const roomDocRef = doc(gameRoomsCollectionRef, roomId);

            try {
                const roomSnap = await getDoc(roomDocRef);
                if (!roomSnap.exists()) {
                    showMessage("Error: Room data not found.", "error");
                    return;
                }
                const roomData = roomSnap.data();
                const currentHighestBetInRoom = Object.values(roomData.currentBets || {}).reduce((max, bet) => Math.max(max, bet), 0);

                let action = 'admin_bet'; // Default action
                if (betAmount > currentHighestBetInRoom && currentHighestBetInRoom > 0) {
                    action = 'admin_raise';
                } else if (betAmount === currentHighestBetInRoom && currentHighestBetInRoom > 0) {
                    action = 'admin_call';
                }

                let newStatus = 'ready';
                if (betAmount < currentHighestBetInRoom && currentHighestBetInRoom > 0) {
                    // This case should ideally be handled by admin consciously or UI should guide better.
                    // For now, if admin sets a bet lower than current highest, it's like an incomplete call.
                    // The player would still be 'pending' based on player card rendering logic.
                    // So, we can set 'pending' here, or let the rendering logic derive it.
                    // Let's assume admin action makes them 'ready' up to their bet, rendering logic will show 'pending' if needed.
                }
                 if (betAmount === targetPlayerTotalChips) { // If admin bets all player's chips
                    newStatus = 'all-in';
                    action = 'admin_all_in';
                }


                const updates = {
                    [`currentBets.${targetPlayerId}`]: betAmount,
                    [`playerStatuses.${targetPlayerId}`]: newStatus,
                    [`playerLastActions.${targetPlayerId}`]: action
                };
                await updateDoc(roomDocRef, updates);
                showMessage(`Bet of ${betAmount} placed for ${targetPlayerName}.`, "success");
                // UI will update via Firestore listener.
            } catch (error) {
                console.error(`Error placing bet for player ${targetPlayerId}:`, error);
                showMessage(`Failed to place bet for player: ${error.message}`, "error");
            }
        }

        async function adminForceFoldPlayer(roomId, targetPlayerId, targetPlayerName) {
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to force fold players.", "error");
                return;
            }
            if (targetPlayerId === auth.currentUser.uid) {
                showMessage("You cannot force fold yourself.", "info");
                return;
            }

            if (!confirm(`Are you sure you want to force fold ${targetPlayerName || 'this player'}?`)) {
                return;
            }

            showMessage(`Forcing ${targetPlayerName || 'player'} to fold...`, "info");
            const roomDocRef = doc(gameRoomsCollectionRef, roomId);
            try {
                const updates = {
                    [`playerStatuses.${targetPlayerId}`]: 'folded',
                    [`playerLastActions.${targetPlayerId}`]: 'admin_folded'
                    // Player's currentBet remains as it was, as is typical for a fold.
                };
                await updateDoc(roomDocRef, updates);
                showMessage(`${targetPlayerName || 'Player'} has been folded.`, "success");
                // UI will update via Firestore listener.
            } catch (error) {
                console.error(`Error force folding player ${targetPlayerId}:`, error);
                showMessage(`Failed to force fold player: ${error.message}`, "error");
            }
        }

        async function adminRemovePlayer(roomId, targetPlayerId, targetPlayerName) {
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to remove players.", "error");
                return;
            }

            if (targetPlayerId === auth.currentUser.uid) {
                showMessage("You cannot remove yourself using this admin action. Please use the 'Leave Room' button.", "info");
                return;
            }

            if (!confirm(`Are you sure you want to remove ${targetPlayerName || 'this player'} from the room?`)) {
                return;
            }

            showMessage(`Removing ${targetPlayerName || 'player'}...`, "info");
            const roomDocRef = doc(gameRoomsCollectionRef, roomId);
            try {
                // To remove fields from maps, we need FieldValue.delete()
                // It's imported with: import { ..., FieldValue } from "firebase/firestore";
                // However, FieldValue is not directly available in the global firebase object when using compat version.
                // For modular SDK, it needs to be imported. Since we are using modular SDK,
                // we need to ensure `deleteField` (the v9 equivalent) is available.
                // It's `import { ..., deleteField } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";`
                // Let's assume `deleteField` is available globally or correctly imported.
                // If not, this will cause an error and we'll need to add `deleteField` to the import list.

                // For now, let's try with direct update and arrayRemove.
                // Removing map entries is trickier without FieldValue.delete() or equivalent.
                // A common workaround if FieldValue.delete() isn't readily usable is to set the field to null or a special marker,
                // or fetch the document, modify the map in JS, and overwrite the map.
                // Given our current structure, arrayRemove is for arrays. For maps, we update the specific keys.

                const updates = {
                    players: arrayRemove(targetPlayerId), // Remove from players array
                    [`currentBets.${targetPlayerId}`]: deleteField(),
                    [`playerStatuses.${targetPlayerId}`]: deleteField(),
                    [`playerLastActions.${targetPlayerId}`]: deleteField()
                };

                await updateDoc(roomDocRef, updates);

                // Also delete their active session to force a UI update/kick for them
                try {
                    const activeSessionRef = doc(activeSessionsCollectionRef, targetPlayerId);
                    await deleteDoc(activeSessionRef);
                    console.log(`Active session for player ${targetPlayerId} deleted by admin removal.`);
                } catch (sessionError) {
                    console.error(`Error deleting active session for removed player ${targetPlayerId}:`, sessionError);
                    // Non-critical for the removal itself, but log it.
                    // The player might not get immediately kicked from UI if this fails, but they are out of the room data-wise.
                }

                showMessage(`${targetPlayerName || 'Player'} has been removed from the room and their session ended.`, "success");
                // The room view will update via Firestore listener.
            } catch (error) {
                console.error(`Error removing player ${targetPlayerId}:`, error);
                showMessage(`Failed to remove player: ${error.message}`, "error");
            }
        }

        async function handlePlaceBet(roomId) {
            if (!auth.currentUser) {
                showMessage("You must be logged in to place a bet.", "error");
                return;
            }
            const userId = auth.currentUser.uid;
            const betAmountString = playerBetInput.value.trim();
            const betAmount = parseInt(betAmountString, 10);

            const currentUserProfile = allFirebaseUsersData.find(p => p.uid === userId);
            const currentPlayerChips = currentUserProfile ? (currentUserProfile.chip_count ?? 0) : 0;

            // Validation
            if (isNaN(betAmount) || betAmount <= 0) {
                showMessage("Please enter a valid positive bet amount.", "error");
                return;
            }
            if (betAmount > currentPlayerChips) {
                showMessage("You cannot bet more chips than you have.", "error");
                return;
            }

            const roomDocRef = doc(gameRoomsCollectionRef, roomId);
            showMessage("Placing your bet...", "info");

            try {
                // Determine current highest bet in the room to decide if it's a bet, call, or raise.
                // This requires fetching the room data first, or having it available.
                // For simplicity in this step, we'll assume any bet sets status to 'ready' and action to 'bet'.
                // More complex logic (call/raise determination) will be handled in later UI steps or refined here.
                const roomSnap = await getDoc(roomDocRef);
                if (!roomSnap.exists()) {
                    showMessage("Error: Room data not found for placing bet.", "error");
                    return;
                }
                const roomData = roomSnap.data();
                const currentHighestBet = Object.values(roomData.currentBets || {}).reduce((max, bet) => Math.max(max, bet), 0);
                
                let action = 'bet'; // Default action
                if (betAmount > currentHighestBet && currentHighestBet > 0) {
                    action = 'raise';
                } else if (betAmount === currentHighestBet && currentHighestBet > 0) {
                    action = 'call';
                } else if (betAmount > 0 && currentHighestBet === 0) {
                    action = 'bet'; // Opening bet
                }


                // Update Firestore document
                const updates = {
                    [`currentBets.${userId}`]: betAmount,
                    [`playerStatuses.${userId}`]: 'ready', // Assuming betting makes you 'ready' for now
                    [`playerLastActions.${userId}`]: action 
                };
                await updateDoc(roomDocRef, updates);
                
                showMessage(`Bet of ${betAmount} (${action}) placed successfully!`, "success");
                playerBetInput.value = ''; // Clear input

                // Note: Actual chip deduction from player's profile is NOT handled here yet.
                // That will be part of the "All-In" implementation or a more general chip management logic.
            } catch (error) {
                console.error("Error placing bet:", error);
                showMessage(`Failed to place bet: ${error.message}`, "error");
            }
        }

        async function handleLeaveRoom(roomId) {
            if (!auth.currentUser) {
                showMessage("You must be logged in to leave a room.", "error");
                return;
            }
            const userId = auth.currentUser.uid;

            if (roomId === currentJoinedRoomId) {
                currentJoinedRoomId = null; // Clear the joined room state
            }

            const roomDocRef = doc(gameRoomsCollectionRef, roomId);
            showMessage("Leaving room...", "info");
            try {
                await updateDoc(roomDocRef, {
                    players: arrayRemove(userId)
                });
                showMessage("You have left the room.", "success");
                showPanel(playerJoinRoomPanel); // Navigate back to the lobby/room list
                // Other UI (like User Directory status) will update via Firestore listeners.
            } catch (error) {
                console.error("Error leaving room:", error);
                showMessage(`Failed to leave room: ${error.message}`, "error");
                // If failed, re-render current view in case it was from gameRoomViewPanel
                if(gameRoomViewPanel && !gameRoomViewPanel.classList.contains('hidden') && currentJoinedRoomId === roomId) {
                    renderGameRoomView(roomId);
                } else {
                     renderAvailableRoomsList(); // Or refresh available rooms list if called from there
                }
            }
        }

        function renderUserRolesTable() {
            userRolesTableBody.innerHTML = '';
            
            if (allFirebaseUsersData.length === 0) {
                userRolesTableBody.innerHTML = '<tr><td colspan="4" class="text-center text-gray-500 py-4">No users found. Users will appear here after they log in.</td></tr>'; // Colspan updated
                return;
            }

            const currentUserId = auth.currentUser?.uid;
            const activeSessionUIDs = firestoreActiveSessions.map(session => session.id); // Get active UIDs
            const currentUserIsAdminOrOwner = hasAdminAccess(currentUserId);
            const currentUserIsOwner = isOwner(currentUserId);


            allFirebaseUsersData.sort((a, b) => (a.displayName || '').localeCompare(b.displayName || '')); // Sort by display name

            allFirebaseUsersData.forEach(user => {
                const row = userRolesTableBody.insertRow();
                const displayNameCell = row.insertCell();
                const chipCountCell = row.insertCell(); // New cell for chip count
                const userRoleCell = row.insertCell();

                displayNameCell.textContent = formatDisplayName(user); // Use helper to format display name

                // Chip count input
                const chipInput = document.createElement('input');
                chipInput.type = 'number';
                chipInput.className = 'border rounded-lg p-1 w-20 text-sm'; // Added w-20 for width
                chipInput.setAttribute('data-uid', user.uid);
                chipInput.setAttribute('name', `chip_count_${user.uid}`);
                chipInput.value = (typeof user.chip_count === 'number') ? user.chip_count : 0;
                chipCountCell.appendChild(chipInput);

                // Role select dropdown
                const select = document.createElement('select');
                select.className = 'border rounded-lg p-1 text-sm';
                select.setAttribute('data-uid', user.uid);
                select.setAttribute('name', `role_${user.uid}`);


                const userCurrentRole = getCurrentUserRole(user.uid);

                ROLES.forEach(role => {
                    const option = document.createElement('option');
                    option.value = role;
                    option.textContent = role;
                    select.appendChild(option);
                });

                select.value = userCurrentRole;

                // **Disable select element and chip input based on permissions**
                let disableRoleSelect = false;
                let disableChipInput = false;

                // 1. If current user doesn't have admin access at all, all fields are disabled.
                if (!currentUserIsAdminOrOwner) {
                    disableRoleSelect = true;
                    disableChipInput = true;
                } else {
                    // 2. SUPER_ADMIN_UID's role dropdown should always be disabled.
                    //    Chip input for SUPER_ADMIN_UID can be edited by an owner.
                    if (user.uid === SUPER_ADMIN_UID) {
                        disableRoleSelect = true;
                        select.value = 'owner'; // Visually reflect owner status
                        if (!currentUserIsOwner) { // Non-owners cannot edit SUPER_ADMIN's chips
                            disableChipInput = true;
                        }
                    }
                    // 3. If the target user is an 'owner' and the current user is not an 'owner' (and target is not SUPER_ADMIN, handled above)
                    //    (Admins cannot change other Owners' roles or chip counts).
                    else if (userCurrentRole === 'owner' && !currentUserIsOwner) {
                        disableRoleSelect = true;
                        disableChipInput = true;
                    }
                }
                select.disabled = disableRoleSelect;
                chipInput.disabled = disableChipInput;

                // Specific option disabling for roles (doesn't apply to chip_count input directly)
                // Disable the 'owner' role option if the current user is not an owner.
                if (!currentUserIsOwner) {
                    const ownerOption = select.querySelector('option[value="owner"]');
                    if (ownerOption) {
                        ownerOption.disabled = true;
                    }
                }

                // Prevent last owner from disabling/demoting self via dropdown directly (UI hint)
                // This is a UI hint; server-side/save function has the definitive check.
                if (user.uid === currentUserId && currentUserIsOwner) {
                    const ownersInFirestore = Object.keys(firestoreUserRoles).filter(id => firestoreUserRoles[id]?.role === 'owner');
                    if (ownersInFirestore.length === 1 && ownersInFirestore[0] === user.uid && user.uid !== SUPER_ADMIN_UID) {
                        ['disabled', 'player', 'admin'].forEach(roleToDisable => {
                            const option = select.querySelector(`option[value="${roleToDisable}"]`);
                            if (option) option.disabled = true;
                        });
                    }
                }


                userRoleCell.appendChild(select);

                // Actions cell
                const actionsCell = row.insertCell();
                const forceLogoutButton = document.createElement('button');
                forceLogoutButton.textContent = 'Force Logout';
                forceLogoutButton.className = 'bg-red-500 hover:bg-red-700 text-white text-xs py-1 px-2 rounded disabled:opacity-50 disabled:cursor-not-allowed';
                
                const targetUserRole = userCurrentRole; // Role of the user in the row
                const targetUserIsOnline = activeSessionUIDs.includes(user.uid);

                let disableLogoutButton = false;

                if (user.uid === currentUserId) { // Cannot logout self
                    disableLogoutButton = true;
                } else if (!targetUserIsOnline) { // Cannot logout an offline user
                    disableLogoutButton = true;
                } else {
                    if (currentUserIsOwner) {
                        // Owners can log out anyone (except self, handled above)
                        disableLogoutButton = false;
                    } else if (currentUserIsAdminOrOwner) { // Current user is Admin (but not Owner)
                        if (targetUserRole === 'owner' || targetUserRole === 'admin') {
                            disableLogoutButton = true; // Admins cannot log out other Admins or Owners
                        }
                    } else { // Current user has no admin/owner access (should not happen if they see the panel, but defensive)
                        disableLogoutButton = true;
                    }
                }

                forceLogoutButton.disabled = disableLogoutButton;
                if (!disableLogoutButton) {
                    forceLogoutButton.onclick = () => forceLogoutUser(user.uid, formatDisplayName(user));
                }
                actionsCell.appendChild(forceLogoutButton);
            });
        }

        function collectAndSaveChanges() { // Function definition renamed
            const newRolesMap = {};
            const changesMap = {}; // Will store { uid: { newRole: 'role', newChipCount: 123 } }
            const rows = userRolesTableBody.querySelectorAll('tr');

            rows.forEach(row => {
                const roleSelect = row.querySelector('select[data-uid]');
                const chipInput = row.querySelector('input[type="number"][data-uid]');

                if (roleSelect && chipInput) {
                    const uid = roleSelect.getAttribute('data-uid');
                    const newRole = roleSelect.value;
                    const newChipCount = parseInt(chipInput.value, 10);

                    if (isNaN(newChipCount)) {
                        showMessage(`Invalid chip count for user with UID ${uid}. Please enter a valid number.`, 'error');
                        // Potentially skip this user or handle error more gracefully
                        return; // Skip this row if chip count is not a number
                    }
                    changesMap[uid] = { newRole, newChipCount };
                }
            });

            if (Object.keys(changesMap).length > 0) {
                saveUserChangesToFirestore(changesMap); // Call the renamed function
            } else {
                showMessage("No user data found to save.", "info");
            }
        }
        // --- End User Management Functions ---

        // --- Admin: Force Logout User ---
        async function forceLogoutUser(targetUid, targetUserDisplayName) {
            console.log(`Attempting to force logout for UID: ${targetUid}, Name: ${targetUserDisplayName}`); // Debug log

            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to force logout users.", 'error');
                // addLogEntry("Force Logout Attempt Failed", { reason: "Permission denied", targetUser: targetUid, by: auth.currentUser?.uid }); // Removed
                console.error("Force logout permission denied for current user:", auth.currentUser?.uid); // Debug log
                return;
            }

            // Additional permission checks (partially redundant with button disabling logic, but good for direct calls)
            const currentUserId = auth.currentUser.uid;
            console.log(`Current admin UID: ${currentUserId}`); // Debug log
            const currentUserIsOwner = isOwner(currentUserId);
            const targetUserRole = getCurrentUserRole(targetUid); 

            if (targetUid === currentUserId) {
                showMessage("You cannot force logout yourself.", 'error');
                return;
            }

            // This check is primarily for direct calls; button logic should prevent this UI-wise for admins.
            if (!currentUserIsOwner && (targetUserRole === 'owner' || targetUserRole === 'admin')) {
                showMessage("Admins cannot force logout other Admins or Owners.", 'error');
                // addLogEntry("Force Logout Attempt Denied", { reason: "Admin tried to log out admin/owner", targetUser: targetUid, by: currentUserId }); // Removed
                return;
            }

            if (!confirm(`Are you sure you want to force logout ${targetUserDisplayName || targetUid}? This will remove their active session marker.`)) {
                return;
            }
            console.log("Proceeding with force logout confirmation."); // Debug log

            if (!confirm(`Are you sure you want to force logout ${targetUserDisplayName || targetUid}? This will remove their active session marker.`)) {
                console.log("Force logout cancelled by admin."); // Debug log
                return;
            }

            showMessage(`Forcing logout for ${targetUserDisplayName || targetUid}...`, 'info');
            try {
                const activeSessionRef = doc(activeSessionsCollectionRef, targetUid);
                console.log(`Attempting to delete active session doc: active_sessions/${targetUid}`); // Debug log
                await deleteDoc(activeSessionRef);
                console.log(`Successfully deleted active session doc for UID: ${targetUid}`); // Debug log
                
                // addLogEntry("User Forced Logout", { 
                //     targetUser: targetUid, 
                //     targetUserName: targetUserDisplayName || 'N/A',
                //     byUser: auth.currentUser.email || currentUserId 
                // }); // Removed
                showMessage(`${targetUserDisplayName || targetUid} has been marked as logged out. Their status will update shortly.`, 'success');
                
                // Re-render the user management table to update button states (e.g., logout button for the user just logged out should become disabled)
                console.log("Force logout successful, re-rendering user roles table if visible."); // Debug log
                if (!userManagementPanel.classList.contains('hidden')) {
                    renderUserRolesTable();
                }
                // The User Directory table will auto-update if visible due to its own listener on activeSessionsCollectionRef.

            } catch (error) {
                console.error("Error during force logout Firestore operation:", error); // Debug log
                showMessage(`Failed to force logout for ${targetUserDisplayName || targetUid}. Error: ${error.message}`, 'error');
                // addLogEntry("Force Logout Failed", { targetUser: targetUid, error: error.message, by: currentUserId }); // Removed
            }
        }


        // --- "User Directory" Panel Functions (formerly Logged-in Users Panel) ---
        async function showUserDirectoryPanel() { 
            showPanel(userDirectoryPanel); // Corrected variable name
            await renderUserDirectoryTable(); 
            // addLogEntry("User Directory Panel Opened", { user: auth.currentUser?.email || auth.currentUser?.uid }); // Removed for log simplification
        }

        function hideUserDirectoryPanel() { 
            userDirectoryPanel.classList.add('hidden'); // Corrected variable name
            const loggedInUser = JSON.parse(localStorage.getItem('loggedInUser'));
            if (loggedInUser && loggedInUser.hasAdminAccess) {
                showPanel(adminPanel);
            } else if (loggedInUser) {
                // For regular users, perhaps show account management or simply hide, returning to default view.
                // Default view logic after login is handled by onAuthStateChanged or handleLoginSuccess.
                // If they were viewing their account, maybe go back there. For now, just hide.
            }
        }

        async function renderUserDirectoryTable() { 
            userDirectoryTableBody.innerHTML = '<tr><td colspan="3" class="text-center text-gray-500 py-4">Loading users...</td></tr>'; // Updated colspan for 3 columns

            try {
                // Ensure firestoreActiveSessions is available for status check
                const activeSessionUIDs = firestoreActiveSessions.map(session => session.id);

                const querySnapshot = await getDocs(userProfilesCollectionRef);
                const users = [];
                querySnapshot.forEach(doc => {
                    users.push(doc.data());
                });

                userDirectoryTableBody.innerHTML = ''; // Corrected variable name

                if (users.length === 0) {
                    userDirectoryTableBody.innerHTML = '<tr><td colspan="3" class="text-center text-gray-500 py-4">No users found in the directory.</td></tr>'; // Updated colspan
                    return;
                }

                // Sort users by displayName, case-insensitive
                users.sort((a, b) => {
                    const nameA = (formatDisplayName(a) || '').toLowerCase();
                    const nameB = (formatDisplayName(b) || '').toLowerCase();
                    if (nameA < nameB) return -1;
                    if (nameA > nameB) return 1;
                    return 0;
                });

                users.forEach(user => {
                    const row = userDirectoryTableBody.insertRow(); // Corrected variable name
                    const displayNameCell = row.insertCell();
                    const chipCountCell = row.insertCell();
                    const statusCell = row.insertCell();

                    displayNameCell.textContent = formatDisplayName(user);
                    chipCountCell.textContent = (typeof user.chip_count === 'number') ? user.chip_count : '0';

                    // Determine status: In-Game > Online > Offline
                    let userStatus = "Offline";
                    let statusClass = "text-gray-500";

                    // Check if user is in any game room's players list
                    let isInGame = false;
                    for (const room of firestoreGameRooms) {
                        if (room.players && room.players.includes(user.uid)) {
                            isInGame = true;
                            break;
                        }
                    }

                    if (isInGame) {
                        userStatus = "In-Game";
                        statusClass = "text-blue-600 font-semibold"; // Blue for In-Game
                    } else if (activeSessionUIDs.includes(user.uid)) {
                        userStatus = 'Online';
                        statusClass = 'text-green-600 font-semibold'; // Green for Online
                    }
                    // Default is Offline (grey), already set

                    statusCell.textContent = userStatus;
                    statusCell.className = statusClass;
                });

            } catch (error) {
                console.error("Error fetching user profiles for directory:", error);
                userDirectoryTableBody.innerHTML = '<tr><td colspan="3" class="text-center text-red-500 py-4">Error loading users.</td></tr>'; // Updated colspan
                showMessage("Could not load user directory.", "error");
            }
        }
        // --- End "User Directory" Panel Functions ---


        // --- Account Management Functions ---
        function renderAccountManagementPanel(displayUser) {
            const firebaseUser = auth.currentUser;

            userProfilePic.src = displayUser.profilePic || firebaseUser?.photoURL || 'https://placehold.co/100x100/cccccc/ffffff?text=U';
            userProfilePic.alt = `${displayUser.name || displayUser.username}'s profile picture`;
            currentUserName.textContent = displayUser.name || firebaseUser?.displayName || 'N/A';
            currentUserUsername.textContent = `Email: ${displayUser.username || firebaseUser?.email || 'N/A'}`;

            let providerId = 'Unknown';
            if (firebaseUser) {
                const providers = firebaseUser.providerData.map(p => p.providerId);
                if (providers.includes('google.com')) {
                    providerId = 'Google';
                    linkGoogleAccountButton.classList.add('hidden'); // Already linked with Google
                } else if (providers.includes('password')) {
                    providerId = 'Email/Password';
                    linkGoogleAccountButton.classList.remove('hidden'); // Can link to Google
                } else if (providers.includes('anonymous')) {
                    providerId = 'Anonymous';
                    linkGoogleAccountButton.classList.remove('hidden'); // Can link to Google
                }
            } else {
                providerId = 'No Firebase Session'; // Should not happen if this panel is shown
                linkGoogleAccountButton.classList.remove('hidden');
            }
            currentUserProvider.textContent = `Provider: ${providerId}`;
        }

        async function handleGoogleLink() {
            if (!auth.currentUser) {
                showMessage("No active Firebase user session to link accounts. Please sign in first.", 'error');
                return;
            }

            showMessage("Attempting to link with Google...", 'info');
            try {
                const result = await linkWithPopup(auth.currentUser, googleProvider);
                const linkedUser = result.user;
                console.log("Account linked successfully with Google:", linkedUser);

                const updatedLoggedInUser = {
                    username: linkedUser.email || linkedUser.uid,
                    name: linkedUser.displayName || linkedUser.email,
                    profilePic: linkedUser.photoURL,
                    isAdmin: (linkedUser.uid === SUPER_ADMIN_UID || firestoreUserRoles[linkedUser.uid]?.role === 'admin'),
                    firebaseUid: linkedUser.uid
                };
                localStorage.setItem('loggedInUser', JSON.stringify(updatedLoggedInUser));
                
                showMessage("Account successfully linked with Google!", 'success');
                // addLogEntry("Account Linked", { user: linkedUser.email || linkedUser.uid, provider: "Google" }); // Removed for log simplification
                renderAccountManagementPanel(updatedLoggedInUser);
            } catch (error) {
                console.error("Error linking Google account:", error);
                let errorMessage = "Failed to link Google account.";
                if (error.code === 'auth/credential-already-in-use') {
                    errorMessage = "This Google account is already linked to another user.";
                } else if (error.code === 'auth/popup-closed-by-user') {
                    errorMessage = "Google login window was closed.";
                } else if (error.code === 'auth/invalid-credential') {
                    errorMessage = "Invalid Google credential or already linked to a different account.";
                } else if (error.code === 'auth/email-already-in-use') {
                    errorMessage = "The email associated with this Google account is already in use by another login method. Please sign in with that method and then link.";
                }
                showMessage(errorMessage, 'error');
                // addLogEntry("Account Link Failed", { user: auth.currentUser?.uid || 'Unknown', provider: "Google", error: error.message }); // Removed for log simplification
            }
        }

        // Function to handle successful login and subsequent data loading
        async function handleLoginSuccess(user) {
            console.log("handleLoginSuccess: User authenticated, UID:", user.uid);
            
            // Ensure data loading and listeners setup only once per successful login
            if (!dataLoadedAndListenersSetup) {
                showPanel(loadingIndicator); // Show loading indicator while data is fetched
                loadingIndicator.querySelector('span').textContent = 'Loading user data...';
                await loadInitialData(); // Load user profiles first, if needed separately
                console.log("handleLoginSuccess: Setting up Firestore listeners and awaiting initial data...");
                await setupFirestoreListeners(); // Wait for listeners to load initial data
                console.log("handleLoginSuccess: Firestore listeners initial data loaded.");
                dataLoadedAndListenersSetup = true;
            }

            let userRole = getCurrentUserRole(user.uid); // Use helper, defaults to 'player'

            // Ensure SUPER_ADMIN_UID has 'owner' role in Firestore for consistency and explicitness.
            // The helper functions (isOwner, hasAdminAccess) will grant privileges regardless,
            // but this makes the database state match the effective permissions.
            if (user.uid === SUPER_ADMIN_UID && userRole !== 'owner') {
                // Check against the raw firestoreUserRoles as getCurrentUserRole would default to 'player' if not set
                if (firestoreUserRoles[user.uid]?.role !== 'owner') {
                    console.log(`SUPER_ADMIN_UID (${user.uid}) logged in. Ensuring 'owner' role is set in Firestore.`);
                    const superAdminRoleRef = doc(userRolesCollectionRef, user.uid);
                    try {
                        await setDoc(superAdminRoleRef, { role: 'owner' }, { merge: true });
                        firestoreUserRoles[user.uid] = { role: 'owner' }; // Update local cache
                        userRole = 'owner'; // Update userRole for the current execution context
                        // addLogEntry("SUPER_ADMIN Role Initialized/Verified", { uid: user.uid }); // Removed for log simplification (too internal)
                        console.log(`SUPER_ADMIN_UID (${user.uid}) role set to 'owner' in Firestore.`);
                    } catch (e) {
                        console.error("CRITICAL: Failed to set SUPER_ADMIN_UID role to 'owner' in Firestore:", e);
                        showMessage("Critical: Failed to initialize SUPER_ADMIN role. Contact support.", "error");
                        // Depending on policy, might want to halt login or restrict SUPER_ADMIN if this fails.
                        // For now, proceed as helper functions provide override.
                    }
                } else {
                     // If firestoreUserRoles already shows 'owner' (e.g. from listener update after another owner set it)
                    userRole = 'owner';
                }
            }


            // Ensure a user profile exists in Firestore for the logged-in Firebase user
            if (user) {
                const userProfileRef = doc(userProfilesCollectionRef, user.uid);
                // Prepare base user data
                const userData = {
                    uid: user.uid,
                    email: user.email || null,
                    displayName: user.displayName || user.email || 'Anonymous', // Ensure displayName has a fallback
                    photoURL: user.photoURL || null,
                    lastLogin: new Date().toISOString(),
                    role: userRole // Ensure profile reflects the determined role
                };

                // Check if the user profile document already exists to set chip_count only for new users
                const userProfileSnap = await getDoc(userProfileRef);
                if (!userProfileSnap.exists()) {
                    userData.chip_count = 0; // Initialize chip_count for new users
                    console.log("New user profile created with initial chip_count: 0 for user:", user.uid);
                } else {
                    const existingData = userProfileSnap.data();
                    // Ensure chip_count is a number, defaulting to 0 if it's missing or not a number.
                    if (typeof existingData.chip_count === 'number') {
                        userData.chip_count = existingData.chip_count;
                    } else {
                        userData.chip_count = 0; // Default to 0 if not a number or undefined
                        if (typeof existingData.chip_count !== 'undefined') {
                            console.log(`Existing user profile had a non-numeric chip_count ('${existingData.chip_count}'). Corrected to 0 for user:`, user.uid);
                        } else {
                            console.log("Existing user profile was missing chip_count. Initialized to 0 for user:", user.uid);
                        }
                    }
                }

                await setDoc(userProfileRef, userData, { merge: true });
                console.log("User profile updated/created in Firestore:", user.uid, "with role:", userRole, "and chip_count handling.");

                // Add to active_sessions collection
                const activeSessionRef = doc(activeSessionsCollectionRef, user.uid);
                try {
                    await setDoc(activeSessionRef, {
                        email: user.email || 'N/A',
                        role: userRole,
                        loginTime: new Date().toISOString()
                    }, { merge: true }); // merge:true to update if session doc already exists
                    console.log("User session added/updated in active_sessions:", user.uid);
                    setupOwnActiveSessionListener(user.uid); // Setup listener for self-logout
                } catch (e) {
                    console.error("Error adding/updating user session to active_sessions:", e);
                    // Non-critical, so don't block login, but log it.
                }
            }

            // ** 'Disabled' role check - This is handled in Step 3 of the plan, will be added here later **

            // Determine admin access and prepare user data for local storage
            const userHasAdminAccess = hasAdminAccess(user.uid);

            const finalUserForLocalStorage = {
                username: user.email || user.uid,
                name: formatDisplayName(user), // Format display name here
                profilePic: user.photoURL || 'https://placehold.co/50x50/cccccc/ffffff?text=U',
                hasAdminAccess: userHasAdminAccess, // Updated field name
                firebaseUid: user.uid,
                role: userRole
            };
            localStorage.setItem('loggedInUser', JSON.stringify(finalUserForLocalStorage));

            // ** 'Disabled' role check **
            if (userRole === 'disabled') {
                showMessage("Your account has been disabled. Please contact an administrator.", 'error');
                // addLogEntry("Disabled Account Login Attempt", { user: finalUserForLocalStorage.username, firebaseUid: user.uid }); // Removed
                // Ensure logout happens and no further UI is shown for a disabled user
                // We need to make sure handleLogout doesn't try to re-trigger onAuthStateChanged logic that might re-run this.
                // The isLoggingOut flag in handleLogout should prevent immediate re-login attempts.
                // No need to show other panels or buttons.
                isLoggingOut = true; // Set flag to prevent onAuthStateChanged from re-processing login
                handleLogout(); // This will clear local storage and sign out from Firebase
                showPanel(loginButtonsContainer); // Explicitly show login buttons after logout
                messageBox.classList.remove('hidden'); // Ensure the disabled message stays visible
                loadingIndicator.classList.add('hidden'); // Hide loading indicator
                return; // Stop further execution for disabled users
            }

            // Show welcome message
            showMessage(`Welcome, ${finalUserForLocalStorage.name}! Role: ${userRole}`, 'success');
            // addLogEntry("User Login", { user: finalUserForLocalStorage.username, firebaseUid: user.uid, role: userRole }); // Removed general login, covered by specific Google success/fail
            
            // Show neutral view with main action buttons, hide all content panels initially
            showPanel(null); // This will hide adminPanel, accountManagementPanel, userDirectoryPanel etc.
            loginButtonsContainer.classList.add('hidden'); // Ensure login buttons are hidden

            logoutButton.classList.remove('hidden');
            openAccountManagementButton.classList.remove('hidden');
            joinGameButton.classList.remove('hidden'); // Show for all logged-in users
            // investmentsButton.classList.remove('hidden'); // Show Investments button for all logged-in users
//            messagesButton.classList.remove('hidden');

            if (userHasAdminAccess) {
                openAdminPanelButton.classList.remove('hidden');
                // addLogEntry("Admin Panel Access", { user: finalUserForLocalStorage.username, firebaseUid: user.uid, role: userRole }); // Removed: Redundant with "User Login" and panel is no longer auto-opened
            } else {
                openAdminPanelButton.classList.add('hidden');
            }
            
            const userRoleForButton = finalUserForLocalStorage.role; // Re-check or use userRole directly
            if (userRoleForButton === 'player' || userRoleForButton === 'admin' || userRoleForButton === 'owner') {
                viewUserDirectoryButton.classList.remove('hidden');
            } else {
                viewUserDirectoryButton.classList.add('hidden');
            }
            // Note: renderAccountManagementPanel() will be called when its button is clicked.
            // Admin panel content is static for now, no specific render function on open needed beyond showPanel.
        }

        // Function to handle logout
        async function handleLogout() {
            if (unsubscribeOwnActiveSessionListener) {
                console.log("Unsubscribing from own active session listener during logout.");
                unsubscribeOwnActiveSessionListener();
                unsubscribeOwnActiveSessionListener = null;
            }

            const loggedInUserString = localStorage.getItem('loggedInUser');
            let firebaseUidToClear = null;

            if (loggedInUserString) {
                const user = JSON.parse(loggedInUserString);
                firebaseUidToClear = user.firebaseUid; // Get UID before clearing localStorage
                // addLogEntry("Logout", { user: user.username, isAdmin: user.hasAdminAccess, firebaseUid: user.firebaseUid }); // Removed
            } else if (auth.currentUser) {
                // Fallback if localStorage was cleared but auth session still exists
                firebaseUidToClear = auth.currentUser.uid;
                // addLogEntry("Logout", { user: auth.currentUser.email || "Unknown (from auth)", firebaseUid: auth.currentUser.uid }); // Removed
            } else {
                 // addLogEntry("Logout", { user: "Unknown" }); // Removed
            }

            isLoggingOut = true;

            if (firebaseUidToClear) {
                // Attempt to remove user from any game room they are in
                for (const room of firestoreGameRooms) {
                    if (room.players && room.players.includes(firebaseUidToClear)) {
                        console.log(`User ${firebaseUidToClear} is in room ${room.id}. Attempting to remove.`);
                        const roomDocRef = doc(gameRoomsCollectionRef, room.id);
                        try {
                            await updateDoc(roomDocRef, {
                                players: arrayRemove(firebaseUidToClear)
                            });
                            console.log(`User ${firebaseUidToClear} removed from room ${room.id} during logout.`);
                        } catch (e) {
                            console.error(`Error removing user ${firebaseUidToClear} from room ${room.id} during logout:`, e);
                            // Non-critical, continue logout process
                        }
                        // Assuming a user can only be in one room at a time
                        break; 
                    }
                }

                // Attempt to remove from active_sessions, regardless of signOut success
                try {
                    const activeSessionRef = doc(activeSessionsCollectionRef, firebaseUidToClear);
                    await deleteDoc(activeSessionRef);
                    console.log("User session removed from active_sessions:", firebaseUidToClear);
                } catch (e) {
                    console.error("Error removing user session from active_sessions:", e);
                    // Non-critical, log and continue logout
                }
            }

            try {
                if (auth.currentUser) { // Check again as state might have changed due to async operations above
                    await signOut(auth); // Use Firebase signOut function
                    console.log("Firebase: Signed out.");
                }
            } catch (error) {
                console.error("Firebase: Error signing out:", error);
            }

            localStorage.removeItem('loggedInUser');
            dataLoadedAndListenersSetup = false; // Reset for next login
            showMessage('You have been logged out.', 'info');
            showPanel(loginButtonsContainer);
            logoutButton.classList.add('hidden');
            viewUserDirectoryButton.classList.add('hidden');
            openAccountManagementButton.classList.add('hidden');
            openAdminPanelButton.classList.add('hidden');
            joinGameButton.classList.add('hidden'); // Hide on logout
            // investmentsButton.classList.add('hidden'); // Hide Investments button on logout
//            messagesButton.classList.add('hidden');

            // Hide other content panels that might have been open
            adminPanel.classList.add('hidden');
            userManagementPanel.classList.add('hidden');
            // logViewer.classList.add('hidden'); // logViewer removed
            accountManagementPanel.classList.add('hidden');
            if (userDirectoryPanel) { 
                userDirectoryPanel.classList.add('hidden');
            }
            // viewUserDirectoryButton is already handled above
        }

        // Best-effort cleanup on tab close / navigation
        window.addEventListener('beforeunload', async (event) => {
            // Check if there's a logged-in user according to Firebase Auth directly
            if (auth.currentUser && !isLoggingOut) { 
                const userId = auth.currentUser.uid;
                console.log('beforeunload: Attempting cleanup for user:', userId);

                // Best-effort: Attempt to remove user from any game room
                for (const room of firestoreGameRooms) {
                    if (room.players && room.players.includes(userId)) {
                        console.log(`beforeunload: User ${userId} is in room ${room.id}. Attempting fire-and-forget removal.`);
                        const roomDocRef = doc(gameRoomsCollectionRef, room.id);
                        updateDoc(roomDocRef, { // Not awaiting, fire-and-forget
                            players: arrayRemove(userId)
                        }).catch(e => console.warn(`beforeunload: Error removing user from room ${room.id}:`, e));
                        break; // Assuming user can only be in one room
                    }
                }
                
                // Best-effort: Attempt to clear active session
                try {
                    const activeSessionRef = doc(activeSessionsCollectionRef, userId);
                    deleteDoc(activeSessionRef).then(() => {
                        console.log('beforeunload: Active session cleanup call for', userId, 'completed.');
                    }).catch(e => {
                        console.warn('beforeunload: Error in active session cleanup call for', userId, e);
                    });
                } catch (e) {
                    console.warn("Error during beforeunload active session cleanup setup for user:", userId, e);
                }
            }
        });

        // --- Initial Data Loading (fetches user profiles) ---
        async function loadInitialData() {
            console.log("loadInitialData: Attempting to load user profiles...");
            if (!auth.currentUser) {
                console.warn("loadInitialData: Skipping data load, no authenticated user.");
                return;
            }

            try {
                const querySnapshot = await getDocs(userProfilesCollectionRef);
                allFirebaseUsersData = [];
                querySnapshot.forEach(doc => {
                    allFirebaseUsersData.push(doc.data());
                });
                console.log("Loaded Firebase user profiles:", allFirebaseUsersData.length);
            } catch (error) {
                console.error("Failed to fetch user profiles:", error);
                showMessage(`Failed to load user data: ${error.message}.`, 'error');
                // addLogEntry("Initial data load failed", { error: error.message }); // Removed
            }
        }

        // --- Firestore Real-time Listeners (for user roles and activity logs) ---
        function setupFirestoreListeners() {
            console.log("setupFirestoreListeners: Attempting to set up listeners...");
            if (!auth.currentUser) {
                console.warn("setupFirestoreListeners: Skipping listener setup, no authenticated user.");
                return Promise.resolve(); // Resolve immediately if no user
            }

            // Promise for User Roles
            const rolesPromise = new Promise((resolve, reject) => {
                let initialRolesLoadDone = false;
                const unsubscribeRoles = onSnapshot(userRolesCollectionRef, (snapshot) => {
                    const newRoles = {};
                    snapshot.forEach(doc => {
                        newRoles[doc.id] = doc.data();
                    });
                    firestoreUserRoles = newRoles;
                    console.log("Firestore: User Roles snapshot processed. Roles count:", Object.keys(firestoreUserRoles).length);

                    if (!userManagementPanel.classList.contains('hidden')) {
                        renderUserRolesTable();
                    }

                    const currentUser = auth.currentUser;
                    if (currentUser) {
                        const storedUser = JSON.parse(localStorage.getItem('loggedInUser'));
                        if (storedUser && currentUser.uid === storedUser.firebaseUid) { // Ensure it's the currently logged-in user
                             const newRoleDeterminedByListener = getCurrentUserRole(currentUser.uid);
                             const newHasAdminAccess = hasAdminAccess(currentUser.uid);

                             // Check if either role or admin access status has changed
                             if (storedUser.role !== newRoleDeterminedByListener || storedUser.hasAdminAccess !== newHasAdminAccess) {
                                 console.log(`Real-time: Role/access changed by listener for ${currentUser.uid}. Old role: ${storedUser.role}, New: ${newRoleDeterminedByListener}. Old AdminAccess: ${storedUser.hasAdminAccess}, New: ${newHasAdminAccess}`);

                                 storedUser.role = newRoleDeterminedByListener;
                                 storedUser.hasAdminAccess = newHasAdminAccess;
                                localStorage.setItem('loggedInUser', JSON.stringify(storedUser));

                                 // Handle 'disabled' role immediately if applied mid-session
                                 if (newRoleDeterminedByListener === 'disabled') {
                                    showMessage("Your account has been disabled. Please contact an administrator.", 'error');
                                    // addLogEntry("Account Disabled Mid-Session", { user: currentUser.email || currentUser.uid }); // Removed
                                    handleLogout(); // Force logout
                                    // Resolve promise here as further UI updates for this user are irrelevant
                                    if (!initialRolesLoadDone) {
                                        initialRolesLoadDone = true;
                                        console.log("Firestore: Initial User Roles loaded (resolved after disabled check).");
                                        resolve();
                                    }
                                    return; // Stop further processing for this user in the listener
                                 }

                                 if (newHasAdminAccess) {
                                    showPanel(adminPanel);
                                } else {
                                    showPanel(accountManagementPanel);
                                    renderAccountManagementPanel(storedUser);
                                }
                            }
                        }
                    }

                    if (!initialRolesLoadDone) {
                        initialRolesLoadDone = true;
                        console.log("Firestore: Initial User Roles loaded.");
                        resolve();
                    }
                }, (error) => {
                    console.error("Firestore: Error listening to user roles:", error);
                    showMessage("Error: Could not sync user roles from cloud.", 'error');
                    reject(error);
                });
                // Consider storing unsubscribeRoles if you need to detach listeners later
            });

            // Promise for User Profiles
            const profilesPromise = new Promise((resolve, reject) => {
                let initialProfilesLoadDone = false;
                const unsubscribeProfiles = onSnapshot(userProfilesCollectionRef, (snapshot) => {
                    allFirebaseUsersData = [];
                    snapshot.forEach(doc => {
                        allFirebaseUsersData.push(doc.data());
                    });
                    console.log("Firestore: User Profiles snapshot processed. Profiles count:", allFirebaseUsersData.length);
                    if (!userManagementPanel.classList.contains('hidden')) {
                        renderUserRolesTable();
                    }
                    if (!initialProfilesLoadDone) {
                        initialProfilesLoadDone = true;
                        console.log("Firestore: Initial User Profiles loaded.");
                        resolve();
                    }
                }, (error) => {
                    console.error("Firestore: Error listening to user profiles:", error);
                    showMessage("Error: Could not sync user profiles from cloud.", 'error');
                    reject(error);
                });
            });

            // Promise for Activity Logs (REMOVED)

            // Promise for Active Sessions
            const activeSessionsPromise = new Promise((resolve, reject) => {
                let initialSessionsLoadDone = false;
                const unsubscribeSessions = onSnapshot(activeSessionsCollectionRef, (snapshot) => {
                    const newSessions = [];
                    snapshot.forEach(doc => {
                        newSessions.push({ id: doc.id, ...doc.data() });
                    });
                    firestoreActiveSessions = newSessions;
                    console.log("Firestore: Active Sessions snapshot processed. Sessions count:", firestoreActiveSessions.length);

                    // If the User Directory panel is currently visible, re-render it to update statuses
                    if (userDirectoryPanel && !userDirectoryPanel.classList.contains('hidden')) {
                        renderUserDirectoryTable(); 
                    }

                    if (!initialSessionsLoadDone) {
                        initialSessionsLoadDone = true;
                        console.log("Firestore: Initial Active Sessions loaded.");
                        resolve();
                    }
                }, (error) => {
                    console.error("Firestore: Error listening to active sessions:", error);
                    showMessage("Error: Could not sync active sessions from cloud.", 'error');
                    reject(error);
                });
                // Consider storing unsubscribeSessions if needed
            });

            // Promise for Game Rooms
            const gameRoomsPromise = new Promise((resolve, reject) => {
                let initialGameRoomsLoadDone = false;
                const q = query(gameRoomsCollectionRef, orderBy("createdAt", "desc")); // Order by creation time, newest first
                const unsubscribeGameRooms = onSnapshot(q, (snapshot) => {
                    const newRooms = [];
                    snapshot.forEach(doc => {
                        newRooms.push({ id: doc.id, ...doc.data() });
                    });
                    firestoreGameRooms = newRooms;
                    console.log("Firestore: Game Rooms snapshot processed. Rooms count:", firestoreGameRooms.length);
                    
                    if (gameRoomManagementPanel && !gameRoomManagementPanel.classList.contains('hidden')) {
                        renderGameRoomsList();
                    }
                    // Also re-render user directory if it's visible, as player status might depend on game rooms
                    if (userDirectoryPanel && !userDirectoryPanel.classList.contains('hidden')) {
                        renderUserDirectoryTable();
                    }
                    // Also re-render available rooms list for players if it's visible
                    if (playerJoinRoomPanel && !playerJoinRoomPanel.classList.contains('hidden')) {
                        renderAvailableRoomsList();
                    }

                    // If player is currently viewing a specific game room, update that view
                    if (currentJoinedRoomId && gameRoomViewPanel && !gameRoomViewPanel.classList.contains('hidden')) {
                        const updatedRoomData = newRooms.find(room => room.id === currentJoinedRoomId);
                        if (updatedRoomData) {
                            renderGameRoomView(currentJoinedRoomId); // Re-render with potentially updated player list, status, etc.
                        } else {
                            // The room the player was in has been deleted or is no longer available
                            showMessage("The room you were in is no longer available.", "info");
                            currentJoinedRoomId = null;
                            showPanel(playerJoinRoomPanel); // Go back to lobby
                        }
                    }

                    if (!initialGameRoomsLoadDone) {
                        initialGameRoomsLoadDone = true;
                        console.log("Firestore: Initial Game Rooms loaded.");
                        resolve();
                    }
                }, (error) => {
                    console.error("Firestore: Error listening to game rooms:", error);
                    showMessage("Error: Could not sync game rooms from cloud.", 'error');
                    reject(error);
                });
                // Consider storing unsubscribeGameRooms if needed
            });

            // Promise for Investments
            const investmentsPromise = new Promise((resolve, reject) => {
                let initialInvestmentsLoadDone = false;
                // Query to get investments relevant to the current user, ordered by offerDate
                // This query might need to be split or adjusted based on how we want to display
                // (e.g., separate queries for investor vs. investee, or filter client-side)
                // For now, fetching all and filtering client-side for simplicity in listener setup.
                // Later, we might use: query(investmentsCollectionRef, where("investorUid", "==", auth.currentUser.uid))
                // and another for investeeUid.
                const qInvestments = query(investmentsCollectionRef, orderBy("offerDate", "desc"));

                const unsubscribeInvestments = onSnapshot(qInvestments, (snapshot) => {
                    const newInvestments = [];
                    snapshot.forEach(doc => {
                        newInvestments.push({ id: doc.id, ...doc.data() });
                    });
                    firestoreInvestments = newInvestments;
                    console.log("Firestore: Investments snapshot processed. Investments count:", firestoreInvestments.length);

                    // Re-render lists if the investment panel is visible and a user is logged in
                    if (auth.currentUser && investmentsPanel && !investmentsPanel.classList.contains('hidden')) {
                        renderMySharesList();
                        renderIncomingOffersList();
                        renderMyInvestmentsAsInvesteeList(); // Added for completeness
                    }

                    if (!initialInvestmentsLoadDone) {
                        initialInvestmentsLoadDone = true;
                        console.log("Firestore: Initial Investments loaded.");
                        resolve();
                    }
                }, (error) => {
                    console.error("Firestore: Error listening to investments:", error);
                    showMessage("Error: Could not sync investment data from cloud.", 'error');
                    reject(error);
                });
                // Consider storing unsubscribeInvestments if needed
            });

            return Promise.all([rolesPromise, profilesPromise, activeSessionsPromise, gameRoomsPromise, investmentsPromise]);
        }


        // --- Initialize App on DOM Load and Auth State Change ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOMContentLoaded fired. Script is running.');
            showPanel(loadingIndicator); // Show loading indicator immediately

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    // User is authenticated
                    console.log("Firebase: Authenticated. User ID:", user.uid, "Provider:", user.providerData[0]?.providerId || 'N/A');
                    firebaseAuthReady = true;

                    // If not logging out, and data/listeners not yet set up for this session
                    if (!isLoggingOut && !dataLoadedAndListenersSetup) {
                        console.log("onAuthStateChanged: User present and not logging out, triggering handleLoginSuccess.");
                        await handleLoginSuccess(user); // Triggers data load, listener setup, and panel display
                    } else if (isLoggingOut) {
                        console.log("onAuthStateChanged: User present but in logging out state. Skipping automatic login actions.");
                        showPanel(loginButtonsContainer); // Ensure login buttons are shown after logout
                        logoutButton.classList.add('hidden');
                        isLoggingOut = false; // Reset flag
                    } else {
                        // User is authenticated and data/listeners already set up for this session
                        console.log("onAuthStateChanged: User authenticated, data already loaded. Showing appropriate panel.");
                        const storedUser = JSON.parse(localStorage.getItem('loggedInUser'));
                        if (storedUser && storedUser.isAdmin) {
                            showPanel(adminPanel);
                        } else if (storedUser) {
                            showPanel(accountManagementPanel);
                            renderAccountManagementPanel(storedUser);
                        } else {
                            // Fallback if localStorage is somehow out of sync with Firebase auth
                            showPanel(loginButtonsContainer);
                            logoutButton.classList.add('hidden');
                        }
                    }
                    googleLoginButton.disabled = false;
                    // emailPasswordLoginButton.disabled = false; // This line is removed as the element no longer exists

                } else {
                    // No Firebase user is currently authenticated
                    console.log("Firebase: No user authenticated or user logged out.");
                    firebaseAuthReady = true; // Mark auth ready to allow future login attempts

                    if (initialAuthToken && !isLoggingOut) {
                        // Canvas environment: Attempt to sign in with custom token
                        console.log("Firebase: Canvas environment detected. Attempting custom token sign-in.");
                        loadingIndicator.querySelector('span').textContent = 'Authenticating with Canvas...';
                        try {
                            await signInWithCustomToken(auth, initialAuthToken);
                            // If successful, onAuthStateChanged will fire again with `user`, triggering data setup.
                        } catch (error) {
                            console.error("Firebase: Custom authentication failed:", error);
                            showMessage(`Firebase custom auth failed: ${error.message}. Functionality may be limited.`, 'error');
                            showPanel(loginButtonsContainer); // Show login buttons if custom auth fails
                        } finally {
                            loadingIndicator.classList.add('hidden');
                        }
                    } else {
                        // Regular web deployment or after explicit logout
                        console.log("Firebase: Regular deployment or logged out. Displaying login options.");
                        showPanel(loginButtonsContainer);
                        logoutButton.classList.add('hidden');
                        loadingIndicator.classList.add('hidden'); // Hide loading if no auth
                    }
                    // Reset data/listener flag when no user is authenticated
                    dataLoadedAndListenersSetup = false; 
                    googleLoginButton.disabled = false;
                    // emailPasswordLoginButton.disabled = false; // Removed
                }
            });
        });

        // Event listener for Google Login Button (primary login method)
        googleLoginButton.addEventListener('click', async () => {
            console.log('Google Login button clicked.');
            // addLogEntry("Google Login Attempt"); // Removed

            if (!firebaseAuthReady) {
                showMessage("Firebase authentication is not ready yet. Please wait a moment and try again.", 'info');
                return;
            }
            
            googleLoginButton.disabled = true; // Disable button during login attempt
            showMessage("Signing in with Google...", 'info');
            try {
                const result = await signInWithPopup(auth, googleProvider);
                const user = result.user; // Firebase User object
                console.log("Google Sign-In successful:", user);

                await handleLoginSuccess(user); // Pass the Firebase User object directly
                // addLogEntry("Google Login Success", { user: user.email || user.uid }); // Removed

            } catch (error) {
                console.error("Google Sign-In failed:", error);
                let errorMessage = "Google sign-in failed.";
                if (error.code === 'auth/popup-closed-by-user') {
                    errorMessage = "Google login window was closed.";
                } else if (error.code === 'auth/cancelled-popup-request') {
                    errorMessage = "Popup blocked or already open. Please try again.";
                } else if (error.code === 'auth/account-exists-with-different-credential') {
                     errorMessage = `An account already exists with this email using a different login method.`;
                     console.warn(errorMessage, "Provider ID:", error.customData.email, error.credential.providerId);
                } else if (error.code === 'auth/operation-not-allowed') {
                    errorMessage = "Google Sign-In is not enabled in Firebase Authentication settings.";
                }
                showMessage(errorMessage, 'error');
                // addLogEntry("Google Login Failed", { error: error.message }); // Removed
            } finally {
                googleLoginButton.disabled = false; // Re-enable button after attempt
            }
        });

        // Email/Password Login event listener removed.


        // Event listener for logout button
        logoutButton.addEventListener('click', handleLogout);

        // --- Admin Panel Button Event Listeners ---
        manageUsersButton.addEventListener('click', () => {
            const loggedInUser = JSON.parse(localStorage.getItem('loggedInUser'));
            // Use the new 'hasAdminAccess' field from localStorage
            if (loggedInUser && loggedInUser.hasAdminAccess) {
                showPanel(userManagementPanel);
                renderUserRolesTable(); // This will apply new role-based disabling of options
                // addLogEntry("User Management Panel Opened", { user: loggedInUser.username, role: loggedInUser.role }); // Removed for log simplification
            } else {
                showMessage("You do not have administrative access to manage users.", 'error');
                // addLogEntry("User Management Access Denied", { user: loggedInUser?.username || 'Unknown User', attemptedAction: "Open User Management Panel" }); // Removed
            }
        });

        hideUserManagementButton.addEventListener('click', () => {
            showPanel(adminPanel); // Assuming only admins/owners see this button in the first place
        });

        saveUserRolesButton.addEventListener('click', collectAndSaveChanges); // Updated function name

        // Event listeners for Bulk User Actions
        setAllPlayerChipsButton.addEventListener('click', handleSetAllPlayerChips); // Re-enabled
        forceLogoutAllUsersButton.addEventListener('click', handleForceLogoutAllUsers); // Re-enabled

        // Event listener for Bulk Game Room Actions
        deleteAllGameRoomsButton.addEventListener('click', handleDeleteAllGameRooms); // Re-enabled


        // Event listeners for log viewer buttons (REMOVED as feature is removed)

        // --- Account Management Button Event Listeners ---
        // The #manageAccountButton (from admin panel) was removed, so its listener must also be removed.
        // manageAccountButton.addEventListener('click', () => {
        //     const loggedInUser = JSON.parse(localStorage.getItem('loggedInUser'));
        //     if (loggedInUser) {
        //         showPanel(accountManagementPanel);
        //         renderAccountManagementPanel(loggedInUser);
        //         // addLogEntry("Account Management Panel Opened", { user: loggedInUser.username }); // Removed for log simplification
        //     } else {
        //         showMessage("Please log in to manage your account.", 'info');
        //     }
        // });

        hideAccountManagementButton.addEventListener('click', () => {
            showPanel(null); // Hide account management, return to the neutral view with main action buttons
        });

        linkGoogleAccountButton.addEventListener('click', handleGoogleLink);

        // --- User Directory Panel Button Event Listeners ---
        viewUserDirectoryButton.addEventListener('click', () => { 
            console.log("View User Directory button clicked."); // Debug log
            const loggedInUser = JSON.parse(localStorage.getItem('loggedInUser'));
            console.log("Logged in user for directory view:", loggedInUser); // Debug log
            if (loggedInUser && (loggedInUser.role === 'player' || loggedInUser.role === 'admin' || loggedInUser.role === 'owner')) {
                showUserDirectoryPanel();
            } else {
                showMessage("You do not have permission to view this.", 'error');
                 // addLogEntry("View User Directory Access Denied", { user: loggedInUser?.username || 'Unknown User', role: loggedInUser?.role }); // Removed
            }
        });

        hideUserDirectoryPanelButton.addEventListener('click', hideUserDirectoryPanel); 


        // --- Event Listeners for New "Open Panel" Buttons ---
        openAdminPanelButton.addEventListener('click', () => {
            // Permission check also happens in handleLoginSuccess for button visibility, 
            // but good to have a check here too in case of direct calls or unforeseen UI states.
            if (auth.currentUser && hasAdminAccess(auth.currentUser.uid)) {
                showPanel(adminPanel);
                // addLogEntry("Admin Panel Opened", { trigger: "OpenAdminPanelButton", by: auth.currentUser.email }); // Removed
            } else {
                showMessage("You do not have permission to access the Admin Panel.", "error");
                // Optionally hide the button if it was erroneously shown
                openAdminPanelButton.classList.add('hidden');
            }
        });

        openAccountManagementButton.addEventListener('click', () => {
            const loggedInUser = JSON.parse(localStorage.getItem('loggedInUser'));
            if (loggedInUser && auth.currentUser) { // Ensure there's an active Firebase auth session too
                showPanel(accountManagementPanel);
                // The loggedInUser object from localStorage should have the formatted name.
                // renderAccountManagementPanel expects an object with {name, username, profilePic}
                // and also uses auth.currentUser for provider info.
                renderAccountManagementPanel(loggedInUser); 
                // addLogEntry("Account Management Panel Opened", { trigger: "OpenAccountManagementButton", by: loggedInUser.username }); // Removed
            } else {
                // This case should ideally not be reached if button visibility is managed correctly.
                showMessage("You need to be logged in to manage your account.", "info");
                showPanel(loginButtonsContainer); // Show login as a fallback
            }
        });

        closeAdminPanelButton.addEventListener('click', () => {
            showPanel(null); // Hide admin panel, return to the neutral view with main action buttons
            // Ensure main action buttons are visible if they were part of a container managed by showPanel
            // However, current logic in handleLoginSuccess makes them visible and they are not hidden by showPanel(specificPanel).
        });

        // --- Game Room Management Panel Event Listeners ---
        manageGameRoomsButton.addEventListener('click', () => {
            console.log("Manage Game Rooms button clicked."); // Debug log
            if (auth.currentUser && hasAdminAccess(auth.currentUser.uid)) {
                console.log("User has admin access, showing gameRoomManagementPanel and calling renderGameRoomsList."); // Debug log
                showPanel(gameRoomManagementPanel);
                renderGameRoomsList(); // Render the list when panel is opened
            } else {
                console.log("User does NOT have admin access for game rooms or not logged in."); // Debug log
                showMessage("You do not have permission to manage game rooms.", "error");
            }
        });

        closeGameRoomManagementPanelButton.addEventListener('click', () => {
            showPanel(adminPanel); // Return to main admin panel
        });

        async function createGameRoom() {
            const roomName = newRoomNameInput.value.trim();
            if (!roomName) {
                showMessage("Room name cannot be empty.", "error");
                return;
            }

            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to create game rooms.", "error");
                return;
            }

            showMessage("Creating game room...", "info");
            try {
                await addDoc(gameRoomsCollectionRef, {
                    roomName: roomName,
                    createdBy: auth.currentUser.uid,
                    createdAt: serverTimestamp(),
                    status: "open", // Initial status
                    players: []      // Initially no players
                });
                showMessage(`Game room "${roomName}" created successfully!`, "success");
                newRoomNameInput.value = ''; // Clear input
                // The list of rooms will update via the Firestore listener in renderGameRoomsList
            } catch (error) {
                console.error("Error creating game room:", error);
                showMessage(`Failed to create game room: ${error.message}`, "error");
            }
        }

        createGameRoomButton.addEventListener('click', createGameRoom);

        async function handleDeleteRoom(roomId, roomName) {
            console.log(`handleDeleteRoom CALLED for roomId: ${roomId}, roomName: ${roomName}`); // Debug
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to delete game rooms.", "error");
                return;
            }

            if (!confirm(`Are you sure you want to permanently delete room: "${roomName}"? This action cannot be undone.`)) {
                return;
            }

            showMessage(`Deleting room "${roomName}"...`, "info");
            try {
                const roomDocRef = doc(gameRoomsCollectionRef, roomId);
                await deleteDoc(roomDocRef);
                showMessage(`Room "${roomName}" deleted successfully.`, "success");
                // The list will automatically update via the Firestore listener.
            } catch (error) {
                console.error("Error deleting game room:", error);
                showMessage(`Failed to delete room "${roomName}": ${error.message}`, "error");
            }
        }

        // --- Player Join Game Panel Listeners ---
        joinGameButton.addEventListener('click', () => {
            if (auth.currentUser) {
                showPanel(playerJoinRoomPanel);
                renderAvailableRoomsList(); // To be implemented next
            } else {
                showMessage("Please log in to join a game.", "info");
                showPanel(loginButtonsContainer);
            }
        });

        closePlayerJoinRoomPanelButton.addEventListener('click', () => {
            showPanel(null); // Return to neutral view
        });

        // --- Game Room Listing ---
        function renderGameRoomsList() {
            console.log("renderGameRoomsList CALLED"); // Debug log
            if (!gameRoomsListContainer) {
                console.error("renderGameRoomsList: gameRoomsListContainer is null!"); // Debug log
                return; 
            }

            gameRoomsListContainer.innerHTML = ''; // Clear previous list

            if (firestoreGameRooms.length === 0) {
                gameRoomsListContainer.innerHTML = '<p class="text-gray-500 text-center py-4">No game rooms created yet.</p>';
                return;
            }

            const ul = document.createElement('ul');
            ul.className = 'space-y-2';

            // Sort rooms, e.g., by creation time (newest first) if createdAt is a valid Timestamp
            // For now, just iterating as is, or sort by name.
            const sortedRooms = [...firestoreGameRooms].sort((a, b) => {
                if (a.createdAt && b.createdAt) { // Assuming createdAt is a Firestore Timestamp
                    return b.createdAt.seconds - a.createdAt.seconds; 
                }
                return (a.roomName || '').localeCompare(b.roomName || '');
            });

            sortedRooms.forEach(room => {
                const li = document.createElement('li');
                li.className = 'p-3 bg-gray-100 rounded-md shadow-sm flex justify-between items-center';
                
                const roomNameSpan = document.createElement('span');
                roomNameSpan.textContent = room.roomName || 'Unnamed Room';
                roomNameSpan.className = 'font-semibold text-gray-800';
                
                const roomStatusSpan = document.createElement('span');
                roomStatusSpan.textContent = `Status: ${room.status || 'N/A'}`;
                roomStatusSpan.className = `text-sm px-2 py-1 rounded-full ${room.status === 'open' ? 'bg-green-200 text-green-800' : 'bg-gray-200 text-gray-800'}`;

                // TODO: Add player count: room.players?.length || 0
                
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'flex items-center space-x-2 mt-2 sm:mt-0 sm:ml-4';

                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.className = 'bg-red-500 hover:bg-red-700 text-white text-xs py-1 px-2 rounded';
                deleteButton.setAttribute('data-room-id', room.id);
                deleteButton.setAttribute('data-room-name', room.roomName || 'Unnamed Room');
                console.log(`Setting delete click for room: ${room.id}, name: ${room.roomName || 'Unnamed Room'}`); // Debug
                deleteButton.onclick = () => handleDeleteRoom(room.id, room.roomName || 'Unnamed Room');

                actionsDiv.appendChild(deleteButton);
                // TODO: Add other admin action buttons here (e.g., View Players, Close/Open Room)


                li.appendChild(roomNameSpan);
                const detailsDiv = document.createElement('div'); // To group status and actions
                detailsDiv.className = "flex flex-col sm:flex-row sm:items-center";
                detailsDiv.appendChild(roomStatusSpan);
                detailsDiv.appendChild(actionsDiv);
                li.appendChild(detailsDiv);

                ul.appendChild(li);
            });
            gameRoomsListContainer.appendChild(ul);
        }

        // --- Player: Render Available Game Rooms List ---
        function renderAvailableRoomsList() {
            if (!availableRoomsListContainer) return;

            availableRoomsListContainer.innerHTML = ''; // Clear previous list

            const openRooms = firestoreGameRooms.filter(room => room.status === 'open');

            if (openRooms.length === 0) {
                availableRoomsListContainer.innerHTML = '<p class="text-gray-500 text-center py-4">No game rooms currently available to join.</p>';
                return;
            }

            const ul = document.createElement('ul');
            ul.className = 'space-y-3';

            openRooms.forEach(room => {
                const li = document.createElement('li');
                li.className = 'p-4 bg-white rounded-lg shadow hover:shadow-md transition-shadow flex flex-col sm:flex-row justify-between items-start sm:items-center space-y-2 sm:space-y-0';

                const roomInfoDiv = document.createElement('div');
                
                const roomNameSpan = document.createElement('span');
                roomNameSpan.textContent = room.roomName || 'Unnamed Room';
                roomNameSpan.className = 'font-semibold text-lg text-indigo-700 block';
                roomInfoDiv.appendChild(roomNameSpan);

                const playerCountSpan = document.createElement('span');
                const currentPlayers = room.players?.length || 0;
                // const maxPlayers = room.maxPlayers || 'N/A'; // Assuming maxPlayers might be added later
                playerCountSpan.textContent = `Players: ${currentPlayers}`; // / ${maxPlayers}
                playerCountSpan.className = 'text-sm text-gray-600 block mt-1';
                roomInfoDiv.appendChild(playerCountSpan);
                
                li.appendChild(roomInfoDiv);

                const joinButton = document.createElement('button');
                joinButton.textContent = 'Join';
                joinButton.className = 'bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out text-sm sm:ml-4 flex-shrink-0 disabled:opacity-50 disabled:cursor-not-allowed';
                joinButton.setAttribute('data-room-id', room.id);
                joinButton.disabled = false; // Default to enabled, specific conditions will disable it.

                if(auth.currentUser) {
                    let playerUID = auth.currentUser.uid;
                    let playerIsCurrentlyInThisRoom = room.players && room.players.includes(playerUID);
                    let playerIsCurrentlyInAnyOtherRoom = false;

                    if (!playerIsCurrentlyInThisRoom) {
                        for (const r of firestoreGameRooms) {
                            if (r.id !== room.id && r.players && r.players.includes(playerUID)) {
                                playerIsCurrentlyInAnyOtherRoom = true;
                                break;
                            }
                        }
                    }

                    if (playerIsCurrentlyInThisRoom) {
                        joinButton.textContent = 'View Current Game';
                        joinButton.className = 'bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out text-sm sm:ml-4 flex-shrink-0';
                        joinButton.onclick = () => {
                            currentJoinedRoomId = room.id;
                            showPanel(gameRoomViewPanel);
                            renderGameRoomView(room.id);
                        };
                    } else if (playerIsCurrentlyInAnyOtherRoom) {
                        joinButton.textContent = 'Join';
                        joinButton.className = 'bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out text-sm sm:ml-4 flex-shrink-0 disabled:opacity-50 disabled:cursor-not-allowed';
                        joinButton.disabled = true; // Player is in another room
                        joinButton.onclick = () => handleJoinRoom(room.id); // Keep original join action, though disabled
                    } else { // Player is in no room
                        joinButton.textContent = 'Join';
                        joinButton.className = 'bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out text-sm sm:ml-4 flex-shrink-0 disabled:opacity-50 disabled:cursor-not-allowed';
                        joinButton.onclick = () => handleJoinRoom(room.id);
                        if (room.status !== 'open') {
                            joinButton.disabled = true; // Room is not open to join
                        }
                    }
                } else {
                    // No user logged in, disable join
                    joinButton.textContent = 'Join';
                    joinButton.className = 'bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out text-sm sm:ml-4 flex-shrink-0 disabled:opacity-50 disabled:cursor-not-allowed';
                    joinButton.disabled = true;
                }
                
                // Final check, if room is not open and it's not the "View Current Game" button
                if (room.status !== 'open' && joinButton.textContent === 'Join') { 
                    joinButton.disabled = true;
                }
                li.appendChild(joinButton);
                ul.appendChild(li);
            });
            availableRoomsListContainer.appendChild(ul);
        }

        function renderGameRoomView(roomId) {
            if (!gameRoomViewPanel || !auth.currentUser) {
                console.error("renderGameRoomView: Panel or user not available.");
                showPanel(playerJoinRoomPanel); // Fallback to lobby
                return;
            }

            const room = firestoreGameRooms.find(r => r.id === roomId);
            if (!room) {
                console.error(`renderGameRoomView: Room with ID ${roomId} not found in firestoreGameRooms.`);
                showMessage("Error: The room you were in could not be found.", "error");
                currentJoinedRoomId = null;
                showPanel(playerJoinRoomPanel); // Fallback to lobby
                adminGameControls.classList.add('hidden'); // Ensure admin controls are hidden on error/fallback
                updateChipsPanel.classList.add('hidden'); // Ensure update chips panel is hidden
                return;
            }

            gameRoomViewName.textContent = room.roomName || 'Unnamed Room';

            // Admin controls visibility check at the beginning of render
            if (auth.currentUser && hasAdminAccess(auth.currentUser.uid)) {
                adminGameControls.classList.remove('hidden');
                // Event listeners for admin buttons are now set here to ensure they have the correct roomId
                adminRoomResetButton.onclick = () => adminRoomReset(roomId);
                adminUpdateChipsButton.onclick = () => toggleUpdateChipsPanel(roomId, true); // Show panel
                cancelChipUpdate.onclick = () => toggleUpdateChipsPanel(roomId, false);    // Hide panel
                submitChipUpdate.onclick = () => handleSubmitChipUpdate(roomId);
            } else {
                adminGameControls.classList.add('hidden');
                updateChipsPanel.classList.add('hidden'); // Also hide the panel if user is not admin
            }

            // Populate player list
            if (!roomPlayersListContainer) {
                console.error("renderGameRoomView: roomPlayersListContainer is null!");
                return;
            }
            roomPlayersListContainer.innerHTML = ''; // Clear previous player list

            // Calculate the highest bet in the current round - MOVED HERE
            const highestBet = Object.values(room.currentBets || {}).reduce((max, bet) => Math.max(max, bet), 0);

            console.log('--- ADMIN ACCESS CHECK (Overall):', auth.currentUser?.uid, hasAdminAccess(auth.currentUser?.uid)); // Step 1 Debug Log

            if (!room.players || room.players.length === 0) {
                roomPlayersListContainer.innerHTML = '<p class="text-gray-400 col-span-full text-center py-4">No players in this room yet.</p>';
            } else {
                room.players.forEach(playerId => {
                    const playerProfile = allFirebaseUsersData.find(p => p.uid === playerId);
                    const playerName = playerProfile ? formatDisplayName(playerProfile) : `Player UID: ${playerId}`;
                    const playerChips = playerProfile ? (playerProfile.chip_count ?? 0) : 'N/A';
                    
                    const rawStatus = room.playerStatuses ? room.playerStatuses[playerId] : 'pending';
                    const playerBetAmount = room.currentBets ? (room.currentBets[playerId] ?? 0) : 0;

                    let displayStatus = rawStatus;
                    let cardBgColor = 'bg-gray-700'; // Default

                    if (rawStatus === 'folded') {
                        displayStatus = 'Folded';
                        cardBgColor = 'bg-red-600 hover:bg-red-700'; // Darker red
                    } else if (rawStatus === 'all-in') {
                        displayStatus = 'All-In';
                        cardBgColor = 'bg-purple-600 hover:bg-purple-700'; // Darker purple
                    } else if (highestBet > 0 && playerBetAmount < highestBet) {
                        displayStatus = 'Pending';
                        cardBgColor = 'bg-yellow-500 hover:bg-yellow-600'; // Darker yellow
                    } else { // Includes playerBetAmount === highestBet, or highestBet is 0
                        displayStatus = 'Ready';
                        cardBgColor = 'bg-green-600 hover:bg-green-700'; // Darker green
                    }

                    const playerCard = document.createElement('div');
                    // Base classes with transition for color change
                    playerCard.className = `p-3 rounded shadow text-white transition-colors duration-300 ease-in-out ${cardBgColor}`;
                    
                    const nameEl = document.createElement('p');
                    nameEl.className = 'font-semibold text-lg'; // Adjusted text color for better contrast on varied backgrounds
                    nameEl.textContent = playerName;
                    playerCard.appendChild(nameEl);

                    const chipsEl = document.createElement('p');
                    chipsEl.className = 'text-sm';
                    chipsEl.textContent = `Chips: ${playerChips}`;
                    playerCard.appendChild(chipsEl);

                    const statusTextEl = document.createElement('p');
                    statusTextEl.className = 'text-sm font-medium mt-1';
                    statusTextEl.textContent = `Status: ${displayStatus}`;
                    playerCard.appendChild(statusTextEl);
                    
                    const betEl = document.createElement('p');
                    betEl.className = 'text-xs';
                    betEl.textContent = `Bet: ${playerBetAmount}`; 
                    playerCard.appendChild(betEl);

                    // Admin Menu for Player Card - Debugging
                    // console.log('Admin Check before if:', auth.currentUser?.uid, typeof auth.currentUser?.uid !== 'undefined' ? hasAdminAccess(auth.currentUser.uid) : 'N/A (no user)');
                    if (auth.currentUser && hasAdminAccess(auth.currentUser.uid)) {
                        // console.log('Admin menu WILL be created for player:', playerName);
                        const adminMenuButton = document.createElement('button');
                        adminMenuButton.innerHTML = '&#8942;'; // Vertical ellipsis
                        // Restored Tailwind classes for subtle styling
                        adminMenuButton.className = 'absolute top-2 right-2 text-gray-200 hover:text-white p-1 rounded-full focus:outline-none focus:ring-2 focus:ring-gray-500'; 
                        
                        const adminMenuDropdown = document.createElement('div');
                        adminMenuDropdown.className = 'hidden absolute top-8 right-2 bg-gray-600 text-white rounded-md shadow-lg py-1 z-10 min-w-max';
                        adminMenuDropdown.id = `admin-menu-${playerId}`;
                        adminMenuDropdown.innerHTML = ''; // Clear placeholder

                        // "Remove Player" option
                        const removePlayerButton = document.createElement('button');
                        removePlayerButton.textContent = 'Remove Player';
                        removePlayerButton.className = 'block w-full text-left px-3 py-2 text-sm hover:bg-gray-500 focus:outline-none';
                        if (playerId === auth.currentUser.uid) { // Prevent admin from removing self this way
                            removePlayerButton.disabled = true;
                            removePlayerButton.title = "Cannot remove yourself";
                            removePlayerButton.classList.add('opacity-50', 'cursor-not-allowed');
                        } else {
                            removePlayerButton.onclick = (event) => {
                                event.stopPropagation();
                                adminRemovePlayer(roomId, playerId, playerName);
                                adminMenuDropdown.classList.add('hidden'); // Close menu after action
                            };
                        }
                        adminMenuDropdown.appendChild(removePlayerButton);

                        // "Force Fold Player" option
                        const forceFoldButton = document.createElement('button');
                        forceFoldButton.textContent = 'Force Fold';
                        forceFoldButton.className = 'block w-full text-left px-3 py-2 text-sm hover:bg-gray-500 focus:outline-none';
                        
                        const targetPlayerCurrentStatus = room.playerStatuses ? room.playerStatuses[playerId] : 'pending';
                        if (playerId === auth.currentUser.uid || targetPlayerCurrentStatus === 'folded' || targetPlayerCurrentStatus === 'all-in') {
                            forceFoldButton.disabled = true;
                            forceFoldButton.title = (playerId === auth.currentUser.uid) ? "Cannot force fold yourself" : "Player already folded or all-in";
                            forceFoldButton.classList.add('opacity-50', 'cursor-not-allowed');
                        } else {
                            forceFoldButton.onclick = (event) => {
                                event.stopPropagation();
                                adminForceFoldPlayer(roomId, playerId, playerName);
                                adminMenuDropdown.classList.add('hidden'); // Close menu
                            };
                        }
                        adminMenuDropdown.appendChild(forceFoldButton);

                        // "Place Bet for Player" option
                        const placeBetForPlayerButton = document.createElement('button');
                        placeBetForPlayerButton.textContent = 'Place Bet for Player';
                        placeBetForPlayerButton.className = 'block w-full text-left px-3 py-2 text-sm hover:bg-gray-500 focus:outline-none';

                        if (targetPlayerCurrentStatus === 'folded' || targetPlayerCurrentStatus === 'all-in') {
                            placeBetForPlayerButton.disabled = true;
                            placeBetForPlayerButton.title = "Player is folded or all-in";
                            placeBetForPlayerButton.classList.add('opacity-50', 'cursor-not-allowed');
                        } else {
                            placeBetForPlayerButton.onclick = (event) => {
                                event.stopPropagation();
                                adminPlaceBetForPlayer(roomId, playerId, playerName, playerChips); // Pass playerChips for validation
                                adminMenuDropdown.classList.add('hidden'); // Close menu
                            };
                        }
                        adminMenuDropdown.appendChild(placeBetForPlayerButton);

                        // "Declare Winner" option (Placeholder) - REMOVED
                        // const declareWinnerButton = document.createElement('button');
                        // declareWinnerButton.textContent = 'Declare Winner (Placeholder)';
                        // declareWinnerButton.className = 'block w-full text-left px-3 py-2 text-sm hover:bg-gray-500 focus:outline-none';
                        // // Enable for any active player, admin can decide if it makes sense.
                        // // Could be disabled if player is folded.
                        // if (targetPlayerCurrentStatus === 'folded') {
                        //      declareWinnerButton.disabled = true;
                        //      declareWinnerButton.title = "Cannot declare a folded player as winner";
                        //      declareWinnerButton.classList.add('opacity-50', 'cursor-not-allowed');
                        // } else {
                        //     declareWinnerButton.onclick = (event) => {
                        //         event.stopPropagation();
                        //         adminDeclareWinner(roomId, playerId, playerName);
                        //         adminMenuDropdown.classList.add('hidden'); // Close menu
                        //     };
                        // }
                        // adminMenuDropdown.appendChild(declareWinnerButton);
                        
                        // Placeholder for more actions (if any more are added after this)
                        // const comingSoon = document.createElement('p'); 
                        // comingSoon.className = 'px-3 py-1 text-xs text-gray-400 border-t border-gray-500 mt-1 pt-1';
                        // comingSoon.textContent = 'More actions soon...';
                        // adminMenuDropdown.appendChild(comingSoon);


                        playerCard.appendChild(adminMenuButton);
                        playerCard.appendChild(adminMenuDropdown); // Append to card to be relative to it

                        adminMenuButton.onclick = (event) => {
                            event.stopPropagation(); // Prevent card click or other underlying events
                            // Hide any other open admin menus
                            document.querySelectorAll('[id^="admin-menu-"]').forEach(menu => {
                                if (menu.id !== adminMenuDropdown.id) {
                                    menu.classList.add('hidden');
                                }
                            });
                            adminMenuDropdown.classList.toggle('hidden');
                        };
                        
                        // Clicking outside the dropdown should close it
                        // This listener is added once per renderGameRoomView, ideally should be managed more globally or cleaned up
                        // For now, this is a simple approach.
                        document.body.addEventListener('click', (event) => {
                            if (!adminMenuDropdown.contains(event.target) && !adminMenuButton.contains(event.target)) {
                                adminMenuDropdown.classList.add('hidden');
                            }
                        }, { once: true }); // Use once to auto-remove after first trigger, or manage removal carefully
                    }
                    playerCard.style.position = 'relative'; // Needed for absolute positioning of dropdown/button

                    roomPlayersListContainer.appendChild(playerCard);
                });
            }

            // Update player's chip count for betting UI
            const currentUserProfileForBetUI = allFirebaseUsersData.find(p => p.uid === auth.currentUser.uid);
            if (currentUserProfileForBetUI && playerChipCountForBet) {
                playerChipCountForBet.textContent = currentUserProfileForBetUI.chip_count ?? 0;
                if (playerBetInput) {
                    playerBetInput.max = currentUserProfileForBetUI.chip_count ?? 0;
                }
            } else if (playerChipCountForBet) {
                playerChipCountForBet.textContent = 'N/A';
                 if (playerBetInput) {
                    playerBetInput.removeAttribute('max');
                }
            }

            // Calculate and Display Game Stats
            const gameStatsContent = document.getElementById('gameStatsContent');
            if (gameStatsContent) {
                gameStatsContent.innerHTML = ''; // Clear previous stats

                const totalPot = Object.values(room.currentBets || {}).reduce((sum, bet) => sum + bet, 0);
                // highestBet is now defined in the outer scope of this function.
                
                const totalPotEl = document.createElement('p');
                totalPotEl.innerHTML = `<strong>Total Pot:</strong> ${totalPot} chips`;
                gameStatsContent.appendChild(totalPotEl);

                const highestBetEl = document.createElement('p');
                highestBetEl.innerHTML = `<strong>Highest Bet This Round:</strong> ${highestBet} chips`; 
                gameStatsContent.appendChild(highestBetEl);

                const activePlayersBetsTitle = document.createElement('h5');
                activePlayersBetsTitle.className = 'text-md font-semibold mt-3 mb-1 text-gray-200';
                activePlayersBetsTitle.textContent = 'Active Player Bets:';
                gameStatsContent.appendChild(activePlayersBetsTitle);

                const activePlayersUl = document.createElement('ul');
                activePlayersUl.className = 'list-disc list-inside text-sm space-y-1';

                let activePlayerFound = false;
                if (room.players && room.playerStatuses && room.currentBets) {
                    room.players.forEach(playerId => {
                        const status = room.playerStatuses[playerId];
                        const bet = room.currentBets[playerId] ?? 0;
                        if (status !== 'folded') {
                            const playerProfile = allFirebaseUsersData.find(p => p.uid === playerId);
                            const playerName = playerProfile ? formatDisplayName(playerProfile) : `UID: ${playerId.substring(0,6)}`;
                            const li = document.createElement('li');
                            li.textContent = `${playerName}: ${bet} chips`;
                            activePlayersUl.appendChild(li);
                            activePlayerFound = true;
                        }
                    });
                }

                if (!activePlayerFound) {
                    const noActiveEl = document.createElement('p');
                    noActiveEl.className = 'text-sm text-gray-400';
                    noActiveEl.textContent = 'No players currently active in the pot.';
                    activePlayersUl.appendChild(noActiveEl);
                }
                gameStatsContent.appendChild(activePlayersUl);

                // Placeholder for future side pot display refinement
                const sidePotInfo = document.createElement('p');
                sidePotInfo.className = 'text-xs text-gray-500 mt-2';
                sidePotInfo.textContent = '(Detailed side pot calculations will be shown here in a future update.)';
                gameStatsContent.appendChild(sidePotInfo);

            } else {
                console.warn("gameStatsContent element not found for rendering stats.");
            }


            // Wire up buttons in this panel
            leaveCurrentGameRoomButton.onclick = () => {
                handleLeaveRoom(roomId);
                adminGameControls.classList.add('hidden'); // Ensure admin controls are hidden
                updateChipsPanel.classList.add('hidden'); // Ensure update chips panel is hidden
            };
            closeGameRoomViewButton.onclick = () => {
                currentJoinedRoomId = null; // Clear joined room state
                showPanel(playerJoinRoomPanel); // Show the lobby/list of rooms
                adminGameControls.classList.add('hidden'); // Hide admin controls when leaving room view
                updateChipsPanel.classList.add('hidden'); // Hide chip update panel if open
            };

            // Assign handlePlaceBet directly to the onclick event
            placeBetButton.onclick = () => handlePlaceBet(roomId);
            callButton.onclick = () => handleCallBet(roomId); // Wire up Call button
            foldButton.onclick = () => handleFold(roomId); // Wire up Fold button
            allInButton.onclick = () => handleAllIn(roomId); // Wire up All-In button

            // Admin controls visibility is handled at the top of renderGameRoomView.
            // Event listeners for admin buttons are also set there.

            // Disable action buttons if player is folded or all-in
            const currentPlayerStatus = room.playerStatuses ? room.playerStatuses[auth.currentUser.uid] : null;
            if (currentPlayerStatus === 'folded' || currentPlayerStatus === 'all-in') {
                placeBetButton.disabled = true;
                foldButton.disabled = true;
                allInButton.disabled = true;
                playerBetInput.disabled = true; 
            } else {
                placeBetButton.disabled = false;
                foldButton.disabled = false;
                allInButton.disabled = false;
                playerBetInput.disabled = false;
                callButton.disabled = false; // Base state
                callButton.textContent = 'Call';

                // Define currentPlayerChips here using the already fetched profile
                const userProfileForChips = allFirebaseUsersData.find(p => p.uid === auth.currentUser.uid);
                const currentPlayerChips = userProfileForChips ? (userProfileForChips.chip_count ?? 0) : 0;

                // Additional logic for Call button text and disabled state
                const highestBetInRoomForCall = Object.values(room.currentBets || {}).reduce((max, bet) => Math.max(max, bet), 0);
                const currentPlayerBet = room.currentBets ? (room.currentBets[auth.currentUser.uid] ?? 0) : 0;

                if (highestBetInRoomForCall === 0 || currentPlayerBet === highestBetInRoomForCall) {
                    callButton.textContent = 'Check';
                } else {
                    callButton.textContent = 'Call ' + highestBetInRoomForCall;
                }

                if (currentPlayerChips === 0 && highestBetInRoomForCall > 0 && currentPlayerBet < highestBetInRoomForCall) {
                    callButton.disabled = true;
                }
                 // This check is somewhat redundant due to the outer 'else' for folded/all-in, but safe.
                 // The outer check for currentPlayerStatus already handles disabling if folded or all-in.
                 // if (currentPlayerStatus === 'folded' || currentPlayerStatus === 'all-in') {
                 //    callButton.disabled = true;
                 // }
            }
        } // This closes renderGameRoomView()

    async function handleCallBet(roomId) {
        if (!auth.currentUser) {
            showMessage("You must be logged in to make this action.", "error");
            return;
        }
        const userId = auth.currentUser.uid;
        const roomDocRef = doc(gameRoomsCollectionRef, roomId);

        const roomSnap = await getDoc(roomDocRef);
        if (!roomSnap.exists()) {
            showMessage("Error: Room data not found.", "error");
            return;
        }
        const roomData = roomSnap.data();
        const highestBetInRoom = Object.values(roomData.currentBets || {}).reduce((max, bet) => Math.max(max, bet), 0);

        const currentUserProfile = allFirebaseUsersData.find(p => p.uid === userId);
        const currentPlayerChips = currentUserProfile ? (currentUserProfile.chip_count ?? 0) : 0;
        const currentPlayerBet = roomData.currentBets ? (roomData.currentBets[userId] ?? 0) : 0;


        let betAmount = 0;
        let newStatus = 'ready';
        let actionMessage = "";
        let action = "call";

        if (highestBetInRoom === 0 || currentPlayerBet === highestBetInRoom) { // Effective Check
            betAmount = currentPlayerBet; // Keep current bet if it matches, or 0 if checking
            action = 'check';
            actionMessage = "You checked.";
            if (currentPlayerBet > 0 && highestBetInRoom === currentPlayerBet) { // Already called/bet this amount
                 actionMessage = `You are already at the highest bet of ${currentPlayerBet}. Action treated as check.`;
            }

        } else { // Standard Call or Call All-In
            if (currentPlayerChips >= (highestBetInRoom - currentPlayerBet) ) { // Has enough to cover the difference
                betAmount = highestBetInRoom;
                actionMessage = `You called ${betAmount}.`;
                action = 'call';
            } else { // Not enough to cover, goes all-in for a partial call
                betAmount = currentPlayerChips + currentPlayerBet; // Their remaining chips + what they already bet
                newStatus = 'all-in';
                action = 'call_all_in';
                actionMessage = `You called by going all-in with your remaining ${currentPlayerChips} (total bet: ${betAmount}).`;
            }
        }

        // Prevent betting more than total chips, though covered by all-in logic mostly
        if (betAmount > (currentUserProfile.chip_count + currentPlayerBet) && newStatus !== 'all-in') {
             // This case should ideally be prevented by UI or prior logic, but as a safeguard
            console.warn("Call logic tried to bet more than available chips, adjusting to all-in.");
            betAmount = currentUserProfile.chip_count + currentPlayerBet; // All current chips + what's already in pot by them
            newStatus = 'all-in';
             action = 'call_all_in'; // Ensure action reflects all-in
        }


        showMessage(`Performing action: ${actionMessage}`, "info");
        try {
            const updates = {
                [`currentBets.${userId}`]: betAmount,
                [`playerStatuses.${userId}`]: newStatus,
                [`playerLastActions.${userId}`]: action
            };
            await updateDoc(roomDocRef, updates);
            showMessage(actionMessage, "success");
        } catch (error) {
            console.error(`Error during ${action}:`, error);
            showMessage(`Failed to ${action}: ${error.message}`, "error");
            }
        }

        async function handleAllIn(roomId) {
            if (!auth.currentUser) {
                showMessage("You must be logged in to go all-in.", "error");
                return;
            }
            const userId = auth.currentUser.uid;
            const roomDocRef = doc(gameRoomsCollectionRef, roomId);

            // Get player's current chip count
            const userProfile = allFirebaseUsersData.find(p => p.uid === userId);
            if (!userProfile || typeof userProfile.chip_count !== 'number') {
                showMessage("Could not retrieve your chip count to go all-in.", "error");
                console.error("All-In: User profile or chip_count not found for", userId, userProfile);
                return;
            }
            const allInAmount = userProfile.chip_count;

            if (allInAmount <= 0) {
                showMessage("You have no chips to go all-in with.", "info");
                // Optionally, could auto-fold the player here or prevent all-in if it means betting 0.
                // For now, just inform. If their current bet is already > 0, this might be an edge case.
                return;
            }

            showMessage(`Going all-in with ${allInAmount} chips...`, "info");
            try {
                const updates = {
                    [`currentBets.${userId}`]: allInAmount,
                    [`playerStatuses.${userId}`]: 'all-in',
                    [`playerLastActions.${userId}`]: 'all-in'
                };
                await updateDoc(roomDocRef, updates);

                // IMPORTANT: Deduct chips from the player's actual profile
                // This is a critical operation and ideally should be part of a transaction
                // if combined with other game state changes that must succeed or fail together.
                // For now, we'll update the user_profiles document directly.
                // Consider moving chip deduction to when a hand/round resolves to avoid issues if a game crashes.
                // However, the requirement was "Deducts chips from the player's profile".
                // Let's proceed with caution. If this direct deduction is problematic,
                // we will revise to only mark chips as "in play" from the room's perspective.

                // For this iteration, we will NOT directly deduct from user_profiles here.
                // The allInAmount is recorded in currentBets. Chip reconciliation will be a later step
                // (e.g., when the pot is awarded or if a player leaves).
                // This avoids complexity with partial game states and rollbacks.

                showMessage(`You are all-in with ${allInAmount}!`, "success");
                // UI will update via Firestore listener, disabling buttons.
            } catch (error) {
                console.error("Error going all-in:", error);
                showMessage(`Failed to go all-in: ${error.message}`, "error");
            }
        }

        async function adminDeclareWinner(roomId, targetPlayerId, targetPlayerName) {
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to declare winners.", "error");
                return;
            }

            const targetPlayerCurrentStatus = firestoreGameRooms.find(r => r.id === roomId)?.playerStatuses?.[targetPlayerId];
            if (targetPlayerCurrentStatus === 'folded') {
                showMessage(`${targetPlayerName} is folded and cannot be declared a winner.`, "info");
                return;
            }

            if (!confirm(`Are you sure you want to declare ${targetPlayerName || 'this player'} as the winner of the current pot? This is a placeholder action.`)) {
                return;
            }

            console.log(`ADMIN ACTION: Declare Winner triggered for player ${targetPlayerName} (UID: ${targetPlayerId}) in room ${roomId}. Pot distribution logic is pending.`);
            alert(`Admin action: Declared ${targetPlayerName} as winner of the current pot. (Note: Pot distribution is not yet implemented.)`);
            
            // In a full implementation, this would trigger:
            // 1. Calculation of main pot and any side pots.
            // 2. Distribution of chips to the winner(s) - updating their chip_count in user_profiles.
            // 3. Resetting currentBets for all players in the room.
            // 4. Potentially advancing the game state (e.g., new round, new dealer).
            // For now, it's just a notification.
            showMessage(`Placeholder: ${targetPlayerName} declared winner. No chips moved yet.`, "info");
        }

        async function handleFold(roomId) {
            if (!auth.currentUser) {
                showMessage("You must be logged in to fold.", "error");
                return;
            }
            const userId = auth.currentUser.uid;
            const roomDocRef = doc(gameRoomsCollectionRef, roomId);

            showMessage("Folding your hand...", "info");
            try {
                const updates = {
                    [`playerStatuses.${userId}`]: 'folded',
                    [`playerLastActions.${userId}`]: 'fold'
                    // Optionally, set currentBets[userId] to a specific value like -1 or keep as is
                };
                await updateDoc(roomDocRef, updates);
                showMessage("You have folded.", "success");
                // The gameRoomView will re-render due to the Firestore listener,
                // which should update UI elements (e.g., disable buttons, change player card color).
            } catch (error) {
                console.error("Error folding:", error);
                showMessage(`Failed to fold: ${error.message}`, "error");
            }
        }

        async function handleJoinRoom(roomId) {
            if (!auth.currentUser) {
                showMessage("You must be logged in to join a room.", "error");
                return;
            }
            const userId = auth.currentUser.uid;

            // Check if player is already in any room (client-side check for quick UI feedback)
            for (const r of firestoreGameRooms) {
                if (r.players && r.players.includes(userId)) {
                    if (r.id === roomId) {
                        showMessage("You are already in this room.", "info");
                    } else {
                        showMessage("You are already in another game room. Please leave it before joining a new one.", "error");
                    }
                    return;
                }
            }

            const roomDocRef = doc(gameRoomsCollectionRef, roomId);
            showMessage("Joining room...", "info");

            try {
                const roomSnap = await getDoc(roomDocRef);
                if (!roomSnap.exists()) {
                    showMessage("Error: Room not found.", "error");
                    renderAvailableRoomsList(); // Refresh list as room might have been deleted
                    return;
                }

                const roomData = roomSnap.data();
                if (roomData.status !== 'open') {
                    showMessage("This room is no longer open to join.", "error");
                    renderAvailableRoomsList(); // Refresh list
                    return;
                }

                // Optional: Check for maxPlayers if implemented
                // if (roomData.players.length >= roomData.maxPlayers) {
                //     showMessage("This room is full.", "error");
                //     renderAvailableRoomsList(); // Refresh list
                //     return;
                // }
                
                // Add player to the room and initialize their game state
                const updates = {
                    players: arrayUnion(userId),
                    [`currentBets.${userId}`]: 0, // Initialize bet to 0
                    [`playerStatuses.${userId}`]: 'pending', // Initial status
                    [`playerLastActions.${userId}`]: 'joined' // Initial action
                };
                await updateDoc(roomDocRef, updates);

                showMessage("Successfully joined the room!", "success");
                currentJoinedRoomId = roomId; // Set the current joined room ID
                showPanel(gameRoomViewPanel);   // Show the dedicated game room view
                renderGameRoomView(roomId);     // Populate the view
            } catch (error) {
                console.error("Error joining room:", error);
                showMessage(`Failed to join room: ${error.message}`, "error");
            }
        }

        // --- Admin Game Control Functions ---
        async function adminRoomReset(roomId) {
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to reset the room.", "error");
                return;
            }

            const roomDocRef = doc(gameRoomsCollectionRef, roomId);
            const room = firestoreGameRooms.find(r => r.id === roomId);

            if (!room || !room.players) {
                showMessage("Room data or players not found.", "error");
                return;
            }

            if (!confirm("Are you sure you want to reset all bets to 0 and unfold all players?")) {
                return;
            }

            showMessage("Resetting room...", "info");
            try {
                const updates = {};
                room.players.forEach(playerId => {
                    updates[`currentBets.${playerId}`] = 0;
                    updates[`playerStatuses.${playerId}`] = 'pending'; // Or 'ready' depending on desired default
                    updates[`playerLastActions.${playerId}`] = 'room_reset';
                });

                // Also reset overall room properties if needed, e.g., pot, current round, etc.
                // For now, focusing on player bets and statuses.

                await updateDoc(roomDocRef, updates);
                showMessage("Room has been reset. All bets are 0, players unfolded.", "success");
                // UI will update via Firestore listener in renderGameRoomView
            } catch (error) {
                console.error("Error resetting room:", error);
                showMessage(`Failed to reset room: ${error.message}`, "error");
            }
        }

        function toggleUpdateChipsPanel(roomId, show) { // Renamed and modified
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to access this feature.", "error");
                return;
            }
            if (show) {
                populateUpdateChipsPanel(roomId); // Populate before showing
                updateChipsPanel.classList.remove('hidden');
            } else {
                updateChipsPanel.classList.add('hidden');
            }
        }

        function populateUpdateChipsPanel(roomId) {
            if (!updateChipsPlayerList) return;
            updateChipsPlayerList.innerHTML = ''; // Clear previous content

            const room = firestoreGameRooms.find(r => r.id === roomId);
            if (!room || !room.players || room.players.length === 0) {
                updateChipsPlayerList.innerHTML = '<p class="text-gray-400">No players in the room to update.</p>';
                return;
            }

            room.players.forEach(playerId => {
                const playerProfile = allFirebaseUsersData.find(p => p.uid === playerId);
                const playerName = playerProfile ? formatDisplayName(playerProfile) : `Player UID: ${playerId}`;
                const playerStatus = room.playerStatuses ? room.playerStatuses[playerId] : 'unknown';

                // Only include players who are not folded for ranking
                if (playerStatus === 'folded') {
                    const foldedPlayerDiv = document.createElement('div');
                    foldedPlayerDiv.className = 'flex justify-between items-center p-2 bg-gray-600 rounded';
                    foldedPlayerDiv.innerHTML = `
                        <span class="text-gray-400">${playerName} (Folded)</span>
                        <span class="text-xs text-gray-500">Cannot rank folded players</span>
                    `;
                    updateChipsPlayerList.appendChild(foldedPlayerDiv);
                    return; // Skip to next player
                }

                const playerDiv = document.createElement('div');
                playerDiv.className = 'flex justify-between items-center p-2 bg-gray-600 rounded';

                const nameSpan = document.createElement('span');
                nameSpan.textContent = playerName;
                nameSpan.className = 'text-gray-100';
                playerDiv.appendChild(nameSpan);

                const selectRank = document.createElement('select');
                selectRank.className = 'bg-gray-500 text-white border border-gray-400 rounded-md p-1 text-sm focus:ring-blue-500 focus:border-blue-500';
                selectRank.setAttribute('data-player-id', playerId);

                const ranks = [
                    { value: '0', text: 'No Win / Loser' },
                    { value: '1', text: 'Winner 1st' },
                    { value: '2', text: 'Winner 2nd' },
                    { value: '3', text: 'Winner 3rd' }
                ];

                ranks.forEach(rank => {
                    const option = document.createElement('option');
                    option.value = rank.value;
                    option.textContent = rank.text;
                    selectRank.appendChild(option);
                });
                selectRank.value = '0'; // Default to "No Win"
                playerDiv.appendChild(selectRank);
                updateChipsPlayerList.appendChild(playerDiv);
            });
        }

        async function handleSubmitChipUpdate(roomId) {
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to perform this action.", "error");
                return;
            }

            const room = firestoreGameRooms.find(r => r.id === roomId);
            if (!room || !room.players || room.players.length === 0) {
                showMessage("No player data found for this room.", "error");
                return;
            }

            // Collect rankings
            const playerRankings = [];
            const rankSelects = updateChipsPlayerList.querySelectorAll('select[data-player-id]');
            rankSelects.forEach(select => {
                playerRankings.push({
                    playerId: select.getAttribute('data-player-id'),
                    rank: parseInt(select.value, 10) // 0 for No Win, 1, 2, 3
                });
            });

            if (playerRankings.some(p => p.rank > 0 && (room.playerStatuses[p.playerId] === 'folded'))) {
                 showMessage("Error: Folded players cannot be assigned a winning rank. Please correct and resubmit.", "error");
                 return;
            }

            // 1. For every eligible (non-folded) player in the room, create a variable calculated by adding all bets that are lower than the player's bet together plus the player's bet times any bets that are equal to/greater than their own, including their own bet. This variable will reflect the max amount of chips each player can win.
            console.log("Step 1: Calculating max win for each player.");
            const players = room.players.map(playerId => {
                const playerProfile = allFirebaseUsersData.find(p => p.uid === playerId);
                const bet = room.currentBets[playerId] || 0;
                const status = room.playerStatuses[playerId];
                const rank = playerRankings.find(p => p.playerId === playerId)?.rank || 0;

                return {
                    id: playerId,
                    name: playerProfile ? formatDisplayName(playerProfile) : `Player ${playerId}`,
                    bet,
                    status,
                    rank,
                    winnings: 0,
                    chips: playerProfile.chip_count
                };
            });

            const bets = players.map(p => p.bet);
            const eligiblePlayers = players.filter(p => p.status !== 'folded');

            eligiblePlayers.forEach(player => {
                let maxWin = 0;
                bets.forEach(bet => {
                    if (bet < player.bet) {
                        maxWin += bet;
                    } else {
                        maxWin += player.bet;
                    }
                });
                player.maxWin = maxWin;
            });
            console.log("Eligible players with max win:", eligiblePlayers);

            // 2. Create a new variable called available_pot that starts equal to the original pot. This new variable will be changed as the pot is calculated to see how many chips remain.
            let available_pot = bets.reduce((a, b) => a + b, 0);
            console.log("Step 2: Initial available pot:", available_pot);

            // 3. Create a new variable called 1st_win_quotient that equals the number of players who are marked as 1st winner divided by the available_pot.
            // 4. Based on the division, for each player marked as 1st winner, compare each players max they can win vs. 1st_win_quotient. if their max is equal to or smaller than the 1st_win_quotient, set their winnings to 1st_win_quotient. if 1st_win_quotient is larger than their max, set their winnings to their max.
            // 5. Set the available_pot variable to available_pot minus all of the players winnings.
            // 6. Repeat steps 3-5 for 2nd winners and 3rd winners.
            for (let i = 1; i <= 3; i++) {
                console.log(`Step 3-6: Calculating winnings for rank ${i}`);
                const winners = eligiblePlayers.filter(p => p.rank === i);
                if (winners.length > 0) {
                    const win_quotient = available_pot / winners.length;
                    console.log(`Rank ${i} win quotient:`, win_quotient);
                    winners.forEach(winner => {
                        if (winner.maxWin <= win_quotient) {
                            winner.winnings = winner.maxWin;
                        } else {
                            winner.winnings = win_quotient;
                        }
                        available_pot -= winner.winnings;
                        console.log(`Winner ${winner.name} winnings:`, winner.winnings);
                        console.log("Available pot after winner:", available_pot);
                    });
                }
            }

            // 7. If the available_pot variable is not equal to 0, return an error, and set all of the winnings back to 0.
            console.log("Step 7: Final available pot check:", available_pot);
            if (available_pot !== 0) {
                showMessage("Error: Pot not distributed correctly. All winnings have been reset to 0.", "error");
                eligiblePlayers.forEach(player => {
                    player.winnings = 0;
                });
                return;
            }

            // 8. If there is no error, subtract each player's bets from their chips in firestore, and add their winnings to their chips in firestore. Then run the reset room function.
            const updates = [];
            players.forEach(player => {
                const playerProfileRef = doc(userProfilesCollectionRef, player.id);
                const newChipCount = player.chips - player.bet + player.winnings;
                updates.push(updateDoc(playerProfileRef, { chip_count: newChipCount }));
            });

            Promise.all(updates).then(() => {
                adminRoomReset(roomId);
                toggleUpdateChipsPanel(roomId, false);
            });
        }

        // --- Bulk User Management Functions ---
        async function handleSetAllPlayerChips() {
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission for this action.", 'error');
                return;
            }

            const newChipAmountString = prompt("Enter the chip amount to set for ALL users (including admins/owners):");
            if (newChipAmountString === null) return; // User cancelled

            let newChipAmount = parseInt(newChipAmountString, 10);
            if (isNaN(newChipAmount) || newChipAmount < 0) {
                showMessage("Invalid chip amount. Please enter a non-negative number.", 'error');
                return;
            }
            newChipAmount = Math.round(newChipAmount); // Round the input amount

            if (!confirm(`Are you sure you want to set the chip count of ALL USERS (INCLUDING ADMINS/OWNERS) to ${newChipAmount}? This cannot be undone.`)) {
                return;
            }

            showMessage("Updating chip counts for all users...", 'info');
            try {
                const querySnapshot = await getDocs(userProfilesCollectionRef);
                const updates = [];
                let usersUpdatedCount = 0;

                querySnapshot.forEach(docSnap => {
                    const userProfile = docSnap.data();
                    // No exclusion based on role, update all users.
                    updates.push(updateDoc(doc(userProfilesCollectionRef, userProfile.uid), { chip_count: newChipAmount }));
                    usersUpdatedCount++;
                });

                await Promise.all(updates);
                if (usersUpdatedCount > 0) {
                    showMessage(`Successfully set chip count to ${newChipAmount} for ${usersUpdatedCount} users.`, 'success');
                } else {
                    showMessage(`No users found to update (this should ideally not happen if there are users).`, 'info');
                }
                // The user roles table will update via Firestore listener if visible.
            } catch (error) {
                console.error("Error setting all player chips:", error);
                showMessage(`Failed to update all chip counts: ${error.message}`, 'error');
            }
        }

        async function handleForceLogoutAllUsers() {
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission for this action.", 'error');
                return;
            }

            // if (!confirm("Are you sure you want to force logout ALL users (except yourself if you are an admin/owner)? This will end their active sessions.")) {
            //     return;
            // }
            if (!confirm("Are you sure you want to force logout ALL OTHER users? Admins will not log out other Admins or Owners unless they are an Owner themselves. Your own session will not be affected.")) {
                return;
            }

            showMessage("Forcing logout for all applicable users...", 'info');
            try {
                const activeSessionsSnapshot = await getDocs(activeSessionsCollectionRef);
                const currentAdminUid = auth.currentUser.uid;
                const updates = [];
                let usersLoggedOutCount = 0;

                activeSessionsSnapshot.forEach(docSnap => {
                    const sessionUid = docSnap.id;
                    // Do not log out the admin performing the action
                    if (sessionUid === currentAdminUid) {
                        console.log("Skipping force logout for self (current admin).");
                        return;
                    }
                    // Additional check: an admin should not be able to force logout an owner or SUPER_ADMIN
                    // unless they themselves are an owner (or SUPER_ADMIN).
                    // The individual force logout already has this, but good for bulk too.
                    const targetUserRole = getCurrentUserRole(sessionUid);
                    const currentUserIsOwner = isOwner(currentAdminUid);

                    if (!currentUserIsOwner && (targetUserRole === 'owner' || sessionUid === SUPER_ADMIN_UID)) {
                        console.log(`Skipping force logout for ${sessionUid} (Role: ${targetUserRole}) by non-owner admin.`);
                        return;
                    }

                    updates.push(deleteDoc(doc(activeSessionsCollectionRef, sessionUid)));
                    usersLoggedOutCount++;
                });

                await Promise.all(updates);
                if (usersLoggedOutCount > 0) {
                    showMessage(`Successfully initiated force logout for ${usersLoggedOutCount} users.`, 'success');
                } else {
                    showMessage("No other active user sessions found to log out.", 'info');
                }
                // User tables (management & directory) will update via listeners.
            } catch (error) {
                console.error("Error forcing logout for all users:", error);
                showMessage(`Failed to force logout all users: ${error.message}`, 'error');
            }
        }

        // --- Bulk Game Room Management Function ---
        async function handleDeleteAllGameRooms() {
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission for this action.", 'error');
                return;
            }

            if (!confirm("EXTREME CAUTION: Are you absolutely sure you want to delete ALL game rooms? This action is irreversible and will affect all ongoing games.")) {
                return;
            }
            // Second, more aggressive confirmation
            if (!confirm("SECOND WARNING: Confirm again to delete ALL game rooms. There is no undo.")) {
                return;
            }

            showMessage("Deleting all game rooms...", 'info');
            try {
                const gameRoomsSnapshot = await getDocs(gameRoomsCollectionRef);
                if (gameRoomsSnapshot.empty) {
                    showMessage("No game rooms found to delete.", 'info');
                    return;
                }

                const deletePromises = [];
                let deletedCount = 0;
                gameRoomsSnapshot.forEach(docSnap => {
                    deletePromises.push(deleteDoc(doc(gameRoomsCollectionRef, docSnap.id)));
                    deletedCount++;
                });

                await Promise.all(deletePromises);
                showMessage(`Successfully deleted ${deletedCount} game room(s).`, 'success');
                // The game rooms list will update automatically via its Firestore listener.
            } catch (error) {
                console.error("Error deleting all game rooms:", error);
                showMessage(`Failed to delete all game rooms: ${error.message}`, 'error');
            }
        }

        // --- Investments Panel Event Listeners ---
//        investmentsButton.addEventListener('click', () => {
//            if (auth.currentUser) {
//                showPanel(investmentsPanel);
//                // Default to showing the 'Shares' tab
//                activateInvestmentsTab(sharesTab, sharesContent);
//            } else {
//                showMessage("Please log in to access investments.", "info");
//                showPanel(loginButtonsContainer);
//            }
//        });

//        closeInvestmentsPanelButton.addEventListener('click', () => {
//            showPanel(null); // Return to neutral view
//        });

//        sharesTab.addEventListener('click', () => activateInvestmentsTab(sharesTab, sharesContent));
//        offersTab.addEventListener('click', () => activateInvestmentsTab(offersTab, offersContent));

        function activateInvestmentsTab(activeTabButton, activeTabContent) {
            // Ensure elements exist before manipulating them
            const tabs = [sharesTab, offersTab].filter(Boolean);
            const contents = [sharesContent, offersContent].filter(Boolean);

            tabs.forEach(tab => {
                tab.classList.remove('border-blue-500', 'text-blue-600', 'text-gray-800', 'font-semibold'); // Active classes
                tab.classList.add('hover:text-gray-600', 'hover:border-gray-300', 'text-gray-500'); // Inactive classes
                tab.setAttribute('aria-selected', 'false');
            });
            contents.forEach(content => {
                content.classList.add('hidden');
            });

            if (activeTabButton) {
                activeTabButton.classList.add('border-blue-500', 'text-blue-600', 'text-gray-800', 'font-semibold');
                activeTabButton.classList.remove('hover:text-gray-600', 'hover:border-gray-300', 'text-gray-500');
                activeTabButton.setAttribute('aria-selected', 'true');
            }

            if (activeTabContent) {
                activeTabContent.classList.remove('hidden');
            }
        }

        // --- Investment Logic Functions ---

        function populateInvestmentPlayerSelect() {
            if (!investPlayerSelect || !auth.currentUser) {
                if (investPlayerSelect) investPlayerSelect.innerHTML = '<option value="">Login to see players</option>';
                return;
            }

            const currentUid = auth.currentUser.uid;
            investPlayerSelect.innerHTML = '<option value="">Select a player to invest in...</option>'; 

            const availablePlayers = allFirebaseUsersData
                .filter(user => user.uid !== currentUid && getCurrentUserRole(user.uid) !== 'disabled')
                .sort((a, b) => (formatDisplayName(a) || '').localeCompare(formatDisplayName(b) || ''));

            if (availablePlayers.length === 0) {
                investPlayerSelect.innerHTML = '<option value="">No other players available</option>';
            } else {
                availablePlayers.forEach(user => {
                    const option = document.createElement('option');
                    option.value = user.uid;
                    option.textContent = formatDisplayName(user);
                    investPlayerSelect.appendChild(option);
                });
            }
            
            const currentUserProfile = allFirebaseUsersData.find(p => p.uid === currentUid);
            if (currentUserProfile && maxInvestableChips) {
                const userChipCount = currentUserProfile.chip_count || 0;
                maxInvestableChips.textContent = userChipCount;
                if (investChipAmount) {
                    investChipAmount.max = userChipCount;
                    investChipAmount.placeholder = `e.g., ${Math.min(100, Math.floor(userChipCount / 2) || 1 )}`; // Dynamic placeholder
                }
            } else if (maxInvestableChips) {
                maxInvestableChips.textContent = 'N/A';
                 if (investChipAmount) {
                    investChipAmount.removeAttribute('max');
                    investChipAmount.placeholder = 'e.g., 100';
                }
            }
        }

        async function handleOfferInvestment(event) {
            event.preventDefault();
            if (!auth.currentUser) {
                showMessage("You must be logged in to offer an investment.", "error");
                return;
            }

            const investorUid = auth.currentUser.uid;
            const investorProfile = allFirebaseUsersData.find(p => p.uid === investorUid);
            if (!investorProfile) {
                showMessage("Could not find your user profile.", "error");
                return;
            }
            const investorName = formatDisplayName(investorProfile);
            const investorChips = investorProfile.chip_count || 0;

            const investeeUid = investPlayerSelect.value;
            const offerAmount = parseInt(investChipAmount.value, 10);
            const requestedPayoutPercent = parseInt(investPayoutPercent.value, 10);
            const handsForPayout = parseInt(investHandsPayout.value, 10);

            if (!investeeUid) {
                showMessage("Please select a player to invest in.", "error");
                return;
            }
            if (isNaN(offerAmount) || offerAmount <= 0) {
                showMessage("Please enter a valid, positive chip amount to send.", "error");
                return;
            }
            if (offerAmount > investorChips) {
                showMessage("You do not have enough chips to make this offer.", "error");
                return;
            }
            if (isNaN(requestedPayoutPercent) || requestedPayoutPercent <= 0 || requestedPayoutPercent > 100) {
                showMessage("Requested payout percentage must be between 1 and 100.", "error");
                return;
            }
            if (isNaN(handsForPayout) || handsForPayout <= 0) {
                showMessage("Please enter a valid, positive number of hands for payout.", "error");
                return;
            }

            const investeeProfile = allFirebaseUsersData.find(p => p.uid === investeeUid);
            if (!investeeProfile) {
                showMessage("Could not find the selected player's profile. They may have logged out.", "error");
                populateInvestmentPlayerSelect(); // Refresh player list
                return;
            }
            const investeeName = formatDisplayName(investeeProfile);

            const investmentData = {
                investorUid,
                investorName,
                investeeUid,
                investeeName,
                offerAmount,
                requestedPayoutPercent,
                handsForPayout,
                status: "pending_investee_action", // Initial status
                offerDate: serverTimestamp(),
                acceptedDate: null,
                completedDate: null,
                payoutDate: null,
                handsRemaining: handsForPayout, 
                investorMessage: "",
                investeeMessage: "",
                originalOfferId: null,
                lastUpdated: serverTimestamp()
            };

            showMessage("Submitting investment offer...", "info");
            try {
                await addDoc(investmentsCollectionRef, investmentData);
                showMessage("Investment offer submitted successfully!", "success");
                offerInvestmentForm.reset(); // Clear the form
                populateInvestmentPlayerSelect(); // Refresh chip count and potentially placeholder
                // The list of 'My Shares' will update via a Firestore listener (to be added).
            } catch (error) {
                console.error("Error submitting investment offer:", error);
                showMessage(`Failed to submit offer: ${error.message}`, "error");
            }
        }
        
        // Add event listener for the investment offer form submission
        if (offerInvestmentForm) {
            offerInvestmentForm.addEventListener('submit', handleOfferInvestment);
        }

        function formatDate(timestamp) {
            if (!timestamp || !timestamp.seconds) return 'N/A';
            return new Date(timestamp.seconds * 1000).toLocaleDateString();
        }
        
        function renderMySharesList() {
            if (!mySharesList || !auth.currentUser) return;
            const currentUid = auth.currentUser.uid;
        
            const userShares = firestoreInvestments.filter(inv => inv.investorUid === currentUid);
            mySharesList.innerHTML = ''; // Clear previous list
        
            if (userShares.length === 0) {
                mySharesList.innerHTML = '<p class="text-gray-500 p-3 text-center">You have not offered any shares.</p>';
                return;
            }
        
            userShares.sort((a, b) => (b.offerDate?.seconds || 0) - (a.offerDate?.seconds || 0)); // Newest first
        
            userShares.forEach(share => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'p-3 border rounded-md bg-gray-50 shadow-sm';
                
                let statusText = share.status.replace(/_/g, ' '); // Prettify status
                statusText = statusText.charAt(0).toUpperCase() + statusText.slice(1);
                let statusColor = 'bg-gray-200 text-gray-800'; // Default
                if (share.status === 'pending_investee_action' || share.status === 'pending_investor_action') statusColor = 'bg-yellow-200 text-yellow-800';
                else if (share.status === 'active') statusColor = 'bg-green-200 text-green-800';
                else if (share.status === 'declined' || share.status === 'cancelled') statusColor = 'bg-red-200 text-red-800';
                else if (share.status === 'completed') statusColor = 'bg-blue-200 text-blue-800';

                // Placeholder for ROI calculation
                let roiText = "N/A";
                if (share.status === 'active') {
                    const investeeProfile = allFirebaseUsersData.find(p => p.uid === share.investeeUid);
                    if (investeeProfile && typeof investeeProfile.chip_count === 'number') {
                        const investeeChips = investeeProfile.chip_count;
                        const estimatedReturn = (investeeChips * (share.requestedPayoutPercent || 0)) / 100;
                        roiText = `${Math.round(estimatedReturn)} chips (Est.)`;
                    } else {
                        roiText = "Calculating (Investee data pending)...";
                    }
                } else if (share.status === 'completed') {
                    roiText = `${Math.round(share.actualPayoutAmount || 0)} chips (Paid)`;
                }

                itemDiv.innerHTML = `
                    <div class="flex justify-between items-center mb-1">
                        <p class="font-semibold text-gray-800">Investment in: <span class="font-normal">${share.investeeName || 'N/A'}</span></p>
                        <span class="text-xs px-2 py-0.5 rounded-full ${statusColor}">${statusText}</span>
                    </div>
                    <p class="text-sm text-gray-600">Offered: <span class="font-medium">${share.offerAmount} chips</span></p>
                    <p class="text-sm text-gray-600">Requested Payout: <span class="font-medium">${share.requestedPayoutPercent}%</span></p>
                    <p class="text-sm text-gray-600">Target Hands: <span class="font-medium">${share.handsForPayout}</span></p>
                    <p class="text-sm text-gray-600">Offered Date: <span class="font-medium">${formatDate(share.offerDate)}</span></p>
                    ${share.status === 'active' ? `<p class="text-sm text-gray-600">Hands Remaining: <span class="font-medium">${share.handsRemaining}</span></p>` : ''}
                    ${share.status === 'active' || share.status === 'completed' ? `<p class="text-sm text-gray-600">Return on Investment (ROI): <span class="font-medium">${roiText}</span></p>` : ''}
                    ${share.investeeMessage && (share.status === 'pending_investor_action' || share.status === 'declined_by_investee' || statusText.toLowerCase().includes('rejected')) ? `<div class="mt-2 p-2 bg-orange-100 border-l-4 border-orange-500 text-orange-700 text-xs"><p><strong>Investee Message:</strong> ${share.investeeMessage}</p></div>` : ''}
                    ${share.investorMessage && (share.status === 'pending_investee_action') ? `<div class="mt-2 p-2 bg-blue-100 border-l-4 border-blue-500 text-blue-700 text-xs"><p><strong>Your Last Message (cleared on edit):</strong> ${share.investorMessage}</p></div>` : ''}
                    ${share.investeeMessage && (share.status === 'pending_investee_action') ? `<div class="mt-2 p-2 bg-orange-100 border-l-4 border-orange-500 text-orange-700 text-xs"><p><strong>Investee Feedback:</strong> ${share.investeeMessage}</p></div>` : ''}
                    <div class="mt-2 space-x-2">
                        ${(share.status === 'pending_investee_action') ? `
                            <button data-id="${share.id}" class="edit-share-offer-btn text-xs bg-blue-500 hover:bg-blue-600 text-white py-1 px-2 rounded">Edit Offer</button>
                            <button data-id="${share.id}" class="cancel-share-offer-btn text-xs bg-red-500 hover:bg-red-600 text-white py-1 px-2 rounded">Cancel Offer</button>
                        ` : ''}
                         <!-- No more pending_investor_action specific buttons here for simplified flow -->
                    </div>
                `;
                mySharesList.appendChild(itemDiv);
            });
            // Add event listeners for new buttons (edit, cancel, view message) after rendering
            // This will be done in a separate step or when wiring up specific actions.
        }

        function renderIncomingOffersList() {
            if (!incomingOffersList || !auth.currentUser) return;
            const currentUid = auth.currentUser.uid;

            const receivedOffers = firestoreInvestments.filter(inv => inv.investeeUid === currentUid && (inv.status === 'pending_investee_action' || inv.status === 'pending_investor_action'));
            incomingOffersList.innerHTML = ''; 
        
            if (receivedOffers.length === 0) {
                incomingOffersList.innerHTML = '<p class="text-gray-500 p-3 text-center">You have no incoming investment offers.</p>';
                return;
            }
        
            receivedOffers.sort((a, b) => (b.offerDate?.seconds || 0) - (a.offerDate?.seconds || 0));
        
            receivedOffers.forEach(offer => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'p-3 border rounded-md bg-gray-50 shadow-sm';

                let statusText = offer.status.replace(/_/g, ' ');
                statusText = statusText.charAt(0).toUpperCase() + statusText.slice(1);
                 let statusColor = 'bg-yellow-200 text-yellow-800'; // Default for pending

                itemDiv.innerHTML = `
                    <div class="flex justify-between items-center mb-1">
                        <p class="font-semibold text-gray-800">Offer from: <span class="font-normal">${offer.investorName || 'N/A'}</span></p>
                        <span class="text-xs px-2 py-0.5 rounded-full ${statusColor}">${statusText}</span>
                    </div>
                    <p class="text-sm text-gray-600">Offering: <span class="font-medium">${offer.offerAmount} chips</span></p>
                    <p class="text-sm text-gray-600">For Payout: <span class="font-medium">${offer.requestedPayoutPercent}%</span> of your total chips</p>
                    <p class="text-sm text-gray-600">Payout in: <span class="font-medium">${offer.handsForPayout} hands</span></p>
                    <p class="text-sm text-gray-600">Date Offered: <span class="font-medium">${formatDate(offer.offerDate)}</span></p>
                    ${offer.investorMessage && offer.status === 'pending_investee_action' ? `<div class="mt-2 p-2 bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 text-xs"><p><strong>Investor Message:</strong> ${offer.investorMessage}</p></div>` : ''}
                    ${offer.status === 'pending_investee_action' ? `
                        <div class="mt-3 space-x-2">
                            <button data-id="${offer.id}" class="accept-investment-btn text-xs bg-green-500 hover:bg-green-600 text-white font-bold py-1 px-3 rounded">Accept</button>
                            <button data-id="${offer.id}" class="decline-investment-btn text-xs bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-3 rounded">Decline</button>
                            <button data-id="${offer.id}" class="amend-investment-btn text-xs bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-1 px-3 rounded">Amend</button>
                        </div>
                    ` : ''}
                     ${offer.status === 'pending_investor_action' ? `
                        <div class="mt-2 text-sm text-gray-600">You sent back an amendment. Waiting for investor response.</div>
                        <div class="mt-1 p-2 bg-blue-100 border-l-4 border-blue-500 text-blue-700 text-xs"><p><strong>Your Message:</strong> ${offer.investeeMessage}</p></div>
                    ` : ''}
                `;
                incomingOffersList.appendChild(itemDiv);
            });
            // Add event listeners for accept, decline, amend buttons later.
        }

        function renderMyInvestmentsAsInvesteeList() {
            if (!myInvestmentsAsInvesteeList || !auth.currentUser) return;
            const currentUid = auth.currentUser.uid;
        
            const acceptedInvestments = firestoreInvestments.filter(inv => inv.investeeUid === currentUid && (inv.status === 'active' || inv.status === 'completed'));
            myInvestmentsAsInvesteeList.innerHTML = ''; 
        
            if (acceptedInvestments.length === 0) {
                myInvestmentsAsInvesteeList.innerHTML = '<p class="text-gray-500 p-3 text-center">You have no active or completed investments as an investee.</p>';
                return;
            }
        
            acceptedInvestments.sort((a, b) => (b.acceptedDate?.seconds || b.offerDate?.seconds || 0) - (a.acceptedDate?.seconds || a.offerDate?.seconds || 0));
        
            acceptedInvestments.forEach(inv => {
                const itemDiv = document.createElement('div');
                let statusText = inv.status.replace(/_/g, ' ');
                statusText = statusText.charAt(0).toUpperCase() + statusText.slice(1);
                let itemClasses = 'p-3 border rounded-md shadow-sm';
                let statusColor = '';
                 let roiText = "N/A";

                if (inv.status === 'active') {
                    itemClasses += ' bg-blue-50';
                    statusColor = 'bg-blue-200 text-blue-800';
                    // User is the investee, so use their own chip count
                    const currentUserProfile = allFirebaseUsersData.find(p => p.uid === auth.currentUser.uid);
                    if (currentUserProfile && typeof currentUserProfile.chip_count === 'number') {
                        const currentUserChips = currentUserProfile.chip_count;
                        const estimatedPayout = (currentUserChips * (inv.requestedPayoutPercent || 0)) / 100;
                        roiText = `${Math.round(estimatedPayout)} chips (Est. Payout)`;
                    } else {
                        roiText = "Calculating (Your data pending)...";
                    }
                } else if (inv.status === 'completed') {
                    itemClasses += ' bg-gray-200 opacity-80';
                    statusColor = 'bg-gray-300 text-gray-700';
                    roiText = `${Math.round(inv.actualPayoutAmount || 0)} chips (Paid)`;
                }
                itemDiv.className = itemClasses;
        
                itemDiv.innerHTML = `
                    <div class="flex justify-between items-center mb-1">
                        <p class="font-semibold text-gray-800">Investment from: <span class="font-normal">${inv.investorName || 'N/A'}</span></p>
                        <span class="text-xs px-2 py-0.5 rounded-full ${statusColor}">${statusText}</span>
                    </div>
                    <p class="text-sm text-gray-600">Received: <span class="font-medium">${inv.offerAmount} chips</span></p>
                    <p class="text-sm text-gray-600">Agreed Payout: <span class="font-medium">${inv.requestedPayoutPercent}%</span> of your total chips</p>
                    ${inv.status === 'active' ? `<p class="text-sm text-gray-600">Hands Remaining for Payout: <span class="font-medium">${inv.handsRemaining}</span></p>` : ''}
                    <p class="text-sm text-gray-600">Date Accepted: <span class="font-medium">${formatDate(inv.acceptedDate || inv.offerDate)}</span></p>
                    ${inv.status === 'completed' ? `<p class="text-sm text-gray-600">Date Completed: <span class="font-medium">${formatDate(inv.completedDate)}</span></p>` : ''}
                    <p class="text-sm text-gray-600">Est. Return / Payout: <span class="font-medium">${roiText}</span></p>
                `;
                myInvestmentsAsInvesteeList.appendChild(itemDiv);
            });
        }
        
        // Update investmentsButton listener to call populateInvestmentPlayerSelect
//        if (investmentsButton) {
//            investmentsButton.addEventListener('click', () => {
//                if (auth.currentUser) {
//                    showPanel(investmentsPanel);
//                    // Default to showing the 'Shares' tab and populate its specific content
//                    activateInvestmentsTab(sharesTab, sharesContent);
//                    populateInvestmentPlayerSelect(); 
//                } else {
//                    showMessage("Please log in to access investments.", "info");
//                    showPanel(loginButtonsContainer);
//                }
//            });
//        }

        // Update tab click listeners to also populate necessary data
//        if (sharesTab) {
//            sharesTab.addEventListener('click', () => {
//                activateInvestmentsTab(sharesTab, sharesContent);
//                if (auth.currentUser) {
//                    populateInvestmentPlayerSelect(); // For the offer form on Shares tab
//                    renderMySharesList(); // Re-render to ensure buttons are fresh if data changed
//                }
//            });
//        }
//        if (offersTab) {
//            offersTab.addEventListener('click', () => {
//                activateInvestmentsTab(offersTab, offersContent);
//                if (auth.currentUser) {
//                    renderIncomingOffersList(); // Re-render to ensure buttons are fresh
//                    renderMyInvestmentsAsInvesteeList();
//                }
//            });
//        }

        // Event Delegation for Investment Action Buttons
//        if (mySharesList) {
//            mySharesList.addEventListener('click', (event) => {
//                const target = event.target;
//                const investmentId = target.dataset.id;
//
//                if (!investmentId) return; // Click was not on a button with data-id
//
//                if (target.classList.contains('cancel-share-offer-btn')) {
//                    cancelPendingOffer(investmentId);
//                } else if (target.classList.contains('edit-share-offer-btn')) {
//                    editPendingOffer(investmentId);
//                }
//                // Removed logic for accept-amendment-btn and reject-amendment-btn
//            });
//        }

//        if (incomingOffersList) {
//            incomingOffersList.addEventListener('click', (event) => {
//                const target = event.target;
//                const investmentId = target.dataset.id;
//
//                if (!investmentId) return; // Click was not on a button with data-id
//
//                if (target.classList.contains('accept-investment-btn')) {
//                    acceptInvestment(investmentId);
//                } else if (target.classList.contains('decline-investment-btn')) {
//                    declineInvestment(investmentId);
//                } else if (target.classList.contains('amend-investment-btn')) { // Added this condition
//                    amendInvestment(investmentId);
//                }
//            });
//        }

//        async function acceptInvestment(investmentId) {
//            if (!auth.currentUser) {
//                showMessage("You must be logged in to accept an investment.", "error");
//                return;
//            }
//            const currentUid = auth.currentUser.uid;
//            const investment = firestoreInvestments.find(inv => inv.id === investmentId);
//
//            if (!investment) {
//                showMessage("Investment offer not found.", "error");
//                return;
//            }
//
//            if (investment.investeeUid !== currentUid) {
//                showMessage("You are not authorized to accept this investment.", "error");
//                return;
//            }
//
//            if (investment.status !== 'pending_investee_action') {
//                showMessage(`This investment is no longer pending your action (Status: ${investment.status}).`, "info");
//                return;
//            }
//
//            showMessage("Accepting investment offer...", "info");

//            const investorProfileRef = doc(userProfilesCollectionRef, investment.investorUid);
//            const investeeProfileRef = doc(userProfilesCollectionRef, currentUid); // currentUid is investeeUid
//            const investmentDocRef = doc(investmentsCollectionRef, investmentId);
//
//            try {
//                const investorSnap = await getDoc(investorProfileRef);
//                const investeeSnap = await getDoc(investeeProfileRef);
//
//                if (!investorSnap.exists()) {
//                    showMessage("Investor profile not found. Cannot complete acceptance.", "error");
//                    // Optionally, update investment status to an error state here
//                    await updateDoc(investmentDocRef, { status: 'error_investor_profile_missing', lastUpdated: serverTimestamp() });
//                    return;
 //               }
 //               if (!investeeSnap.exists()) {
 //                   // Should not happen if current user is the investee and logged in
 //                   showMessage("Your profile not found. Cannot complete acceptance.", "error");
 //                   return;
 //               }
//
//                const investorData = investorSnap.data();
//                const investeeData = investeeSnap.data();
//                const investorCurrentChips = investorData.chip_count || 0;
//                const offerAmount = investment.offerAmount;
//
//                if (investorCurrentChips < offerAmount) {
//                    showMessage("Investor does not have sufficient chips to fund this investment. The offer may be void.", "error");
//                    // Update investment status to reflect this issue
//                    await updateDoc(investmentDocRef, { status: 'cancelled_insufficient_funds', lastUpdated: serverTimestamp() });
//                    return;
//                }
//
//                const batch = writeBatch(db);
//
//                const investorInitialChips = investorData.chip_count || 0;
//                const investeeInitialChips = investeeData.chip_count || 0;
//
//                let potentialInvestorNewChips = investorInitialChips - offerAmount;
//                let potentialInvesteeNewChips = investeeInitialChips + offerAmount;
//
//                let finalInvestorChips = Math.round(potentialInvestorNewChips);
//                let finalInvesteeChips = Math.round(potentialInvesteeNewChips);
//
//                const investorHadHalf = Math.abs(potentialInvestorNewChips % 1) === 0.5;
//                const investeeHadHalf = Math.abs(potentialInvesteeNewChips % 1) === 0.5;

//                if (investorHadHalf && investeeHadHalf) {
//                    console.log("Applying .5 random rounding for investment acceptance.");
//                    if (Math.random() < 0.5) { // Investor rounds towards zero, Investee rounds away from zero
//                        finalInvestorChips = (potentialInvestorNewChips > 0) ? Math.floor(potentialInvestorNewChips) : Math.ceil(potentialInvestorNewChips);
//                        finalInvesteeChips = (potentialInvesteeNewChips > 0) ? Math.ceil(potentialInvesteeNewChips) : Math.floor(potentialInvesteeNewChips);
//                    } else { // Investor rounds away from zero, Investee rounds towards zero
//                        finalInvestorChips = (potentialInvestorNewChips > 0) ? Math.ceil(potentialInvestorNewChips) : Math.floor(potentialInvestorNewChips);
//                        finalInvesteeChips = (potentialInvesteeNewChips > 0) ? Math.floor(potentialInvesteeNewChips) : Math.ceil(potentialInvesteeNewChips);
//                    }
//                }
//
                // Ensure chip counts are not negative after rounding
//                finalInvestorChips = Math.max(0, finalInvestorChips);
//                finalInvesteeChips = Math.max(0, finalInvesteeChips);

                // 1. Update investor's chips
 //               batch.update(investorProfileRef, { chip_count: finalInvestorChips });

                // 2. Update investee's chips
//                batch.update(investeeProfileRef, { chip_count: finalInvesteeChips });

                // 3. Update investment document
//                batch.update(investmentDocRef, {
//                    status: 'active',
//                    acceptedDate: serverTimestamp(),
//                    handsRemaining: investment.handsForPayout, // Initialize handsRemaining
//                    lastUpdated: serverTimestamp()
//                });

//                await batch.commit();
//                showMessage("Investment accepted successfully! Chips transferred.", "success");
//                // UI will update via Firestore listener automatically.

//            } catch (error) {
//                console.error("Error accepting investment:", error);
//                showMessage(`Failed to accept investment: ${error.message}`, "error");
//            }
//        }

    </script>
</body>
</html>
