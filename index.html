<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WPS 3.0</title>
    <!-- Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the Inter font and overall body */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* Light grey background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px; /* Add some padding for smaller screens */
            box-sizing: border-box; /* Ensure padding doesn't cause overflow */
        }
        /* Style for the message box (e.g., error/success messages) */
        .message-box {
            padding: 10px;
            border-radius: 8px;
            margin-top: 15px;
            text-align: center;
            font-weight: bold;
        }
        .message-box.error {
            background-color: #fee2e2; /* Red-ish background */
            color: #ef4444; /* Red text */
            border: 1px solid #ef4444;
        }
        .message-box.success {
            background-color: #d1fae5; /* Green-ish background */
            color: #10b981; /* Green text */
            border: 1px solid #10b981;
        }
        .message-box.info {
            background-color: #bfdbfe; /* Blue-ish background */
            color: #3b82f6; /* Blue text */
            border: 1px solid #3b82f6;
        }
        /* Styling for log entries */
        .log-entry {
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            padding: 8px;
            margin-bottom: 4px;
            border-radius: 4px;
            font-size: 0.875rem;
            color: #4b5563;
            text-align: left;
        }
        .log-entry strong {
            color: #1f2937;
        }
        /* Table styles for user management */
        .user-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        .user-table th, .user-table td {
            border: 1px solid #e2e8f0;
            padding: 8px;
            text-align: left;
        }
        .user-table th {
            background-color: #e0f2fe;
            color: #2563eb;
            font-weight: bold;
        }
        .user-table tr:nth-child(even) {
            background-color: #f8fafc;
        }
        .user-table select {
            width: 100%;
            padding: 4px;
            border-radius: 4px;
            border: 1px solid #cbd5e1;
        }
    </style>
</head>
<body class="bg-gray-100 font-inter">

    <!-- Main Login Container -->
    <div class="bg-white p-8 rounded-xl shadow-lg w-full max-w-sm sm:max-w-md md:max-w-lg lg:max-w-xl flex flex-col items-center">
        <h2 class="text-3xl md:text-4xl font-bold text-gray-800 mb-6">WPS Login</h2>

        <!-- Loading Indicator -->
        <div id="loadingIndicator" class="hidden flex items-center justify-center p-4">
            <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <span class="text-gray-600">Initializing Firebase...</span>
        </div>

        <!-- Login Buttons -->
        <div id="loginButtonsContainer" class="w-full flex flex-col items-center space-y-3 hidden">
            <button
                type="button"
                id="googleLoginButton"
                class="w-full flex items-center justify-center bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg"
            >
                <!-- Google Icon SVG -->
                <svg class="w-5 h-5 mr-2" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12.0001 4.5V7.5L17.2501 7.5C17.0279 8.65312 16.3989 9.69736 15.4883 10.4514C14.5776 11.2054 13.4357 11.6212 12.2501 11.6212C9.40006 11.6212 6.99999 9.40871 6.99999 6.55871C6.99999 3.70871 9.40006 1.49621 12.2501 1.49621C13.6874 1.49621 14.9754 2.05267 15.9388 2.92305L18.1565 0.705359C16.5912 -0.80332 14.4754 -1.54716e-07 12.2501 -1.54716e-07C7.26627 -1.54716e-07 3.00006 4.26627 3.00006 9.25006C3.00006 14.2338 7.26627 18.5 12.2501 18.5C14.6738 18.5 16.6346 17.6534 18.0626 16.1436C19.5398 14.6338 19.9999 12.3501 19.9999 9.94006C19.9999 9.25006 19.9312 8.57506 19.8001 7.92506L12.0001 7.92506V4.5Z" fill="#fff"/>
                </svg>
                Sign In with Google
            </button>
            <!-- Email/Password button removed -->
        </div>


        <!-- Message Box for Login Status -->
        <div id="messageBox" class="message-box hidden w-full text-sm md:text-base"></div>

        <!-- Logout Button (Initially hidden) -->
        <button
            id="logoutButton"
            class="hidden mt-4 w-full bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg"
        >
            Logout
        </button>

        <!-- "View User Directory" Button (Initially hidden) -->
        <button
            id="viewUserDirectoryButton"
            class="hidden mt-4 w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg"
        >
            View User Directory
        </button>

        <!-- "Open Account Management" Button (Initially hidden) -->
        <button
            id="openAccountManagementButton"
            class="hidden mt-4 w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg"
        >
            Manage Account
        </button>

        <!-- "Open Admin Panel" Button (Initially hidden, for admins) -->
        <button
            id="openAdminPanelButton"
            class="hidden mt-4 w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg"
        >
            Admin Panel
        </button>

        <!-- Admin Panel (Initially hidden) -->
        <div id="adminPanel" class="hidden mt-8 p-6 bg-gray-50 rounded-xl shadow-inner w-full text-center">
            <h3 class="text-2xl md:text-3xl font-bold text-gray-700 mb-4">Admin Panel</h3>
            <p class="text-gray-600 mb-6 text-sm md:text-base">
                Welcome, Administrator! From here, you can manage users, game data, and other aspects of the WPS system.
                <br>
                <strong class="text-red-500">Note: User management will only show users who have logged in via Firebase Auth.</strong>
            </p>
            <div class="space-y-4">
                <button id="manageUsersButton" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Manage Users
                </button>
                <button class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Manage Game Data
                </button>
                <button class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Configure Games
                </button>
                <!-- "View Activity Logs" button removed -->
                <button id="manageAccountButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Account Management
                </button>
                <button id="closeAdminPanelButton" class="mt-6 w-1/2 mx-auto bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Close Admin Panel
                </button>
            </div>
        </div>

        <!-- User Management Panel (Initially hidden) -->
        <div id="userManagementPanel" class="hidden mt-8 p-6 bg-gray-50 rounded-xl shadow-inner w-full max-w-md md:max-w-lg lg:max-w-xl">
            <h3 class="text-2xl md:text-3xl font-bold text-gray-700 mb-4 text-center">User Management</h3>
            <p class="text-gray-600 mb-4 text-center text-sm md:text-base">
                Assign roles to users who have logged in.
                <br>
                <strong class="text-red-500">Important: This is a client-side role management for demonstration. For production, consider using Firebase Cloud Functions for secure role assignment.</strong>
            </p>
            <div class="overflow-x-auto">
                <table class="user-table text-sm md:text-base">
                    <thead>
                        <tr>
                            <th>Display Name</th>
                            <th>Chip Count</th>
                            <th>Role</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="userRolesTableBody">
                        <!-- User rows will be rendered here -->
                        <tr><td colspan="3" class="text-center text-gray-500">Loading users...</td></tr>
                    </tbody>
                </table>
            </div>
            <div class="flex justify-between space-x-2 mt-4">
                <button id="saveUserRolesButton" class="w-1/2 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Save Changes
                </button>
                <button id="hideUserManagementButton" class="w-1/2 bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Hide Panel
                </button>
            </div>
        </div>

        <!-- Account Management Panel (Initially hidden) -->
        <div id="accountManagementPanel" class="hidden mt-8 p-6 bg-gray-50 rounded-xl shadow-inner w-full max-w-md md:max-w-lg text-center">
            <h3 class="text-2xl md:text-3xl font-bold text-gray-700 mb-4">Account Management</h3>
            <div class="flex flex-col items-center space-y-4">
                <img id="userProfilePic" class="w-24 h-24 md:w-32 md:h-32 rounded-full border-4 border-blue-400 shadow-md" src="" alt="Profile Picture">
                <p class="text-xl md:text-2xl font-semibold text-gray-800" id="currentUserName"></p>
                <p class="text-gray-600 text-sm md:text-base" id="currentUserUsername"></p>
                <p class="text-gray-500 text-xs md:text-sm" id="currentUserProvider"></p>

                <div class="w-full space-y-3 pt-4 border-t border-gray-200 mt-4">
                    <button
                        type="button"
                        id="linkGoogleAccountButton"
                        class="w-full flex items-center justify-center bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75 transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg"
                    >
                        <svg class="w-5 h-5 mr-2" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12.0001 4.5V7.5L17.2501 7.5C17.0279 8.65312 16.3989 9.69736 15.4883 10.4514C14.5776 11.2054 13.4357 11.6212 12.2501 11.6212C9.40006 11.6212 6.99999 9.40871 6.99999 6.55871C6.99999 3.70871 9.40006 1.49621 12.2501 1.49621C13.6874 1.49621 14.9754 2.05267 15.9388 2.92305L18.1565 0.705359C16.5912 -0.80332 14.4754 -1.54716e-07 12.2501 -1.54716e-07C7.26627 -1.54716e-07 3.00006 4.26627 3.00006 9.25006C3.00006 14.2338 7.26627 18.5 12.2501 18.5C14.6738 18.5 16.6346 17.6534 18.0626 16.1436C19.5398 14.6338 19.9999 12.3501 19.9999 9.94006C19.9999 9.25006 19.9312 8.57506 19.8001 7.92506L12.0001 7.92506V4.5Z" fill="#fff"/>
                        </svg>
                        Link with Google
                    </button>
                    <button class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                        Change Password (Placeholder)
                    </button>
                    <button class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                        Update Profile (Placeholder)
                    </button>
                </div>
                <button id="hideAccountManagementButton" class="w-full bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Close Account Management
                </button>
            </div>
        </div>


        <!-- Activity Log Viewer (REMOVED) -->

        <!-- User Directory Panel -->
        <div id="userDirectoryPanel" class="hidden mt-8 p-6 bg-gray-50 rounded-xl shadow-inner w-full max-w-lg md:max-w-xl lg:max-w-2xl">
            <h3 class="text-2xl md:text-3xl font-bold text-gray-700 mb-4 text-center">User Directory</h3>
            <div class="overflow-x-auto">
                <table class="user-table text-sm md:text-base">
                    <thead>
                        <tr>
                            <th>Display Name</th>
                            <th>Chip Count</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="userDirectoryTableBody">
                        <!-- User rows will be rendered here by JavaScript -->
                        <tr><td colspan="2" class="text-center text-gray-500 py-4">Loading...</td></tr>
                    </tbody>
                </table>
            </div>
            <div class="flex justify-center mt-4">
                <button id="hideUserDirectoryPanelButton" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out transform hover:scale-105 text-base md:text-lg">
                    Close
                </button>
            </div>
        </div>

    </div>

    <script type="module">
        // Import Firebase SDKs
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-analytics.js";
        import { getAuth, signInWithCustomToken, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, linkWithPopup, signOut } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, addDoc, onSnapshot, collection, query, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";

        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyBefsHEBuiRyJ31NzF885ac3ugCefzngTU",
            authDomain: "wps-3-be723.firebaseapp.com",
            projectId: "wps-3-be723",
            storageBucket: "wps-3-be723.firebasestorage.app",
            messagingSenderId: "420146617877",
            appId: "1:420146617877:web:ea2e06a690732da76fb81c",
            measurementId: "G-H0Z4C2185Y"
        };

        const appId = typeof __app_id !== 'undefined' ? __app_id : firebaseConfig.projectId;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Initialize Firebase
        const firebaseApp = initializeApp(firebaseConfig);
        const analytics = getAnalytics(firebaseApp);
        const db = getFirestore(firebaseApp, 'wps-database'); // Using named database 'wps-database'
        const auth = getAuth(firebaseApp);
        const googleProvider = new GoogleAuthProvider();


        // Track Firebase authentication readiness and data loading state
        let firebaseAuthReady = false;
        let isLoggingOut = false;
        let dataLoadedAndListenersSetup = false;
        let unsubscribeOwnActiveSessionListener = null; // For self-logout listener


        // --- Super Admin UID (DO NOT TOUCH THIS!) ---
        // This UID will be used to identify the initial administrator account.
        // It should be the Firebase UID of your Google account.
        const SUPER_ADMIN_UID = "Qr3XI0uNYrZ3AECim6XtRvp12MJ2";


        // --- DOM Elements ---
        const loginButtonsContainer = document.getElementById('loginButtonsContainer');
        const googleLoginButton = document.getElementById('googleLoginButton');
        // const emailPasswordLoginButton = document.getElementById('emailPasswordLoginButton'); // Removed
        const messageBox = document.getElementById('messageBox');
        const logoutButton = document.getElementById('logoutButton');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const adminPanel = document.getElementById('adminPanel');

        const manageUsersButton = document.getElementById('manageUsersButton');
        const userManagementPanel = document.getElementById('userManagementPanel');
        const userRolesTableBody = document.getElementById('userRolesTableBody');
        const saveUserRolesButton = document.getElementById('saveUserRolesButton');
        const hideUserManagementButton = document.getElementById('hideUserManagementButton');

        // const viewLogsButton = document.getElementById('viewLogsButton'); // Removed
        // const logViewer = document.getElementById('logViewer'); // Removed
        // const logEntriesContainer = document.getElementById('logEntries'); // Removed
        // const clearLogsButton = document.getElementById('clearLogsButton'); // Removed
        // const hideLogsButton = document.getElementById('hideLogsButton'); // Removed

        const manageAccountButton = document.getElementById('manageAccountButton');
        const accountManagementPanel = document.getElementById('accountManagementPanel');
        const userProfilePic = document.getElementById('userProfilePic');
        const currentUserName = document.getElementById('currentUserName');
        const currentUserUsername = document.getElementById('currentUserUsername');
        const currentUserProvider = document.getElementById('currentUserProvider');
        const linkGoogleAccountButton = document.getElementById('linkGoogleAccountButton');
        const hideAccountManagementButton = document.getElementById('hideAccountManagementButton');

        const viewUserDirectoryButton = document.getElementById('viewUserDirectoryButton'); // Changed ID
        const userDirectoryPanel = document.getElementById('userDirectoryPanel'); 
        const userDirectoryTableBody = document.getElementById('userDirectoryTableBody'); 
        const hideUserDirectoryPanelButton = document.getElementById('hideUserDirectoryPanelButton');

        const openAdminPanelButton = document.getElementById('openAdminPanelButton');
        const openAccountManagementButton = document.getElementById('openAccountManagementButton');
        const closeAdminPanelButton = document.getElementById('closeAdminPanelButton');


        // const logFilterType = document.getElementById('logFilterType'); // Removed
        // const logSearchText = document.getElementById('logSearchText'); // Removed
        // const logSortOrderRadios = document.querySelectorAll('input[name="logSortOrder"]'); // Removed

        let allFirebaseUsersData = []; // Stores user profiles fetched from Firestore
        let firestoreUserRoles = {}; // Stores roles fetched from Firestore
        // let firestoreActivityLogs = []; // Removed
        let firestoreActiveSessions = []; // Stores active sessions from Firestore

        const ROLES = ['disabled', 'player', 'admin', 'owner']; // Defined roles for the system


        // --- Role Helper Functions ---
        function getCurrentUserRole(uid) {
            if (!uid) return 'player'; // Default for cases where UID might be null
            return firestoreUserRoles[uid]?.role || 'player'; // Default to 'player'
        }

        function isOwner(uid) {
            if (!uid) return false;
            // SUPER_ADMIN_UID is always considered an owner for bootstrapping purposes.
            // Otherwise, explicit 'owner' role is required.
            return uid === SUPER_ADMIN_UID || getCurrentUserRole(uid) === 'owner';
        }

        function hasAdminAccess(uid) {
            if (!uid) return false;
            const role = getCurrentUserRole(uid);
            // SUPER_ADMIN_UID, 'owner', or 'admin' roles grant admin panel access.
            return uid === SUPER_ADMIN_UID || role === 'owner' || role === 'admin';
        }

        // --- Listener for Own Active Session (for remote/forced logout detection) ---
        function setupOwnActiveSessionListener(uid) {
            if (unsubscribeOwnActiveSessionListener) {
                console.log("Unsubscribing from previous own active session listener.");
                unsubscribeOwnActiveSessionListener(); 
                unsubscribeOwnActiveSessionListener = null;
            }

            if (!uid) {
                console.error("Cannot setup own active session listener without UID.");
                return; 
            }

            const sessionDocRef = doc(activeSessionsCollectionRef, uid);
            console.log(`Setting up listener for own active session: active_sessions/${uid}`);

            unsubscribeOwnActiveSessionListener = onSnapshot(sessionDocRef, (docSnap) => {
                console.log(`Own active session listener event: exists=${docSnap.exists()}`);
                if (!docSnap.exists()) {
                    // Document was deleted
                    console.log("Own active session document deleted, potentially by force logout or other means.");
                    if (auth.currentUser && auth.currentUser.uid === uid && !isLoggingOut) { 
                        // Check if still the same user and not already in the process of logging out
                        console.log("Current user matches and not already logging out. Initiating self-logout.");
                        isLoggingOut = true; // Set flag early to prevent race conditions/re-entry
                        showMessage("Your session has been ended remotely. You are now being logged out.", "info");
                        
                        if (unsubscribeOwnActiveSessionListener) {
                            console.log("Unsubscribing from own active session listener before forced logout.");
                            unsubscribeOwnActiveSessionListener();
                            unsubscribeOwnActiveSessionListener = null;
                        }

                        // Delay slightly to allow message to be seen, then logout
                        setTimeout(() => {
                            handleLogout(); 
                        }, 3000); 
                    } else {
                        console.log("Self-logout condition not met:", 
                                    {currentUser: auth.currentUser?.uid, targetUid: uid, isLoggingOutFlag: isLoggingOut});
                    }
                }
            }, (error) => {
                console.error(`Error listening to own active session (active_sessions/${uid}):`, error);
                // Optionally, inform the user if this critical listener fails
                // showMessage("Error: Could not monitor session status. Please refresh.", "error");
            });
        }


        // Firestore Collection References (implicitly pointing to 'user-data' database)
        const userRolesCollectionRef = collection(db, `artifacts/${appId}/public/data/user_roles`);
        const activityLogsCollectionRef = collection(db, `artifacts/${appId}/public/data/activity_logs`);
        const userProfilesCollectionRef = collection(db, `artifacts/${appId}/public/data/user_profiles`);
        const activeSessionsCollectionRef = collection(db, `artifacts/${appId}/public/data/active_sessions`);


        // --- Utility Functions ---
        function showPanel(panelToShow) {
            // logViewer variable was removed, so it's no longer in this list.
            const panels = [loginButtonsContainer, adminPanel, userManagementPanel, accountManagementPanel, userDirectoryPanel, loadingIndicator];
            panels.forEach(panel => {
                if (panel === panelToShow) {
                    panel.classList.remove('hidden');
                } else {
                    panel.classList.add('hidden');
                }
            });
        }

        function showMessage(message, type = 'error') {
            messageBox.textContent = message;
            messageBox.className = `message-box ${type} w-full`;
            messageBox.classList.remove('hidden');
            setTimeout(hideMessage, 5000); // Auto-hide messages after 5 seconds
        }

        function hideMessage() {
            messageBox.classList.add('hidden');
        }

        // --- Helper function to format display names ---
        function formatDisplayName(user) {
            if (!user || typeof user.displayName !== 'string' || typeof user.email !== 'string') {
                // Return a fallback if essential user properties are missing or not strings
                return (user && typeof user.displayName === 'string') ? user.displayName : (user && typeof user.email === 'string' ? user.email : 'N/A');
            }

            let displayName = user.displayName;
            // Ensure email is present and is a string before trying to operate on it
            if (user.email && typeof user.email === 'string') {
                const emailParts = user.email.split('@');
                if (emailParts.length === 2) {
                    const emailDomain = emailParts[1].toLowerCase();
                    if (emailDomain === 'wrsdk12.net') {
                        if (!displayName.endsWith(" (School)")) {
                            displayName += " (School)";
                        }
                    }
                }
            }
            return displayName;
        }


        // --- Log System Functions (Firestore Integrated) ---
        // addLogEntry function and its calls are being removed.

        // Log-related functions populateLogFilterTypes, renderLogs, clearLogs REMOVED.
        
        // --- End Log System Functions ---


        // --- User Management Functions (Firestore Integrated) ---
        async function saveUserChangesToFirestore(changesMap) { // Renamed and updated parameter
            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to save user changes.", 'error');
                // addLogEntry("Save User Changes Attempt Failed", { reason: "Permission denied", by: auth.currentUser?.uid }); // Removed
                return;
            }

            const currentUserIsOwner = isOwner(auth.currentUser.uid);
            showMessage("Saving user changes...", 'info');

            try {
                // Fetch current roles and profiles for robust old value checks and to avoid unnecessary writes.
                const rolesSnapshot = await getDocs(userRolesCollectionRef);
                const currentFirestoreRoles = {};
                rolesSnapshot.forEach(doc => currentFirestoreRoles[doc.id] = doc.data());

                const profilesSnapshot = await getDocs(userProfilesCollectionRef);
                const currentFirestoreProfiles = {};
                profilesSnapshot.forEach(doc => currentFirestoreProfiles[doc.id] = doc.data());

                for (const uid in changesMap) {
                    const { newRole, newChipCount } = changesMap[uid];
                    const oldRole = currentFirestoreRoles[uid]?.role || 'player';
                    const oldChipCount = currentFirestoreProfiles[uid]?.chip_count; // Can be undefined or number

                    let roleChanged = oldRole !== newRole;
                    // Chip count comparison needs to handle undefined and ensure numeric comparison
                    let chipCountChanged = typeof oldChipCount === 'undefined' || oldChipCount !== newChipCount;
                    if (typeof newChipCount !== 'number') { // Ensure newChipCount is a number before saving
                        showMessage(`Invalid chip count for user ${uid}. Must be a number.`, 'error');
                        // addLogEntry("Invalid Chip Count Input", {targetUser: uid, value: newChipCount}); // Removed
                        continue; // Skip this user if chip count is not a number
                    }


                    // **Permission Checks**
                    // These apply to both role and chip count changes for simplicity unless specific fine-grained control is needed.
                    // If a user cannot have their role changed, they likely shouldn't have chip count changed by that admin either.

                    // 0. SUPER_ADMIN_UID: Role must be 'owner', chip count cannot be changed by non-owners (effectively, should not be changed by anyone but system/self if needed)
                    if (uid === SUPER_ADMIN_UID) {
                        if (newRole !== 'owner') {
                            showMessage(`SUPER_ADMIN (${uid}) role cannot be changed from 'owner'.`, 'error');
                            // addLogEntry("SUPER_ADMIN Role Change Blocked", { attemptedRole: newRole, by: auth.currentUser.uid }); // Removed
                            roleChanged = false; // Do not proceed with role change
                        }
                        // For SUPER_ADMIN, only allow chip count change if current user is owner (which SUPER_ADMIN is).
                        // Effectively, this means SUPER_ADMIN can change their own chips if UI allowed, or another owner could.
                        // But generally, we want to protect SUPER_ADMIN from accidental changes by other admins.
                        // The UI already disables these fields if current user is not owner.
                        // This server-side check ensures it.
                        if (!currentUserIsOwner && chipCountChanged) {
                             showMessage(`Chip count for SUPER_ADMIN (${uid}) cannot be changed by non-owners.`, 'error');
                             // addLogEntry("SUPER_ADMIN Chip Count Change Blocked", { by: auth.currentUser.uid }); // Removed
                             chipCountChanged = false; // Do not proceed
                        }
                    }
                    // 1. Only an owner can assign the 'owner' role.
                    else if (newRole === 'owner' && !currentUserIsOwner) {
                        showMessage(`You do not have permission to assign 'owner' role to ${uid}.`, 'error');
                        // addLogEntry("Assign Owner Role Failed", { targetUser: uid, by: auth.currentUser.uid }); // Removed
                        roleChanged = false;
                    }
                    // 2. An admin cannot change an owner's role or chip count. Only another owner can.
                    else if (oldRole === 'owner' && !currentUserIsOwner) {
                        if (roleChanged) {
                            showMessage(`You do not have permission to change role of owner ${uid}.`, 'error');
                            // addLogEntry("Modify Owner Role Failed", { targetUser: uid, by: auth.currentUser.uid }); // Removed
                            roleChanged = false;
                        }
                        if (chipCountChanged) {
                            showMessage(`You do not have permission to change chip count of owner ${uid}.`, 'error');
                            // addLogEntry("Modify Owner Chip Count Failed", { targetUser: uid, by: auth.currentUser.uid }); // Removed
                            chipCountChanged = false;
                        }
                    }
                    // 3. Prevent last owner from demoting themselves (SUPER_ADMIN is a fallback).
                    else if (uid === auth.currentUser.uid && currentUserIsOwner && (newRole === 'disabled' || newRole === 'player' || newRole === 'admin')) {
                        const ownersInFirestore = Object.keys(currentFirestoreRoles).filter(id => currentFirestoreRoles[id]?.role === 'owner');
                        // Check against currentFirestoreRoles which is fresh from DB
                        if (ownersInFirestore.length === 1 && ownersInFirestore[0] === uid && uid !== SUPER_ADMIN_UID) {
                           showMessage("Cannot demote the last owner. Assign 'owner' to another user first.", 'error');
                           // addLogEntry("Last Owner Demotion Blocked", { user: uid, newRole: newRole }); // Removed
                           roleChanged = false;
                        }
                    }

                    // Proceed with updates if changes are valid and permissible
                    if (roleChanged) {
                        const roleDocRef = doc(userRolesCollectionRef, uid);
                        await setDoc(roleDocRef, { role: newRole }, { merge: true });
                        // addLogEntry("User Role Changed", { targetUser: uid, oldRole, newRole, by: auth.currentUser.email }); // Removed
                    }

                    if (chipCountChanged && typeof newChipCount === 'number') { // Double check it's a number
                        const profileDocRef = doc(userProfilesCollectionRef, uid);
                        await setDoc(profileDocRef, { chip_count: newChipCount }, { merge: true });
                        // addLogEntry("User Chip Count Changed", { targetUser: uid, oldChipCount: oldChipCount === undefined ? "N/A" : oldChipCount, newChipCount, by: auth.currentUser.email }); // Removed
                    }
                }
                showMessage("User changes processed and saved to Firestore.", 'success');
            } catch (e) {
                console.error("Error saving user changes to Firestore:", e);
                showMessage("Failed to save user changes.", 'error');
            }
        }

        function renderUserRolesTable() {
            userRolesTableBody.innerHTML = '';
            
            if (allFirebaseUsersData.length === 0) {
                userRolesTableBody.innerHTML = '<tr><td colspan="4" class="text-center text-gray-500 py-4">No users found. Users will appear here after they log in.</td></tr>'; // Colspan updated
                return;
            }

            const currentUserId = auth.currentUser?.uid;
            const activeSessionUIDs = firestoreActiveSessions.map(session => session.id); // Get active UIDs
            const currentUserIsAdminOrOwner = hasAdminAccess(currentUserId);
            const currentUserIsOwner = isOwner(currentUserId);


            allFirebaseUsersData.sort((a, b) => (a.displayName || '').localeCompare(b.displayName || '')); // Sort by display name

            allFirebaseUsersData.forEach(user => {
                const row = userRolesTableBody.insertRow();
                const displayNameCell = row.insertCell();
                const chipCountCell = row.insertCell(); // New cell for chip count
                const userRoleCell = row.insertCell();

                displayNameCell.textContent = formatDisplayName(user); // Use helper to format display name

                // Chip count input
                const chipInput = document.createElement('input');
                chipInput.type = 'number';
                chipInput.className = 'border rounded-lg p-1 w-20 text-sm'; // Added w-20 for width
                chipInput.setAttribute('data-uid', user.uid);
                chipInput.setAttribute('name', `chip_count_${user.uid}`);
                chipInput.value = (typeof user.chip_count === 'number') ? user.chip_count : 0;
                chipCountCell.appendChild(chipInput);

                // Role select dropdown
                const select = document.createElement('select');
                select.className = 'border rounded-lg p-1 text-sm';
                select.setAttribute('data-uid', user.uid);
                select.setAttribute('name', `role_${user.uid}`);


                const userCurrentRole = getCurrentUserRole(user.uid);

                ROLES.forEach(role => {
                    const option = document.createElement('option');
                    option.value = role;
                    option.textContent = role;
                    select.appendChild(option);
                });

                select.value = userCurrentRole;

                // **Disable select element and chip input based on permissions**
                let disableRoleSelect = false;
                let disableChipInput = false;

                // 1. If current user doesn't have admin access at all, all fields are disabled.
                if (!currentUserIsAdminOrOwner) {
                    disableRoleSelect = true;
                    disableChipInput = true;
                } else {
                    // 2. SUPER_ADMIN_UID's role dropdown should always be disabled.
                    //    Chip input for SUPER_ADMIN_UID can be edited by an owner.
                    if (user.uid === SUPER_ADMIN_UID) {
                        disableRoleSelect = true;
                        select.value = 'owner'; // Visually reflect owner status
                        if (!currentUserIsOwner) { // Non-owners cannot edit SUPER_ADMIN's chips
                            disableChipInput = true;
                        }
                    }
                    // 3. If the target user is an 'owner' and the current user is not an 'owner' (and target is not SUPER_ADMIN, handled above)
                    //    (Admins cannot change other Owners' roles or chip counts).
                    else if (userCurrentRole === 'owner' && !currentUserIsOwner) {
                        disableRoleSelect = true;
                        disableChipInput = true;
                    }
                }
                select.disabled = disableRoleSelect;
                chipInput.disabled = disableChipInput;

                // Specific option disabling for roles (doesn't apply to chip_count input directly)
                // Disable the 'owner' role option if the current user is not an owner.
                if (!currentUserIsOwner) {
                    const ownerOption = select.querySelector('option[value="owner"]');
                    if (ownerOption) {
                        ownerOption.disabled = true;
                    }
                }

                // Prevent last owner from disabling/demoting self via dropdown directly (UI hint)
                // This is a UI hint; server-side/save function has the definitive check.
                if (user.uid === currentUserId && currentUserIsOwner) {
                    const ownersInFirestore = Object.keys(firestoreUserRoles).filter(id => firestoreUserRoles[id]?.role === 'owner');
                    if (ownersInFirestore.length === 1 && ownersInFirestore[0] === user.uid && user.uid !== SUPER_ADMIN_UID) {
                        ['disabled', 'player', 'admin'].forEach(roleToDisable => {
                            const option = select.querySelector(`option[value="${roleToDisable}"]`);
                            if (option) option.disabled = true;
                        });
                    }
                }


                userRoleCell.appendChild(select);

                // Actions cell
                const actionsCell = row.insertCell();
                const forceLogoutButton = document.createElement('button');
                forceLogoutButton.textContent = 'Force Logout';
                forceLogoutButton.className = 'bg-red-500 hover:bg-red-700 text-white text-xs py-1 px-2 rounded disabled:opacity-50 disabled:cursor-not-allowed';
                
                const targetUserRole = userCurrentRole; // Role of the user in the row
                const targetUserIsOnline = activeSessionUIDs.includes(user.uid);

                let disableLogoutButton = false;

                if (user.uid === currentUserId) { // Cannot logout self
                    disableLogoutButton = true;
                } else if (!targetUserIsOnline) { // Cannot logout an offline user
                    disableLogoutButton = true;
                } else {
                    if (currentUserIsOwner) {
                        // Owners can log out anyone (except self, handled above)
                        disableLogoutButton = false;
                    } else if (currentUserIsAdminOrOwner) { // Current user is Admin (but not Owner)
                        if (targetUserRole === 'owner' || targetUserRole === 'admin') {
                            disableLogoutButton = true; // Admins cannot log out other Admins or Owners
                        }
                    } else { // Current user has no admin/owner access (should not happen if they see the panel, but defensive)
                        disableLogoutButton = true;
                    }
                }

                forceLogoutButton.disabled = disableLogoutButton;
                if (!disableLogoutButton) {
                    forceLogoutButton.onclick = () => forceLogoutUser(user.uid, formatDisplayName(user));
                }
                actionsCell.appendChild(forceLogoutButton);
            });
        }

        function collectAndSaveChanges() { // Function definition renamed
            const newRolesMap = {};
            const changesMap = {}; // Will store { uid: { newRole: 'role', newChipCount: 123 } }
            const rows = userRolesTableBody.querySelectorAll('tr');

            rows.forEach(row => {
                const roleSelect = row.querySelector('select[data-uid]');
                const chipInput = row.querySelector('input[type="number"][data-uid]');

                if (roleSelect && chipInput) {
                    const uid = roleSelect.getAttribute('data-uid');
                    const newRole = roleSelect.value;
                    const newChipCount = parseInt(chipInput.value, 10);

                    if (isNaN(newChipCount)) {
                        showMessage(`Invalid chip count for user with UID ${uid}. Please enter a valid number.`, 'error');
                        // Potentially skip this user or handle error more gracefully
                        return; // Skip this row if chip count is not a number
                    }
                    changesMap[uid] = { newRole, newChipCount };
                }
            });

            if (Object.keys(changesMap).length > 0) {
                saveUserChangesToFirestore(changesMap); // Call the renamed function
            } else {
                showMessage("No user data found to save.", "info");
            }
        }
        // --- End User Management Functions ---

        // --- Admin: Force Logout User ---
        async function forceLogoutUser(targetUid, targetUserDisplayName) {
            console.log(`Attempting to force logout for UID: ${targetUid}, Name: ${targetUserDisplayName}`); // Debug log

            if (!auth.currentUser || !hasAdminAccess(auth.currentUser.uid)) {
                showMessage("You do not have permission to force logout users.", 'error');
                // addLogEntry("Force Logout Attempt Failed", { reason: "Permission denied", targetUser: targetUid, by: auth.currentUser?.uid }); // Removed
                console.error("Force logout permission denied for current user:", auth.currentUser?.uid); // Debug log
                return;
            }

            // Additional permission checks (partially redundant with button disabling logic, but good for direct calls)
            const currentUserId = auth.currentUser.uid;
            console.log(`Current admin UID: ${currentUserId}`); // Debug log
            const currentUserIsOwner = isOwner(currentUserId);
            const targetUserRole = getCurrentUserRole(targetUid); 

            if (targetUid === currentUserId) {
                showMessage("You cannot force logout yourself.", 'error');
                return;
            }

            // This check is primarily for direct calls; button logic should prevent this UI-wise for admins.
            if (!currentUserIsOwner && (targetUserRole === 'owner' || targetUserRole === 'admin')) {
                showMessage("Admins cannot force logout other Admins or Owners.", 'error');
                // addLogEntry("Force Logout Attempt Denied", { reason: "Admin tried to log out admin/owner", targetUser: targetUid, by: currentUserId }); // Removed
                return;
            }

            if (!confirm(`Are you sure you want to force logout ${targetUserDisplayName || targetUid}? This will remove their active session marker.`)) {
                return;
            }
            console.log("Proceeding with force logout confirmation."); // Debug log

            if (!confirm(`Are you sure you want to force logout ${targetUserDisplayName || targetUid}? This will remove their active session marker.`)) {
                console.log("Force logout cancelled by admin."); // Debug log
                return;
            }

            showMessage(`Forcing logout for ${targetUserDisplayName || targetUid}...`, 'info');
            try {
                const activeSessionRef = doc(activeSessionsCollectionRef, targetUid);
                console.log(`Attempting to delete active session doc: active_sessions/${targetUid}`); // Debug log
                await deleteDoc(activeSessionRef);
                console.log(`Successfully deleted active session doc for UID: ${targetUid}`); // Debug log
                
                // addLogEntry("User Forced Logout", { 
                //     targetUser: targetUid, 
                //     targetUserName: targetUserDisplayName || 'N/A',
                //     byUser: auth.currentUser.email || currentUserId 
                // }); // Removed
                showMessage(`${targetUserDisplayName || targetUid} has been marked as logged out. Their status will update shortly.`, 'success');
                
                // Re-render the user management table to update button states (e.g., logout button for the user just logged out should become disabled)
                console.log("Force logout successful, re-rendering user roles table if visible."); // Debug log
                if (!userManagementPanel.classList.contains('hidden')) {
                    renderUserRolesTable();
                }
                // The User Directory table will auto-update if visible due to its own listener on activeSessionsCollectionRef.

            } catch (error) {
                console.error("Error during force logout Firestore operation:", error); // Debug log
                showMessage(`Failed to force logout for ${targetUserDisplayName || targetUid}. Error: ${error.message}`, 'error');
                // addLogEntry("Force Logout Failed", { targetUser: targetUid, error: error.message, by: currentUserId }); // Removed
            }
        }


        // --- "User Directory" Panel Functions (formerly Logged-in Users Panel) ---
        async function showUserDirectoryPanel() { 
            showPanel(userDirectoryPanel); // Corrected variable name
            await renderUserDirectoryTable(); 
            // addLogEntry("User Directory Panel Opened", { user: auth.currentUser?.email || auth.currentUser?.uid }); // Removed for log simplification
        }

        function hideUserDirectoryPanel() { 
            userDirectoryPanel.classList.add('hidden'); // Corrected variable name
            const loggedInUser = JSON.parse(localStorage.getItem('loggedInUser'));
            if (loggedInUser && loggedInUser.hasAdminAccess) {
                showPanel(adminPanel);
            } else if (loggedInUser) {
                // For regular users, perhaps show account management or simply hide, returning to default view.
                // Default view logic after login is handled by onAuthStateChanged or handleLoginSuccess.
                // If they were viewing their account, maybe go back there. For now, just hide.
            }
        }

        async function renderUserDirectoryTable() { 
            userDirectoryTableBody.innerHTML = '<tr><td colspan="3" class="text-center text-gray-500 py-4">Loading users...</td></tr>'; // Updated colspan for 3 columns

            try {
                // Ensure firestoreActiveSessions is available for status check
                const activeSessionUIDs = firestoreActiveSessions.map(session => session.id);

                const querySnapshot = await getDocs(userProfilesCollectionRef);
                const users = [];
                querySnapshot.forEach(doc => {
                    users.push(doc.data());
                });

                userDirectoryTableBody.innerHTML = ''; // Corrected variable name

                if (users.length === 0) {
                    userDirectoryTableBody.innerHTML = '<tr><td colspan="3" class="text-center text-gray-500 py-4">No users found in the directory.</td></tr>'; // Updated colspan
                    return;
                }

                // Sort users by displayName, case-insensitive
                users.sort((a, b) => {
                    const nameA = (formatDisplayName(a) || '').toLowerCase();
                    const nameB = (formatDisplayName(b) || '').toLowerCase();
                    if (nameA < nameB) return -1;
                    if (nameA > nameB) return 1;
                    return 0;
                });

                users.forEach(user => {
                    const row = userDirectoryTableBody.insertRow(); // Corrected variable name
                    const displayNameCell = row.insertCell();
                    const chipCountCell = row.insertCell();
                    const statusCell = row.insertCell();

                    displayNameCell.textContent = formatDisplayName(user);
                    chipCountCell.textContent = (typeof user.chip_count === 'number') ? user.chip_count : '0';

                    // Determine status
                    if (activeSessionUIDs.includes(user.uid)) {
                        statusCell.textContent = 'Online';
                        statusCell.className = 'text-green-600 font-semibold';
                    } else {
                        statusCell.textContent = 'Offline';
                        statusCell.className = 'text-gray-500';
                    }
                });

            } catch (error) {
                console.error("Error fetching user profiles for directory:", error);
                userDirectoryTableBody.innerHTML = '<tr><td colspan="3" class="text-center text-red-500 py-4">Error loading users.</td></tr>'; // Updated colspan
                showMessage("Could not load user directory.", "error");
            }
        }
        // --- End "User Directory" Panel Functions ---


        // --- Account Management Functions ---
        function renderAccountManagementPanel(displayUser) {
            const firebaseUser = auth.currentUser;

            userProfilePic.src = displayUser.profilePic || firebaseUser?.photoURL || 'https://placehold.co/100x100/cccccc/ffffff?text=U';
            userProfilePic.alt = `${displayUser.name || displayUser.username}'s profile picture`;
            currentUserName.textContent = displayUser.name || firebaseUser?.displayName || 'N/A';
            currentUserUsername.textContent = `Email: ${displayUser.username || firebaseUser?.email || 'N/A'}`;

            let providerId = 'Unknown';
            if (firebaseUser) {
                const providers = firebaseUser.providerData.map(p => p.providerId);
                if (providers.includes('google.com')) {
                    providerId = 'Google';
                    linkGoogleAccountButton.classList.add('hidden'); // Already linked with Google
                } else if (providers.includes('password')) {
                    providerId = 'Email/Password';
                    linkGoogleAccountButton.classList.remove('hidden'); // Can link to Google
                } else if (providers.includes('anonymous')) {
                    providerId = 'Anonymous';
                    linkGoogleAccountButton.classList.remove('hidden'); // Can link to Google
                }
            } else {
                providerId = 'No Firebase Session'; // Should not happen if this panel is shown
                linkGoogleAccountButton.classList.remove('hidden');
            }
            currentUserProvider.textContent = `Provider: ${providerId}`;
        }

        async function handleGoogleLink() {
            if (!auth.currentUser) {
                showMessage("No active Firebase user session to link accounts. Please sign in first.", 'error');
                return;
            }

            showMessage("Attempting to link with Google...", 'info');
            try {
                const result = await linkWithPopup(auth.currentUser, googleProvider);
                const linkedUser = result.user;
                console.log("Account linked successfully with Google:", linkedUser);

                const updatedLoggedInUser = {
                    username: linkedUser.email || linkedUser.uid,
                    name: linkedUser.displayName || linkedUser.email,
                    profilePic: linkedUser.photoURL,
                    isAdmin: (linkedUser.uid === SUPER_ADMIN_UID || firestoreUserRoles[linkedUser.uid]?.role === 'admin'),
                    firebaseUid: linkedUser.uid
                };
                localStorage.setItem('loggedInUser', JSON.stringify(updatedLoggedInUser));
                
                showMessage("Account successfully linked with Google!", 'success');
                // addLogEntry("Account Linked", { user: linkedUser.email || linkedUser.uid, provider: "Google" }); // Removed for log simplification
                renderAccountManagementPanel(updatedLoggedInUser);
            } catch (error) {
                console.error("Error linking Google account:", error);
                let errorMessage = "Failed to link Google account.";
                if (error.code === 'auth/credential-already-in-use') {
                    errorMessage = "This Google account is already linked to another user.";
                } else if (error.code === 'auth/popup-closed-by-user') {
                    errorMessage = "Google login window was closed.";
                } else if (error.code === 'auth/invalid-credential') {
                    errorMessage = "Invalid Google credential or already linked to a different account.";
                } else if (error.code === 'auth/email-already-in-use') {
                    errorMessage = "The email associated with this Google account is already in use by another login method. Please sign in with that method and then link.";
                }
                showMessage(errorMessage, 'error');
                // addLogEntry("Account Link Failed", { user: auth.currentUser?.uid || 'Unknown', provider: "Google", error: error.message }); // Removed for log simplification
            }
        }

        // Function to handle successful login and subsequent data loading
        async function handleLoginSuccess(user) {
            console.log("handleLoginSuccess: User authenticated, UID:", user.uid);
            
            // Ensure data loading and listeners setup only once per successful login
            if (!dataLoadedAndListenersSetup) {
                showPanel(loadingIndicator); // Show loading indicator while data is fetched
                loadingIndicator.querySelector('span').textContent = 'Loading user data...';
                await loadInitialData(); // Load user profiles first, if needed separately
                console.log("handleLoginSuccess: Setting up Firestore listeners and awaiting initial data...");
                await setupFirestoreListeners(); // Wait for listeners to load initial data
                console.log("handleLoginSuccess: Firestore listeners initial data loaded.");
                dataLoadedAndListenersSetup = true;
            }

            let userRole = getCurrentUserRole(user.uid); // Use helper, defaults to 'player'

            // Ensure SUPER_ADMIN_UID has 'owner' role in Firestore for consistency and explicitness.
            // The helper functions (isOwner, hasAdminAccess) will grant privileges regardless,
            // but this makes the database state match the effective permissions.
            if (user.uid === SUPER_ADMIN_UID && userRole !== 'owner') {
                // Check against the raw firestoreUserRoles as getCurrentUserRole would default to 'player' if not set
                if (firestoreUserRoles[user.uid]?.role !== 'owner') {
                    console.log(`SUPER_ADMIN_UID (${user.uid}) logged in. Ensuring 'owner' role is set in Firestore.`);
                    const superAdminRoleRef = doc(userRolesCollectionRef, user.uid);
                    try {
                        await setDoc(superAdminRoleRef, { role: 'owner' }, { merge: true });
                        firestoreUserRoles[user.uid] = { role: 'owner' }; // Update local cache
                        userRole = 'owner'; // Update userRole for the current execution context
                        // addLogEntry("SUPER_ADMIN Role Initialized/Verified", { uid: user.uid }); // Removed for log simplification (too internal)
                        console.log(`SUPER_ADMIN_UID (${user.uid}) role set to 'owner' in Firestore.`);
                    } catch (e) {
                        console.error("CRITICAL: Failed to set SUPER_ADMIN_UID role to 'owner' in Firestore:", e);
                        showMessage("Critical: Failed to initialize SUPER_ADMIN role. Contact support.", "error");
                        // Depending on policy, might want to halt login or restrict SUPER_ADMIN if this fails.
                        // For now, proceed as helper functions provide override.
                    }
                } else {
                     // If firestoreUserRoles already shows 'owner' (e.g. from listener update after another owner set it)
                    userRole = 'owner';
                }
            }


            // Ensure a user profile exists in Firestore for the logged-in Firebase user
            if (user) {
                const userProfileRef = doc(userProfilesCollectionRef, user.uid);
                // Prepare base user data
                const userData = {
                    uid: user.uid,
                    email: user.email || null,
                    displayName: user.displayName || user.email || 'Anonymous', // Ensure displayName has a fallback
                    photoURL: user.photoURL || null,
                    lastLogin: new Date().toISOString(),
                    role: userRole // Ensure profile reflects the determined role
                };

                // Check if the user profile document already exists to set chip_count only for new users
                const userProfileSnap = await getDoc(userProfileRef);
                if (!userProfileSnap.exists()) {
                    userData.chip_count = 0; // Initialize chip_count for new users
                    console.log("New user profile created with initial chip_count: 0 for user:", user.uid);
                } else {
                    const existingData = userProfileSnap.data();
                    // Ensure chip_count is a number, defaulting to 0 if it's missing or not a number.
                    if (typeof existingData.chip_count === 'number') {
                        userData.chip_count = existingData.chip_count;
                    } else {
                        userData.chip_count = 0; // Default to 0 if not a number or undefined
                        if (typeof existingData.chip_count !== 'undefined') {
                            console.log(`Existing user profile had a non-numeric chip_count ('${existingData.chip_count}'). Corrected to 0 for user:`, user.uid);
                        } else {
                            console.log("Existing user profile was missing chip_count. Initialized to 0 for user:", user.uid);
                        }
                    }
                }

                await setDoc(userProfileRef, userData, { merge: true });
                console.log("User profile updated/created in Firestore:", user.uid, "with role:", userRole, "and chip_count handling.");

                // Add to active_sessions collection
                const activeSessionRef = doc(activeSessionsCollectionRef, user.uid);
                try {
                    await setDoc(activeSessionRef, {
                        email: user.email || 'N/A',
                        role: userRole,
                        loginTime: new Date().toISOString()
                    }, { merge: true }); // merge:true to update if session doc already exists
                    console.log("User session added/updated in active_sessions:", user.uid);
                    setupOwnActiveSessionListener(user.uid); // Setup listener for self-logout
                } catch (e) {
                    console.error("Error adding/updating user session to active_sessions:", e);
                    // Non-critical, so don't block login, but log it.
                }
            }

            // ** 'Disabled' role check - This is handled in Step 3 of the plan, will be added here later **

            // Determine admin access and prepare user data for local storage
            const userHasAdminAccess = hasAdminAccess(user.uid);

            const finalUserForLocalStorage = {
                username: user.email || user.uid,
                name: formatDisplayName(user), // Format display name here
                profilePic: user.photoURL || 'https://placehold.co/50x50/cccccc/ffffff?text=U',
                hasAdminAccess: userHasAdminAccess, // Updated field name
                firebaseUid: user.uid,
                role: userRole
            };
            localStorage.setItem('loggedInUser', JSON.stringify(finalUserForLocalStorage));

            // ** 'Disabled' role check **
            if (userRole === 'disabled') {
                showMessage("Your account has been disabled. Please contact an administrator.", 'error');
                // addLogEntry("Disabled Account Login Attempt", { user: finalUserForLocalStorage.username, firebaseUid: user.uid }); // Removed
                // Ensure logout happens and no further UI is shown for a disabled user
                // We need to make sure handleLogout doesn't try to re-trigger onAuthStateChanged logic that might re-run this.
                // The isLoggingOut flag in handleLogout should prevent immediate re-login attempts.
                // No need to show other panels or buttons.
                isLoggingOut = true; // Set flag to prevent onAuthStateChanged from re-processing login
                handleLogout(); // This will clear local storage and sign out from Firebase
                showPanel(loginButtonsContainer); // Explicitly show login buttons after logout
                messageBox.classList.remove('hidden'); // Ensure the disabled message stays visible
                loadingIndicator.classList.add('hidden'); // Hide loading indicator
                return; // Stop further execution for disabled users
            }

            // Show welcome message
            showMessage(`Welcome, ${finalUserForLocalStorage.name}! Role: ${userRole}`, 'success');
            // addLogEntry("User Login", { user: finalUserForLocalStorage.username, firebaseUid: user.uid, role: userRole }); // Removed general login, covered by specific Google success/fail
            
            // Show neutral view with main action buttons, hide all content panels initially
            showPanel(null); // This will hide adminPanel, accountManagementPanel, userDirectoryPanel etc.
            loginButtonsContainer.classList.add('hidden'); // Ensure login buttons are hidden

            logoutButton.classList.remove('hidden');
            openAccountManagementButton.classList.remove('hidden');

            if (userHasAdminAccess) {
                openAdminPanelButton.classList.remove('hidden');
                // addLogEntry("Admin Panel Access", { user: finalUserForLocalStorage.username, firebaseUid: user.uid, role: userRole }); // Removed: Redundant with "User Login" and panel is no longer auto-opened
            } else {
                openAdminPanelButton.classList.add('hidden');
            }
            
            const userRoleForButton = finalUserForLocalStorage.role; // Re-check or use userRole directly
            if (userRoleForButton === 'player' || userRoleForButton === 'admin' || userRoleForButton === 'owner') {
                viewUserDirectoryButton.classList.remove('hidden');
            } else {
                viewUserDirectoryButton.classList.add('hidden');
            }
            // Note: renderAccountManagementPanel() will be called when its button is clicked.
            // Admin panel content is static for now, no specific render function on open needed beyond showPanel.
        }

        // Function to handle logout
        async function handleLogout() {
            if (unsubscribeOwnActiveSessionListener) {
                console.log("Unsubscribing from own active session listener during logout.");
                unsubscribeOwnActiveSessionListener();
                unsubscribeOwnActiveSessionListener = null;
            }

            const loggedInUserString = localStorage.getItem('loggedInUser');
            let firebaseUidToClear = null;

            if (loggedInUserString) {
                const user = JSON.parse(loggedInUserString);
                firebaseUidToClear = user.firebaseUid; // Get UID before clearing localStorage
                // addLogEntry("Logout", { user: user.username, isAdmin: user.hasAdminAccess, firebaseUid: user.firebaseUid }); // Removed
            } else if (auth.currentUser) {
                // Fallback if localStorage was cleared but auth session still exists
                firebaseUidToClear = auth.currentUser.uid;
                // addLogEntry("Logout", { user: auth.currentUser.email || "Unknown (from auth)", firebaseUid: auth.currentUser.uid }); // Removed
            } else {
                 // addLogEntry("Logout", { user: "Unknown" }); // Removed
            }

            isLoggingOut = true;

            // Attempt to remove from active_sessions, regardless of signOut success
            if (firebaseUidToClear) {
                try {
                    const activeSessionRef = doc(activeSessionsCollectionRef, firebaseUidToClear);
                    await deleteDoc(activeSessionRef);
                    console.log("User session removed from active_sessions:", firebaseUidToClear);
                } catch (e) {
                    console.error("Error removing user session from active_sessions:", e);
                    // Non-critical, log and continue logout
                }
            }

            try {
                if (auth.currentUser) {
                    await signOut(auth); // Use Firebase signOut function
                    console.log("Firebase: Signed out.");
                }
            } catch (error) {
                console.error("Firebase: Error signing out:", error);
            }

            localStorage.removeItem('loggedInUser');
            dataLoadedAndListenersSetup = false; // Reset for next login
            showMessage('You have been logged out.', 'info');
            showPanel(loginButtonsContainer);
            logoutButton.classList.add('hidden');
            viewUserDirectoryButton.classList.add('hidden');
            openAccountManagementButton.classList.add('hidden');
            openAdminPanelButton.classList.add('hidden');

            // Hide other content panels that might have been open
            adminPanel.classList.add('hidden');
            userManagementPanel.classList.add('hidden');
            // logViewer.classList.add('hidden'); // logViewer removed
            accountManagementPanel.classList.add('hidden');
            if (userDirectoryPanel) { 
                userDirectoryPanel.classList.add('hidden');
            }
            // viewUserDirectoryButton is already handled above
        }

        // Best-effort cleanup on tab close / navigation
        window.addEventListener('beforeunload', async (event) => {
            // Check if there's a logged-in user according to Firebase Auth directly
            if (auth.currentUser && !isLoggingOut) { // !isLoggingOut to prevent double execution during normal logout
                console.log('beforeunload: Attempting to clear active session for user:', auth.currentUser.uid);
                try {
                    const activeSessionRef = doc(activeSessionsCollectionRef, auth.currentUser.uid);
                    // Note: This is a best-effort. Complex async operations in beforeunload are not guaranteed.
                    // For very critical session cleanup, server-side heartbeats or timeouts are more robust.
                    // Here, we make a fire-and-forget attempt.
                    deleteDoc(activeSessionRef).then(() => {
                        console.log('beforeunload: Session cleanup call for', auth.currentUser.uid, 'completed.');
                    }).catch(e => {
                        console.warn('beforeunload: Error in session cleanup call for', auth.currentUser.uid, e);
                    });
                    // Some browsers might require a returnValue to be set to show a confirmation dialog
                    // event.preventDefault(); // If you want to try and show a confirmation
                    // event.returnValue = ''; // Necessary for some browsers
                } catch (e) {
                    console.warn("Error during beforeunload session cleanup for user:", auth.currentUser.uid, e);
                }
            }
        });

        // --- Initial Data Loading (fetches user profiles) ---
        async function loadInitialData() {
            console.log("loadInitialData: Attempting to load user profiles...");
            if (!auth.currentUser) {
                console.warn("loadInitialData: Skipping data load, no authenticated user.");
                return;
            }

            try {
                const querySnapshot = await getDocs(userProfilesCollectionRef);
                allFirebaseUsersData = [];
                querySnapshot.forEach(doc => {
                    allFirebaseUsersData.push(doc.data());
                });
                console.log("Loaded Firebase user profiles:", allFirebaseUsersData.length);
            } catch (error) {
                console.error("Failed to fetch user profiles:", error);
                showMessage(`Failed to load user data: ${error.message}.`, 'error');
                // addLogEntry("Initial data load failed", { error: error.message }); // Removed
            }
        }

        // --- Firestore Real-time Listeners (for user roles and activity logs) ---
        function setupFirestoreListeners() {
            console.log("setupFirestoreListeners: Attempting to set up listeners...");
            if (!auth.currentUser) {
                console.warn("setupFirestoreListeners: Skipping listener setup, no authenticated user.");
                return Promise.resolve(); // Resolve immediately if no user
            }

            // Promise for User Roles
            const rolesPromise = new Promise((resolve, reject) => {
                let initialRolesLoadDone = false;
                const unsubscribeRoles = onSnapshot(userRolesCollectionRef, (snapshot) => {
                    const newRoles = {};
                    snapshot.forEach(doc => {
                        newRoles[doc.id] = doc.data();
                    });
                    firestoreUserRoles = newRoles;
                    console.log("Firestore: User Roles snapshot processed. Roles count:", Object.keys(firestoreUserRoles).length);

                    if (!userManagementPanel.classList.contains('hidden')) {
                        renderUserRolesTable();
                    }

                    const currentUser = auth.currentUser;
                    if (currentUser) {
                        const storedUser = JSON.parse(localStorage.getItem('loggedInUser'));
                        if (storedUser && currentUser.uid === storedUser.firebaseUid) { // Ensure it's the currently logged-in user
                             const newRoleDeterminedByListener = getCurrentUserRole(currentUser.uid);
                             const newHasAdminAccess = hasAdminAccess(currentUser.uid);

                             // Check if either role or admin access status has changed
                             if (storedUser.role !== newRoleDeterminedByListener || storedUser.hasAdminAccess !== newHasAdminAccess) {
                                 console.log(`Real-time: Role/access changed by listener for ${currentUser.uid}. Old role: ${storedUser.role}, New: ${newRoleDeterminedByListener}. Old AdminAccess: ${storedUser.hasAdminAccess}, New: ${newHasAdminAccess}`);

                                 storedUser.role = newRoleDeterminedByListener;
                                 storedUser.hasAdminAccess = newHasAdminAccess;
                                localStorage.setItem('loggedInUser', JSON.stringify(storedUser));

                                 // Handle 'disabled' role immediately if applied mid-session
                                 if (newRoleDeterminedByListener === 'disabled') {
                                    showMessage("Your account has been disabled. Please contact an administrator.", 'error');
                                    // addLogEntry("Account Disabled Mid-Session", { user: currentUser.email || currentUser.uid }); // Removed
                                    handleLogout(); // Force logout
                                    // Resolve promise here as further UI updates for this user are irrelevant
                                    if (!initialRolesLoadDone) {
                                        initialRolesLoadDone = true;
                                        console.log("Firestore: Initial User Roles loaded (resolved after disabled check).");
                                        resolve();
                                    }
                                    return; // Stop further processing for this user in the listener
                                 }

                                 if (newHasAdminAccess) {
                                    showPanel(adminPanel);
                                } else {
                                    showPanel(accountManagementPanel);
                                    renderAccountManagementPanel(storedUser);
                                }
                            }
                        }
                    }

                    if (!initialRolesLoadDone) {
                        initialRolesLoadDone = true;
                        console.log("Firestore: Initial User Roles loaded.");
                        resolve();
                    }
                }, (error) => {
                    console.error("Firestore: Error listening to user roles:", error);
                    showMessage("Error: Could not sync user roles from cloud.", 'error');
                    reject(error);
                });
                // Consider storing unsubscribeRoles if you need to detach listeners later
            });

            // Promise for User Profiles
            const profilesPromise = new Promise((resolve, reject) => {
                let initialProfilesLoadDone = false;
                const unsubscribeProfiles = onSnapshot(userProfilesCollectionRef, (snapshot) => {
                    allFirebaseUsersData = [];
                    snapshot.forEach(doc => {
                        allFirebaseUsersData.push(doc.data());
                    });
                    console.log("Firestore: User Profiles snapshot processed. Profiles count:", allFirebaseUsersData.length);
                    if (!userManagementPanel.classList.contains('hidden')) {
                        renderUserRolesTable();
                    }
                    if (!initialProfilesLoadDone) {
                        initialProfilesLoadDone = true;
                        console.log("Firestore: Initial User Profiles loaded.");
                        resolve();
                    }
                }, (error) => {
                    console.error("Firestore: Error listening to user profiles:", error);
                    showMessage("Error: Could not sync user profiles from cloud.", 'error');
                    reject(error);
                });
            });

            // Promise for Activity Logs (REMOVED)

            // Promise for Active Sessions
            const activeSessionsPromise = new Promise((resolve, reject) => {
                let initialSessionsLoadDone = false;
                const unsubscribeSessions = onSnapshot(activeSessionsCollectionRef, (snapshot) => {
                    const newSessions = [];
                    snapshot.forEach(doc => {
                        newSessions.push({ id: doc.id, ...doc.data() });
                    });
                    firestoreActiveSessions = newSessions;
                    console.log("Firestore: Active Sessions snapshot processed. Sessions count:", firestoreActiveSessions.length);

                    // If the User Directory panel is currently visible, re-render it to update statuses
                    if (userDirectoryPanel && !userDirectoryPanel.classList.contains('hidden')) {
                        renderUserDirectoryTable(); 
                    }

                    if (!initialSessionsLoadDone) {
                        initialSessionsLoadDone = true;
                        console.log("Firestore: Initial Active Sessions loaded.");
                        resolve();
                    }
                }, (error) => {
                    console.error("Firestore: Error listening to active sessions:", error);
                    showMessage("Error: Could not sync active sessions from cloud.", 'error');
                    reject(error);
                });
                // Consider storing unsubscribeSessions if needed
            });

            return Promise.all([rolesPromise, profilesPromise, activeSessionsPromise]); // Removed logsPromise
        }


        // --- Initialize App on DOM Load and Auth State Change ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOMContentLoaded fired. Script is running.');
            showPanel(loadingIndicator); // Show loading indicator immediately

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    // User is authenticated
                    console.log("Firebase: Authenticated. User ID:", user.uid, "Provider:", user.providerData[0]?.providerId || 'N/A');
                    firebaseAuthReady = true;

                    // If not logging out, and data/listeners not yet set up for this session
                    if (!isLoggingOut && !dataLoadedAndListenersSetup) {
                        console.log("onAuthStateChanged: User present and not logging out, triggering handleLoginSuccess.");
                        await handleLoginSuccess(user); // Triggers data load, listener setup, and panel display
                    } else if (isLoggingOut) {
                        console.log("onAuthStateChanged: User present but in logging out state. Skipping automatic login actions.");
                        showPanel(loginButtonsContainer); // Ensure login buttons are shown after logout
                        logoutButton.classList.add('hidden');
                        isLoggingOut = false; // Reset flag
                    } else {
                        // User is authenticated and data/listeners already set up for this session
                        console.log("onAuthStateChanged: User authenticated, data already loaded. Showing appropriate panel.");
                        const storedUser = JSON.parse(localStorage.getItem('loggedInUser'));
                        if (storedUser && storedUser.isAdmin) {
                            showPanel(adminPanel);
                        } else if (storedUser) {
                            showPanel(accountManagementPanel);
                            renderAccountManagementPanel(storedUser);
                        } else {
                            // Fallback if localStorage is somehow out of sync with Firebase auth
                            showPanel(loginButtonsContainer);
                            logoutButton.classList.add('hidden');
                        }
                    }
                    googleLoginButton.disabled = false;
                    // emailPasswordLoginButton.disabled = false; // This line is removed as the element no longer exists

                } else {
                    // No Firebase user is currently authenticated
                    console.log("Firebase: No user authenticated or user logged out.");
                    firebaseAuthReady = true; // Mark auth ready to allow future login attempts

                    if (initialAuthToken && !isLoggingOut) {
                        // Canvas environment: Attempt to sign in with custom token
                        console.log("Firebase: Canvas environment detected. Attempting custom token sign-in.");
                        loadingIndicator.querySelector('span').textContent = 'Authenticating with Canvas...';
                        try {
                            await signInWithCustomToken(auth, initialAuthToken);
                            // If successful, onAuthStateChanged will fire again with `user`, triggering data setup.
                        } catch (error) {
                            console.error("Firebase: Custom authentication failed:", error);
                            showMessage(`Firebase custom auth failed: ${error.message}. Functionality may be limited.`, 'error');
                            showPanel(loginButtonsContainer); // Show login buttons if custom auth fails
                        } finally {
                            loadingIndicator.classList.add('hidden');
                        }
                    } else {
                        // Regular web deployment or after explicit logout
                        console.log("Firebase: Regular deployment or logged out. Displaying login options.");
                        showPanel(loginButtonsContainer);
                        logoutButton.classList.add('hidden');
                        loadingIndicator.classList.add('hidden'); // Hide loading if no auth
                    }
                    // Reset data/listener flag when no user is authenticated
                    dataLoadedAndListenersSetup = false; 
                    googleLoginButton.disabled = false;
                    // emailPasswordLoginButton.disabled = false; // Removed
                }
            });
        });

        // Event listener for Google Login Button (primary login method)
        googleLoginButton.addEventListener('click', async () => {
            console.log('Google Login button clicked.');
            // addLogEntry("Google Login Attempt"); // Removed

            if (!firebaseAuthReady) {
                showMessage("Firebase authentication is not ready yet. Please wait a moment and try again.", 'info');
                return;
            }
            
            googleLoginButton.disabled = true; // Disable button during login attempt
            showMessage("Signing in with Google...", 'info');
            try {
                const result = await signInWithPopup(auth, googleProvider);
                const user = result.user; // Firebase User object
                console.log("Google Sign-In successful:", user);

                await handleLoginSuccess(user); // Pass the Firebase User object directly
                // addLogEntry("Google Login Success", { user: user.email || user.uid }); // Removed

            } catch (error) {
                console.error("Google Sign-In failed:", error);
                let errorMessage = "Google sign-in failed.";
                if (error.code === 'auth/popup-closed-by-user') {
                    errorMessage = "Google login window was closed.";
                } else if (error.code === 'auth/cancelled-popup-request') {
                    errorMessage = "Popup blocked or already open. Please try again.";
                } else if (error.code === 'auth/account-exists-with-different-credential') {
                     errorMessage = `An account already exists with this email using a different login method.`;
                     console.warn(errorMessage, "Provider ID:", error.customData.email, error.credential.providerId);
                } else if (error.code === 'auth/operation-not-allowed') {
                    errorMessage = "Google Sign-In is not enabled in Firebase Authentication settings.";
                }
                showMessage(errorMessage, 'error');
                // addLogEntry("Google Login Failed", { error: error.message }); // Removed
            } finally {
                googleLoginButton.disabled = false; // Re-enable button after attempt
            }
        });

        // Email/Password Login event listener removed.


        // Event listener for logout button
        logoutButton.addEventListener('click', handleLogout);

        // --- Admin Panel Button Event Listeners ---
        manageUsersButton.addEventListener('click', () => {
            const loggedInUser = JSON.parse(localStorage.getItem('loggedInUser'));
            // Use the new 'hasAdminAccess' field from localStorage
            if (loggedInUser && loggedInUser.hasAdminAccess) {
                showPanel(userManagementPanel);
                renderUserRolesTable(); // This will apply new role-based disabling of options
                // addLogEntry("User Management Panel Opened", { user: loggedInUser.username, role: loggedInUser.role }); // Removed for log simplification
            } else {
                showMessage("You do not have administrative access to manage users.", 'error');
                // addLogEntry("User Management Access Denied", { user: loggedInUser?.username || 'Unknown User', attemptedAction: "Open User Management Panel" }); // Removed
            }
        });

        hideUserManagementButton.addEventListener('click', () => {
            showPanel(adminPanel); // Assuming only admins/owners see this button in the first place
        });

        saveUserRolesButton.addEventListener('click', collectAndSaveChanges); // Updated function name


        // Event listeners for log viewer buttons
        viewLogsButton.addEventListener('click', () => {
            const loggedInUser = JSON.parse(localStorage.getItem('loggedInUser'));
            if (loggedInUser && loggedInUser.hasAdminAccess) {
                showPanel(logViewer);
                populateLogFilterTypes();
                renderLogs();
                // addLogEntry("View Logs Button Clicked", { user: loggedInUser.username, role: loggedInUser.role }); // Removed for log simplification
            } else {
                 showMessage("You do not have administrative access to view logs.", 'error');
                 // addLogEntry("View Logs Access Denied", { user: loggedInUser?.username || 'Unknown User', attemptedAction: "View Activity Logs" }); // Removed
            }
        });

        hideLogsButton.addEventListener('click', () => {
            showPanel(adminPanel);
        });

        clearLogsButton.addEventListener('click', clearLogs);

        // Event listeners for log filtering and sorting
        logFilterType.addEventListener('change', renderLogs);
        logSearchText.addEventListener('input', renderLogs);
        logSortOrderRadios.forEach(radio => {
            radio.addEventListener('change', renderLogs);
        });

        // --- Account Management Button Event Listeners ---
        manageAccountButton.addEventListener('click', () => {
            const loggedInUser = JSON.parse(localStorage.getItem('loggedInUser'));
            if (loggedInUser) {
                showPanel(accountManagementPanel);
                renderAccountManagementPanel(loggedInUser);
                // addLogEntry("Account Management Panel Opened", { user: loggedInUser.username }); // Removed for log simplification
            } else {
                showMessage("Please log in to manage your account.", 'info');
            }
        });

        hideAccountManagementButton.addEventListener('click', () => {
            showPanel(null); // Hide account management, return to the neutral view with main action buttons
        });

        linkGoogleAccountButton.addEventListener('click', handleGoogleLink);

        // --- User Directory Panel Button Event Listeners ---
        viewUserDirectoryButton.addEventListener('click', () => { 
            console.log("View User Directory button clicked."); // Debug log
            const loggedInUser = JSON.parse(localStorage.getItem('loggedInUser'));
            console.log("Logged in user for directory view:", loggedInUser); // Debug log
            if (loggedInUser && (loggedInUser.role === 'player' || loggedInUser.role === 'admin' || loggedInUser.role === 'owner')) {
                showUserDirectoryPanel();
            } else {
                showMessage("You do not have permission to view this.", 'error');
                 // addLogEntry("View User Directory Access Denied", { user: loggedInUser?.username || 'Unknown User', role: loggedInUser?.role }); // Removed
            }
        });

        hideUserDirectoryPanelButton.addEventListener('click', hideUserDirectoryPanel); 


        // --- Event Listeners for New "Open Panel" Buttons ---
        openAdminPanelButton.addEventListener('click', () => {
            // Permission check also happens in handleLoginSuccess for button visibility, 
            // but good to have a check here too in case of direct calls or unforeseen UI states.
            if (auth.currentUser && hasAdminAccess(auth.currentUser.uid)) {
                showPanel(adminPanel);
                // addLogEntry("Admin Panel Opened", { trigger: "OpenAdminPanelButton", by: auth.currentUser.email }); // Removed
            } else {
                showMessage("You do not have permission to access the Admin Panel.", "error");
                // Optionally hide the button if it was erroneously shown
                openAdminPanelButton.classList.add('hidden');
            }
        });

        openAccountManagementButton.addEventListener('click', () => {
            const loggedInUser = JSON.parse(localStorage.getItem('loggedInUser'));
            if (loggedInUser && auth.currentUser) { // Ensure there's an active Firebase auth session too
                showPanel(accountManagementPanel);
                // The loggedInUser object from localStorage should have the formatted name.
                // renderAccountManagementPanel expects an object with {name, username, profilePic}
                // and also uses auth.currentUser for provider info.
                renderAccountManagementPanel(loggedInUser); 
                // addLogEntry("Account Management Panel Opened", { trigger: "OpenAccountManagementButton", by: loggedInUser.username }); // Removed
            } else {
                // This case should ideally not be reached if button visibility is managed correctly.
                showMessage("You need to be logged in to manage your account.", "info");
                showPanel(loginButtonsContainer); // Show login as a fallback
            }
        });

        closeAdminPanelButton.addEventListener('click', () => {
            showPanel(null); // Hide admin panel, return to the neutral view with main action buttons
            // Ensure main action buttons are visible if they were part of a container managed by showPanel
            // However, current logic in handleLoginSuccess makes them visible and they are not hidden by showPanel(specificPanel).
        });

    </script>
</body>
</html>
